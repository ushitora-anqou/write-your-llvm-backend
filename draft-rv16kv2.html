<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.11.dev">
<meta name="author" content="艮鮟鱇">
<title>[下書き] LLVMバックエンド for RV16Kv2 開発文書</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
:not(pre)>code.nobreak{word-wrap:normal}
:not(pre)>code.nowrap{white-space:nowrap}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:50%;border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>[下書き] LLVMバックエンド for RV16Kv2 開発文書</h1>
<div class="details">
<span id="author" class="author">艮鮟鱇</span><br>
<span id="email" class="email"><a href="mailto:ushitora@anqou.net">ushitora@anqou.net</a></span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_これはなに">これはなに</a></li>
<li><a href="#_簡単使い方">簡単使い方</a>
<ul class="sectlevel2">
<li><a href="#_ビルドする">ビルドする</a></li>
<li><a href="#_アセンブラを使う">アセンブラを使う</a></li>
<li><a href="#_コンパイラを起動する">コンパイラを起動する</a></li>
</ul>
</li>
<li><a href="#_概要">概要</a></li>
<li><a href="#_ところで">ところで</a></li>
<li><a href="#_参考にすべき資料">参考にすべき資料</a>
<ul class="sectlevel2">
<li><a href="#_webページ">Webページ</a></li>
<li><a href="#_書籍">書籍</a></li>
<li><a href="#_バックエンド">バックエンド</a></li>
</ul>
</li>
<li><a href="#_rv16kv2アーキテクチャ仕様">RV16Kv2アーキテクチャ仕様</a></li>
<li><a href="#_llvmをテストする">LLVMをテストする</a></li>
<li><a href="#_llvmバックエンドの流れ">LLVMバックエンドの流れ</a></li>
<li><a href="#_llvmのソースコードを用意する">LLVMのソースコードを用意する</a></li>
<li><a href="#_スケルトンバックエンドを追加する">スケルトンバックエンドを追加する</a>
<ul class="sectlevel2">
<li><a href="#_rv16kをtripleに追加する">RV16KをTripleに追加する</a></li>
<li><a href="#_rv16kのelf定義を追加する">RV16KのELF定義を追加する</a></li>
<li><a href="#_バックエンドを追加する">バックエンドを追加する</a></li>
</ul>
</li>
<li><a href="#_簡易的なアセンブラを実装する">簡易的なアセンブラを実装する</a>
<ul class="sectlevel2">
<li><a href="#_tablegenファイルを追加する">TableGenファイルを追加する</a></li>
<li><a href="#_rv16k用の_mctargetdesc_を追加する">RV16K用の <code>MCTargetDesc</code> を追加する</a></li>
</ul>
</li>
<li><a href="#_簡易アセンブラのテストを書く">簡易アセンブラのテストを書く</a>
<ul class="sectlevel2">
<li><a href="#_rv16kinstprinter_を実装する"><code>RV16KInstPrinter</code> を実装する</a></li>
<li><a href="#_テストを書く">テストを書く</a></li>
</ul>
</li>
<li><a href="#_アセンブラに残りの命令を追加する">アセンブラに残りの命令を追加する</a>
<ul class="sectlevel2">
<li><a href="#_lwlbulbswsb_命令を追加する"><code>lw/lbu/lb/sw/sb</code> 命令を追加する</a></li>
<li><a href="#_lwspswsp_命令を追加する"><code>lwsp/swsp</code> 命令を追加する</a></li>
<li><a href="#_jjaljalrjrjljlejejnejbjbe_命令を追加する"><code>j/jal/jalr/jr/jl/jle/je/jne/jb/jbe</code> 命令を追加する</a></li>
<li><a href="#_属性を指定する">属性を指定する</a></li>
</ul>
</li>
<li><a href="#_ディスアセンブラを実装する">ディスアセンブラを実装する</a></li>
<li><a href="#_relocationとfixupに対応する">relocationとfixupに対応する</a>
<ul class="sectlevel2">
<li><a href="#_fixupを定義する">Fixupを定義する</a></li>
<li><a href="#_fixupを適用する関数を定義する">Fixupを適用する関数を定義する</a></li>
<li><a href="#_アセンブラにfixupを生成させる">アセンブラにFixupを生成させる</a></li>
<li><a href="#_relocationに対応する">Relocationに対応する</a></li>
<li><a href="#_即値に定数式を書けるようにする">即値に定数式を書けるようにする</a></li>
</ul>
</li>
<li><a href="#_コンパイラのスケルトンを作成する">コンパイラのスケルトンを作成する</a>
<ul class="sectlevel2">
<li><a href="#_rv16kasmprinter_と_rv16kmcinstlower_を追加"><code>RV16KAsmPrinter</code> と <code>RV16KMCInstLower</code> を追加</a></li>
<li><a href="#_rv16kinstrinfo_を追加"><code>RV16KInstrInfo</code> を追加</a></li>
<li><a href="#_rv16kregisterinfo_を追加"><code>RV16KRegisterInfo</code> を追加</a></li>
<li><a href="#_rv16ksubtarget_を追加"><code>RV16KSubtarget</code> を追加</a></li>
<li><a href="#_rv16kpassconfig_を追加"><code>RV16KPassConfig</code> を追加</a></li>
<li><a href="#_rv16kiseldagtodag_を追加"><code>RV16KISelDAGToDAG</code> を追加</a></li>
<li><a href="#_rv16kcallingconv_td_を追加"><code>RV16KCallingConv.td</code> を追加</a></li>
<li><a href="#_rv16kinstrinfo_td_を修正"><code>RV16KInstrInfo.td</code> を修正</a></li>
<li><a href="#_その他">その他</a></li>
</ul>
</li>
<li><a href="#_定数に対応する">定数に対応する</a></li>
<li><a href="#_メモリ操作に対応する">メモリ操作に対応する</a></li>
<li><a href="#_グローバル変数に対応する">グローバル変数に対応する</a></li>
<li><a href="#_条件分岐に対応する">条件分岐に対応する</a></li>
<li><a href="#_関数呼び出しを実装する">関数呼び出しを実装する</a></li>
<li><a href="#_getframeindexreference_をオーバーライドする"><code>getFrameIndexReference</code> をオーバーライドする</a></li>
<li><a href="#_関数プロローグとエピローグを出力する">関数プロローグとエピローグを出力する</a></li>
<li><a href="#_select_に対応する"><code>select</code> に対応する</a></li>
<li><a href="#_落穂拾いをする">落穂拾いをする</a>
<ul class="sectlevel2">
<li><a href="#_大きなスタックフレームに対応する">大きなスタックフレームに対応する</a></li>
<li><a href="#_命令に対するフラグを追加する">命令に対するフラグを追加する</a></li>
<li><a href="#_setcc_に対応する"><code>SETCC</code> に対応する</a></li>
<li><a href="#_キャリー付き加減算に対応する">キャリー付き加減算に対応する</a></li>
<li><a href="#_lowercall_内で_externalsymbolsdnode_を処理する"><code>LowerCall</code> 内で <code>ExternalSymbolSDNode</code> を処理する</a></li>
<li><a href="#_掛け算に対応する">掛け算に対応する</a></li>
<li><a href="#_rotlrotrbswapcttzctlzctpop_に対応する"><code>ROTL/ROTR/BSWAP/CTTZ/CTLZ/CTPOP</code> に対応する</a></li>
<li><a href="#_除算剰余に対応する">除算・剰余に対応する</a></li>
<li><a href="#_32bitのシフトに対応する">32bitのシフトに対応する</a></li>
<li><a href="#_単体の_sextzexttrunc_に対応する">単体の <code>sext/zext/trunc</code> に対応する</a></li>
<li><a href="#_間接ジャンプに対応する">間接ジャンプに対応する</a></li>
<li><a href="#_blockaddress_のlowerに対応する"><code>BlockAddress</code> のlowerに対応する</a></li>
<li><a href="#_ジャンプテーブルに対応しない">ジャンプテーブルに対応しない</a></li>
</ul>
</li>
<li><a href="#_frame_pointer_eliminationに対応する">frame pointer eliminationに対応する</a></li>
<li><a href="#_動的なスタック領域確保に対応する">動的なスタック領域確保に対応する</a></li>
<li><a href="#_関数呼び出しを_jal_で行うようにする">関数呼び出しを <code>jal</code> で行うようにする</a></li>
<li><a href="#_frameindex_をlowerする"><code>FrameIndex</code> をlowerする</a></li>
<li><a href="#_clangをrv16kに対応させる">ClangをRV16Kに対応させる</a>
<ul class="sectlevel2">
<li><a href="#_clangのターゲットにrv16kを追加する">ClangのターゲットにRV16Kを追加する</a></li>
<li><a href="#_clangのdriverにrv16kを追加する">ClangのdriverにRV16Kを追加する</a></li>
<li><a href="#_frame_pointer_eliminationを最適化時に有効にする">frame pointer eliminationを最適化時に有効にする</a></li>
</ul>
</li>
<li><a href="#_スタック経由の引数渡しに対応する">スタック経由の引数渡しに対応する</a></li>
<li><a href="#_hlt_擬似命令を追加する"><code>HLT</code> 擬似命令を追加する</a></li>
<li><a href="#_実行可能ファイルを作る">実行可能ファイルを作る</a>
<ul class="sectlevel2">
<li><a href="#_elfのセクション構造を考える">ELFのセクション構造を考える</a></li>
<li><a href="#_lldにrv16kターゲットを追加する">LLDにRV16Kターゲットを追加する</a></li>
<li><a href="#_clang_で実行可能ファイルを出力する"><code>clang</code> で実行可能ファイルを出力する</a></li>
</ul>
</li>
<li><a href="#_lwsw_の代わりに_lwspswsp_命令を使う"><code>lw/sw</code> の代わりに <code>lwsp/swsp</code> 命令を使う</a></li>
<li><a href="#_続_frameindex_をlowerする">続・ <code>FrameIndex</code> をlowerする</a></li>
<li><a href="#_bcc_を導入する"><code>Bcc</code> を導入する</a></li>
<li><a href="#_分岐解析に対応する">分岐解析に対応する</a></li>
<li><a href="#_jcc_の分岐先が8bitに収まらない場合に対応する"><code>jcc</code> の分岐先が8bitに収まらない場合に対応する</a></li>
<li><a href="#_リンカスクリプトを書く">リンカスクリプトを書く</a>
<ul class="sectlevel2">
<li><a href="#_text_data_rodata_に対応する"><code>.text/.data/.rodata</code> に対応する</a></li>
<li><a href="#_bss_に対応する"><code>.bss</code> に対応する</a></li>
</ul>
</li>
<li><a href="#_脇道_brainfuckインタプリタを動かす">[脇道] Brainfuckインタプリタを動かす</a></li>
<li><a href="#_byvalに対応する">byvalに対応する</a></li>
<li><a href="#_fastccに対応する">fastccに対応する</a></li>
<li><a href="#_インラインアセンブリに対応する">インラインアセンブリに対応する</a></li>
<li><a href="#_emergency_spillに対応しない">emergency spillに対応しない</a></li>
<li><a href="#_frameaddrreturnaddr_に対応する"><code>FRAMEADDR/RETURNADDR</code> に対応する</a></li>
<li><a href="#_pseudobr_を消す"><code>PseudoBR</code> を消す</a></li>
<li><a href="#_rv16k_rtを作る">rv16k-rtを作る</a></li>
<li><a href="#_0_を不正なアドレスにする"><code>0</code> を不正なアドレスにする</a></li>
<li><a href="#_乗算除算剰余に対応">乗算・除算・剰余に対応</a></li>
<li><a href="#_allowregisterrenaming_を_1_にする"><code>AllowRegisterRenaming</code> を <code>1</code> にする</a></li>
<li><a href="#_最適化について調査する">最適化について調査する</a></li>
<li><a href="#_即値命令を追加する">即値命令を追加する</a></li>
<li><a href="#_リンク時最適化lto_link_time_optimizationをかける">リンク時最適化（LTO; Link Time Optimization）をかける</a></li>
<li><a href="#_末尾再帰に対応する">末尾再帰に対応する</a></li>
<li><a href="#_構造体を正しく扱う">構造体を正しく扱う</a></li>
<li><a href="#_risc_vとrv16kの比較">RISC-VとRV16Kの比較</a>
<ul class="sectlevel2">
<li><a href="#_lsiandiorixorilslilsriasri_など即値命令を追加する"><code>lsi/andi/ori/xori/lsli/lsri/asri</code> など即値命令を追加する</a></li>
<li><a href="#_lw0_と_sw0_を追加する"><code>lw0</code> と <code>sw0</code> を追加する</a></li>
<li><a href="#_addi_の即値フィールドを6bitに増やす"><code>addi</code> の即値フィールドを6bitに増やす</a></li>
<li><a href="#_add3_rd_rs1_rs2_を追加する"><code>add3 rd, rs1, rs2</code> を追加する</a></li>
<li><a href="#_irレベルで定数読み込みのコストを考慮に入れる">IRレベルで定数読み込みのコストを考慮に入れる</a></li>
<li><a href="#_サイズ最適化のときはloop_unrollingを抑止する">サイズ最適化のときはloop-unrollingを抑止する</a></li>
<li><a href="#_globalmergepass_を追加する"><code>GlobalMergePass</code> を追加する</a></li>
<li><a href="#_machinescheduler_を有効化する"><code>MachineScheduler</code> を有効化する</a></li>
<li><a href="#_islegaladdressingmodeislegalicmpimmediateislegaladdimmediate_を定義"><code>isLegalAddressingMode/isLegalICmpImmediate/isLegalAddImmediate</code> を定義</a></li>
<li><a href="#_iszextfree_を定義"><code>isZextFree</code> を定義</a></li>
<li><a href="#_再実体化remat_rematerializationの実装">再実体化（remat; rematerialization）の実装</a></li>
</ul>
</li>
<li><a href="#_llvm9に移行する">LLVM9に移行する</a></li>
<li><a href="#_done_line">--- DONE LINE ---</a></li>
<li><a href="#_mallocfreeの実装">malloc/freeの実装</a></li>
<li><a href="#_命令スケジューリングのための情報を命令に付加する">命令スケジューリングのための情報を命令に付加する</a></li>
<li><a href="#_アドレッシングモード">アドレッシング・モード</a></li>
<li><a href="#_関数の可変長引数に対応する">関数の可変長引数に対応する</a></li>
<li><a href="#_コマンドライン引数対応">コマンドライン引数対応</a></li>
<li><a href="#_デバッグ情報を出力する">デバッグ情報を出力する</a></li>
<li><a href="#_参照">参照</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_これはなに">これはなに</h2>
<div class="sectionbody">
<div class="paragraph">
<p>2019年にRV16Kv2という自作ISA用のLLVMバックエンドを作ったときの自分とメンバ用のメモ。
メモなので当然読みにくい。これをブラッシュアップしてまともな文章にする予定だったが、
その作業が遅れているので、一旦メモのまま公開する。内容について質問したい場合は
Twitter <a href="https://twitter.com/ushitora_anqou">@ushitora_anqou</a>までリプライなどを貰えれば反応するかもしれない。</p>
</div>
<div class="paragraph">
<p>この文章は、前に作ったRV32Kv1用LLVMバックエンドで得た知識を前提にして書かれている。
RV32Kv1のメモは<a href="#draft-rv32kv1.adoc">[draft-rv32kv1.adoc]</a>を参照のこと。</p>
</div>
<div class="paragraph">
<p>ソースコードは<a href="https://github.com/virtualsecureplatform/llvm-rv16k">GitHub</a>にある。</p>
</div>
<div class="paragraph">
<p>ブラッシュアップは<a href="https://github.com/ushitora-anqou/write-your-llvm-backend">GitHub</a>にて行っている。</p>
</div>
<div class="paragraph">
<p>このLLVMバックエンドの開発は、もともと2019年度未踏事業において
<a href="https://github.com/virtualsecureplatform/kvsp">Virtual Secure Platform</a>を開発するために行われた。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_簡単使い方">簡単使い方</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_ビルドする">ビルドする</h3>
<div class="paragraph">
<p>とりあえずビルドする。ビルドには</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>cmake</code></p>
</li>
<li>
<p><code>ninja</code></p>
</li>
<li>
<p><code>clang</code></p>
</li>
<li>
<p><code>clang++</code></p>
</li>
<li>
<p><code>make</code></p>
</li>
<li>
<p><code>lld</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>が必要。</p>
</div>
<div class="paragraph">
<p>これらを入れた後 <code>cmake</code> を次のように走らせる。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cd /path/to/llvm-project
$ mkdir build
$ cd build
$ cmake -G Ninja \
    -DLLVM_ENABLE_PROJECTS="clang;lld" \
    -DCMAKE_BUILD_TYPE="Debug" \
    -DBUILD_SHARED_LIBS=True \
    -DLLVM_USE_SPLIT_DWARF=True \
    -DLLVM_OPTIMIZED_TABLEGEN=True \
    -DLLVM_BUILD_TESTS=True \
    -DCMAKE_C_COMPILER=clang \
    -DCMAKE_CXX_COMPILER=clang++ \
    -DLLVM_USE_LINKER=lld \
    -DLLVM_TARGETS_TO_BUILD="" \
    -DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD="RV16K" \
    ../llvm
$ cmake --build .</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_アセンブラを使う">アセンブラを使う</h3>
<div class="paragraph">
<p>アセンブラを起動する。アセンブラは <code>build/bin/llvm-mc</code> である。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cat foo.s
hoge:
	li a0, 55
	mov a1, a0
	add a1, a0
	j hoge

$ bin/llvm-mc -arch=rv16k -filetype=obj foo.s | od -tx1z -Ax -v
000000 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00  &gt;.ELF............&lt;
000010 01 00 f6 00 01 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
000020 7c 00 00 00 00 00 00 00 34 00 00 00 00 00 28 00  &gt;|.......4.....(.&lt;
000030 04 00 01 00 08 78 37 00 89 c0 89 e2 00 52 f6 ff  &gt;.....x7......R..&lt;
000040 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
000050 07 00 00 00 00 00 00 00 00 00 00 00 00 00 02 00  &gt;................&lt;
000060 00 2e 74 65 78 74 00 68 6f 67 65 00 2e 73 74 72  &gt;..text.hoge..str&lt;
000070 74 61 62 00 2e 73 79 6d 74 61 62 00 00 00 00 00  &gt;tab..symtab.....&lt;
000080 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
000090 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
0000a0 00 00 00 00 0c 00 00 00 03 00 00 00 00 00 00 00  &gt;................&lt;
0000b0 00 00 00 00 60 00 00 00 1c 00 00 00 00 00 00 00  &gt;....`...........&lt;
0000c0 00 00 00 00 01 00 00 00 00 00 00 00 01 00 00 00  &gt;................&lt;
0000d0 01 00 00 00 06 00 00 00 00 00 00 00 34 00 00 00  &gt;............4...&lt;
0000e0 0c 00 00 00 00 00 00 00 00 00 00 00 04 00 00 00  &gt;................&lt;
0000f0 00 00 00 00 14 00 00 00 02 00 00 00 00 00 00 00  &gt;................&lt;
000100 00 00 00 00 40 00 00 00 20 00 00 00 01 00 00 00  &gt;....@... .......&lt;
000110 02 00 00 00 04 00 00 00 10 00 00 00              &gt;............&lt;
00011c

$ bin/llvm-mc -arch=rv16k -show-encoding foo.s
	.text
hoge:
	li	a0, 55                  # encoding: [0x08,0x78,0x37,0x00]
	mov	a1, a0                  # encoding: [0x89,0xc0]
	add	a1, a0                  # encoding: [0x89,0xe2]
	j	hoge                    # encoding: [0x00,0x52,A,A]
                                        #   fixup A - offset: 2, value: hoge, kind: fixup_rv16k_pcrel_16bit

$ bin/llvm-mc -filetype=obj -triple=rv16k foo.s | bin/llvm-objdump -d -

&lt;stdin&gt;:	file format ELF32-rv16k

Disassembly of section .text:
0000000000000000 hoge:
       0:	08 78 37 00 	li	a0, 55
       4:	89 c0 	mov	a1, a0
       6:	89 e2 	add	a1, a0
       8:	00 52 f6 ff 	j	-10</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_コンパイラを起動する">コンパイラを起動する</h3>
<div class="paragraph">
<p>まずランタイムライブラリをビルドする必要がある。rv16k-rtレポジトリを <code>git clone</code> し
<code>CC=/path/to/bin/clang</code> をつけて <code>make</code> する。</p>
</div>
<div class="literalblock">
<div class="content">
<pre># rv16k-rt レポジトリをcloneする。
$ git clone git@github.com:ushitora-anqou/rv16k-rt.git

# rv16k-rt をビルドする。 CC 環境変数で、先程ビルドしたclangを指定する。
$ cd rv16k-rt
$ CC=/path/to/bin/clang make</pre>
</div>
</div>
<div class="paragraph">
<p>以下のようなCプログラム <code>foo.c</code> を <code>clang</code> を用いてコンパイルする。
コンパイル時に <code>--sysroot</code> オプションを用いて、先程ビルドしたrv16k-rtのディレクトリを指定する。
なおバイナリサイズを小さくしたい場合は <code>-Oz</code> オプションを指定するなどすればよい。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cat foo.c
int hoge;

int main()
{
    hoge = 42;
    return hoge;
}

$ bin/clang -target rv16k foo.c -o foo.exe --sysroot=/path/to/rv16k-rt</pre>
</div>
</div>
<div class="paragraph">
<p><code>llvm-readelf</code> を用いて <code>.text</code> その他のサイズが分かる。
これがROMサイズ（ <code>0x200 = 512</code> ）未満であることを確認する。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ bin/llvm-readelf -S foo.exe
There are 7 section headers, starting at offset 0x10f0:

Section Headers:
  [Nr] Name              Type            Address  Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .text             PROGBITS        00000000 001000 00002e 00  AX  0   0  4
  [ 2] .bss              NOBITS          00010000 00102e 000002 00  WA  0   0  2
  [ 3] .comment          PROGBITS        00000000 00102e 000028 01  MS  0   0  1
  [ 4] .symtab           SYMTAB          00000000 001058 000050 10      6   2  4
  [ 5] .shstrtab         STRTAB          00000000 0010a8 00002f 00      0   0  1
  [ 6] .strtab           STRTAB          00000000 0010d7 000018 00      0   0  1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)</pre>
</div>
</div>
<div class="paragraph">
<p><code>llvm-objdump</code> を用いて逆アセンブルを行うことができる。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ bin/llvm-objdump -d foo.exe

foo.exe:	file format ELF32-rv16k

Disassembly of section .text:
0000000000000000 _start:
       0:	00 73 06 00 	jal	6
       4:	00 52 fe ff 	j	-2

0000000000000008 main:
       8:	c1 f2 	addi	sp, -4
       a:	21 80 	swsp	fp, 2(sp)
       c:	12 e0 	mov	fp, sp
       e:	42 f2 	addi	fp, 4
      10:	08 78 00 00 	li	a0, 0
      14:	82 92 fc ff 	sw	a0, -4(fp)
      18:	08 78 00 00 	li	a0, 0
      1c:	88 b2 00 00 	lw	a0, 0(a0)
      20:	12 a0 	lwsp	fp, 2(sp)
      22:	41 f2 	addi	sp, 4
      24:	00 40 	jr	ra</pre>
</div>
</div>
<div class="paragraph">
<p><code>rv16k-sim</code> を使ってシミュレーションを行う。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ~/ano/secure_vm/rv16k-sim/main foo.exe 20
ROM: 0000 0073
ROM: 0002 0600
ROM: 0004 0052
ROM: 0006 FEFF
ROM: 0008 C1F2
ROM: 000A 2180
ROM: 000C 12E0
ROM: 000E 42F2
ROM: 0010 0878
ROM: 0012 0000
ROM: 0014 8292
ROM: 0016 FCFF
ROM: 0018 0878
ROM: 001A 0000
ROM: 001C 88B2
ROM: 001E 0000
ROM: 0020 12A0
ROM: 0022 41F2
ROM: 0024 0040

RAM: 0000 2A00

Inst:JAL	PC &lt;= 0x0002 Reg x0 &lt;= 0x0004 PC &lt;= 0x0008 FLAGS(SZCV) &lt;= 0000
Inst:ADDI	Reg x1 &lt;= 0x01FA PC &lt;= 0x000A FLAGS(SZCV) &lt;= 0000
Inst:SWSP	DataRam[0x01FC] &lt;= 0x0000 DataRam[0x01FD] &lt;= 0x0000 PC &lt;= 0x000C FLAGS(SZCV) &lt;= 0010
Inst:MOV	Reg x2 &lt;= 0x01FA PC &lt;= 0x000E FLAGS(SZCV) &lt;= 0000
Inst:ADDI	Reg x2 &lt;= 0x01FE PC &lt;= 0x0010 FLAGS(SZCV) &lt;= 0010
Inst:LI	PC &lt;= 0x0012 Reg x8 &lt;= 0x0000 PC &lt;= 0x0014 FLAGS(SZCV) &lt;= 0100
Inst:SW	PC &lt;= 0x0016 DataRam[0x01FA] &lt;= 0x0000 DataRam[0x01FB] &lt;= 0x0000 PC &lt;= 0x0018 FLAGS(SZCV) &lt;= 0000
Inst:LI	PC &lt;= 0x001A Reg x8 &lt;= 0x0000 PC &lt;= 0x001C FLAGS(SZCV) &lt;= 0100
Inst:LW	PC &lt;= 0x001E Reg x8 &lt;= 0x002A PC &lt;= 0x0020 FLAGS(SZCV) &lt;= 0110
Inst:LWSP	Reg x2 &lt;= 0x0000 PC &lt;= 0x0022 FLAGS(SZCV) &lt;= 0010
Inst:ADDI	Reg x1 &lt;= 0x01FE PC &lt;= 0x0024 FLAGS(SZCV) &lt;= 0010
Inst:JR	PC &lt;= 0x0004 FLAGS(SZCV) &lt;= 0000
Inst:J	PC &lt;= 0x0006 PC &lt;= 0x0004 FLAGS(SZCV) &lt;= 0000
Inst:J	PC &lt;= 0x0006 PC &lt;= 0x0004 FLAGS(SZCV) &lt;= 0000
Inst:J	PC &lt;= 0x0006 PC &lt;= 0x0004 FLAGS(SZCV) &lt;= 0000
Inst:J	PC &lt;= 0x0006 PC &lt;= 0x0004 FLAGS(SZCV) &lt;= 0000
Inst:J	PC &lt;= 0x0006 PC &lt;= 0x0004 FLAGS(SZCV) &lt;= 0000
Inst:J	PC &lt;= 0x0006 PC &lt;= 0x0004 FLAGS(SZCV) &lt;= 0000
Inst:J	PC &lt;= 0x0006 PC &lt;= 0x0004 FLAGS(SZCV) &lt;= 0000
Inst:J	PC &lt;= 0x0006 PC &lt;= 0x0004 FLAGS(SZCV) &lt;= 0000
x0=4	x1=510	x2=0	x3=0	x4=0	x5=0	x6=0	x7=0	x8=42	x9=0	x10=0	x11=0	x12=0	x13=0	x14=0	x15=0</pre>
</div>
</div>
<div class="paragraph">
<p><code>x8=42</code> とあるので、正しく実行されていることが分かる。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_概要">概要</h2>
<div class="sectionbody">
<div class="paragraph">
<p>これを読めば自作アーキテクチャ（RV16Kv2）の機械語を出力するLLVMバックエンドを作成することができる。
VSP開発のバス係数を高める意義がある。</p>
</div>
<div class="paragraph">
<p>この文書はAsciiDocを用いて記述されている。
記述方法についてはリファレンス<a href="#asciidoctor_user-manual">[4]</a><a href="#asciidoctor-quickref">[84]</a>を参照のこと。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ところで">ところで</h2>
<div class="sectionbody">
<div class="paragraph">
<p>一度もコンパイラを書いたことがない人は、この文書を読む前に
『低レイヤを知りたい人のためのCコンパイラ作成入門』<a href="#rui-compilerbook">[50]</a>などで一度
フルスクラッチからコンパイラを書くことをおすすめします。</p>
</div>
<div class="paragraph">
<p>また<a href="#krister-writing_gcc_backend">[51]</a>などを参考に、
LLVMではなくGCCにバックエンドを追加することも検討してみてはいかがでしょうか。
意外とGCCのほうが楽かもしれませんよ？</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_参考にすべき資料">参考にすべき資料</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_webページ">Webページ</h3>
<div class="ulist">
<ul>
<li>
<p>Writing an LLVM Backend<a href="#llvm-writing_backend">[18]</a></p>
<div class="ulist">
<ul>
<li>
<p>分かりにくく読みにくい。正直あんまり見ていないが、たまに眺めると有益な情報を見つけたりもする。</p>
</li>
</ul>
</div>
</li>
<li>
<p>The LLVM Target-Independent Code Generator<a href="#llvm-code_generator">[31]</a></p>
<div class="ulist">
<ul>
<li>
<p><a href="#llvm-writing_backend">[18]</a>よりもよほど参考になる。LLVMバックエンドがどのようにLLVM IRをアセンブリに落とすかが明記されている。必読。</p>
</li>
</ul>
</div>
</li>
<li>
<p>TableGenのLLVMのドキュメント<a href="#llvm-tablegen">[21]</a></p>
<div class="ulist">
<ul>
<li>
<p>情報量が少ない。これを読むよりも各種バックエンドのTableGenファイルを読むほうが良い。</p>
</li>
</ul>
</div>
</li>
<li>
<p>LLVM Language Reference Manual<a href="#llvm-langref">[43]</a></p>
<div class="ulist">
<ul>
<li>
<p>LLVM IRについての言語リファレンス。LLVM IRの仕様などを参照できる。必要に応じて読む。</p>
</li>
</ul>
</div>
</li>
<li>
<p>Architecture &amp; Platform Information for Compiler Writers<a href="#llvm-compilerwriterinfo">[68]</a></p>
<div class="ulist">
<ul>
<li>
<p>LLVMで公式に実装されているバックエンドに関するISAの情報が集約されている。Lanaiの言語仕様へのリンクが貴重。</p>
</li>
</ul>
</div>
</li>
<li>
<p>RISC-V support for LLVM projects<a href="#github_riscv-llvm">[10]</a></p>
<div class="ulist">
<ul>
<li>
<p><strong>どちゃくそに参考になる</strong>。以下の開発はこれに基づいて行う。</p>
</li>
<li>
<p>LLVMにRISC-Vサポートを追加するパッチ群。バックエンドを開発するためのチュートリアルも兼ねているらしく <code>docs/</code> 及びそれと対応したpatchが参考になる。</p>
</li>
<li>
<p>またこれについて、開発者が2018 LLVM Developers' Meetingで登壇したときの動画は<a href="#youtube_llvm-backend-development-by-example">[11]</a>より閲覧できる。スライドは<a href="#speakerdeck-llvm_backend_development">[30]</a>より閲覧できる。</p>
</li>
<li>
<p>そのときのCoding Labは<a href="#lowrisc-devmtg18">[48]</a>より閲覧できる。</p>
</li>
</ul>
</div>
</li>
<li>
<p>Create an LLVM Backend for the Cpu0 Architecture<a href="#cpu0">[35]</a></p>
<div class="ulist">
<ul>
<li>
<p>Cpu0という独自アーキテクチャのLLVMバックエンドを作成するチュートリアル。多少古いが、内容が網羅的で参考になる。英語が怪しい。</p>
</li>
</ul>
</div>
</li>
<li>
<p>FPGA開発日記<a href="#fpga_develop_diary">[44]</a></p>
<div class="ulist">
<ul>
<li>
<p>Cpu0の資料<a href="#cpu0">[35]</a>をもとに1からRISC-Vバックエンドを作成する過程がブログエントリとして公開されている。GitHubに実装も公開されている<a href="#fpga_develop_diary-llvm">[65]</a>。</p>
</li>
</ul>
</div>
</li>
<li>
<p>ELVMバックエンド<a href="#elvm-llvm_backend">[36]</a></p>
<div class="ulist">
<ul>
<li>
<p>限られた命令でLLVM IRの機能を達成する例として貴重。でも意外とISAはリッチだったりする。</p>
</li>
<li>
<p>作成者のスライドも参考になる<a href="#elvm-slide">[37]</a>。</p>
</li>
</ul>
</div>
</li>
<li>
<p>2018年度東大CPU実験で開発されたLLVM Backend<a href="#todai_llvm_backend">[40]</a></p>
<div class="ulist">
<ul>
<li>
<p>これについて書かれたAdCのエントリもある<a href="#todai_llvm_backend-article">[41]</a>。</p>
</li>
</ul>
</div>
</li>
<li>
<p>Tutorial: Building a backend in 24 hours<a href="#llvm-anton_korobeynikov_2012">[45]</a></p>
<div class="ulist">
<ul>
<li>
<p>LLVMバックエンドの大まかな動きについてざっとまとめたあと、 <code>ret</code> だけが定義された最低限のLLVMバックエンド ("stub backend") を構成している。</p>
</li>
<li>
<p>Instruction Selection の説明にある <strong>Does bunch of magic and crazy pattern-matching</strong> が好き。</p>
</li>
</ul>
</div>
</li>
<li>
<p>2017 LLVM Developers’ Meeting: M. Braun "Welcome to the back-end: The LLVM machine representation"<a href="#llvm-welcome_to_the_back_end_2017">[46]</a></p>
<div class="ulist">
<ul>
<li>
<p>スライドも公開されている<a href="#welcome_to_the_back_end-slides">[135]</a>。</p>
</li>
<li>
<p>命令選択が終わったあとの中間表現であるLLVM MIR
（ <code>MachineFunction</code> や <code>MachineInstr</code> など）や、それに対する操作の解説。
RegStateやframe index・register scavengerなどの説明が貴重。</p>
</li>
</ul>
</div>
</li>
<li>
<p>Howto: Implementing LLVM Integrated Assembler<a href="#ean10-howto-llvmas">[47]</a></p>
<div class="ulist">
<ul>
<li>
<p>LLVM上でアセンブラを書くためのチュートリアル。アセンブラ単体に焦点を絞ったものは珍しい。</p>
</li>
</ul>
</div>
</li>
<li>
<p>Building an LLVM Backend<a href="#LLVMBackend_2015_03_26_v2">[49]</a></p>
<div class="ulist">
<ul>
<li>
<p>対応するレポジトリが<a href="#github-frasercrmck_llvm_leg">[54]</a>にある。</p>
</li>
</ul>
</div>
</li>
<li>
<p>[LLVMdev] backend documentation<a href="#llvm_dev_ml-059799">[116]</a></p>
<div class="ulist">
<ul>
<li>
<p>llvm-devメーリングリストのバックエンドのよいドキュメントは無いかというスレッド。Cpu0とTriCoreが挙げられているが、深くまで記述したものは無いという回答。</p>
</li>
</ul>
</div>
</li>
<li>
<p>TriCore Backend<a href="#tricore-llvm">[118]</a></p>
<div class="ulist">
<ul>
<li>
<p>TriCoreというアーキテクチャ用のバックエンドを書いたという論文。スライドもある<a href="#tricore-llvm-slides">[117]</a>。ソースコードもGitHub上に上がっているが、どれが公式かわからない<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup>。</p>
</li>
</ul>
</div>
</li>
<li>
<p>Life of an instruction in LLVM<a href="#life_of_an_instruction">[136]</a></p>
<div class="ulist">
<ul>
<li>
<p>Cコードからassemblyまでの流れを概観。</p>
</li>
</ul>
</div>
</li>
<li>
<p>LLVM Backendの紹介<a href="#llvm_backend_intro">[138]</a></p>
<div class="ulist">
<ul>
<li>
<p>「コンパイラ勉強会」<sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup>での、LLVMバックエンドの大きな流れ（特に命令選択）について概観した日本語スライド。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_書籍">書籍</h3>
<div class="ulist">
<ul>
<li>
<p>『きつねさんでもわかるLLVM〜コンパイラを自作するためのガイドブック〜』<a href="#fox-llvm">[7]</a></p>
<div class="ulist">
<ul>
<li>
<p>数少ない日本語資料。Passやバックエンドの各クラスについて説明している。<a href="#llvm-code_generator">[31]</a>と合わせて大まかな流れを掴むのに良い。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>なおLLVMについてGoogleで検索していると"LLVM Cookbook"なる謎の書籍（の電子コピー）が
見つかるが、内容はLLVM公式文書のパクリのようだ<a href="#amazon-llvm_cookbook-customer_review">[139]</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_バックエンド">バックエンド</h3>
<div class="ulist">
<ul>
<li>
<p>RISC-V<a href="#riscv">[5]</a></p>
<div class="ulist">
<ul>
<li>
<p>パッチ群が開発ドキュメントとともに公開されている<a href="#github_riscv-llvm">[10]</a>。移行の開発はこれをベースに行う。</p>
</li>
</ul>
</div>
</li>
<li>
<p>Lanai<a href="#lanai-isa">[103]</a></p>
<div class="ulist">
<ul>
<li>
<p>Googleが開発した32bit RISCの謎アーキテクチャ。全く実用されていないが、バックエンドが単純に設計されておりコメントも豊富のためかなり参考になる<sup class="footnote">[<a id="_footnoteref_3" class="footnote" href="#_footnotedef_3" title="View footnote.">3</a>]</sup>。<sup class="footnote">[<a id="_footnoteref_4" class="footnote" href="#_footnotedef_4" title="View footnote.">4</a>]</sup></p>
</li>
</ul>
</div>
</li>
<li>
<p>Sparc</p>
<div class="ulist">
<ul>
<li>
<p><a href="#llvm-writing_backend">[18]</a>でも説明に使われており、コメントが豊富。</p>
</li>
</ul>
</div>
</li>
<li>
<p>x86</p>
<div class="ulist">
<ul>
<li>
<p>みんな大好きx86。貴重なCISCの資料であり、かつ2オペランド方式を採用する場合に貴重な実装例を与えてくれる。あと <code>EFLAGS</code> の取り回しなども参考になるが、全体的にコードは読みにくい。ただLLVMの命名規則には従うため、他のバックエンドからある程度推論をして読むのが良い。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_rv16kv2アーキテクチャ仕様">RV16Kv2アーキテクチャ仕様</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://docs.google.com/spreadsheets/d/1Q9JPoZLVyqJEC3p_LBYiPLMTjGZgVoNlu-Jx3CFrLNQ/edit?usp=sharing" class="bare">https://docs.google.com/spreadsheets/d/1Q9JPoZLVyqJEC3p_LBYiPLMTjGZgVoNlu-Jx3CFrLNQ/edit?usp=sharing</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_llvmをテストする">LLVMをテストする</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>llvm-lit</code> を使用してLLVMをテストできる。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ bin/llvm-lit test -s  # 全てのテストを実行する
$ bin/llvm-lit -s --filter 'RV16K' test # RV16Kを含むテストを実行する
$ bin/llvm-lit -as --filter 'RV16K' test # テスト結果を詳細に表示する
$ bin/llvm-lit -as --filter 'RV16K' --debug test # デバッグ情報を表示する</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_llvmバックエンドの流れ">LLVMバックエンドの流れ</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>RV16K*</code> はオーバーライドできるメンバ関数を表す。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>LLVM IR code

|
|
v

SelectionDAG (SDNode); RV16Kで扱えない型・操作を含む (not legal)。

|
|  &lt;-- RV16KTargetLowering::RV16KTargetLowering
|  &lt;-- RV16KTargetLowering::Lower*
v

SelectionDAG (SDNode); RV16Kで扱える型・操作のみを含む (legal)。

|
|  &lt;-- RV16KDAGToDAGISel, RV16KInstrInfo
v

SelectionDAG (MachineSDNode); ノードの命令は全てRV16Kのもの。

|
|  &lt;-- RV16KInstrInfo; 命令スケジューリング
v

LLVM MIR (MachineInstr); スケジューリングされた命令列

|  (以下の流れは TargetPassConfig::addMachinePasses に記述されている)
|
|  &lt;-- RV16KTargetLowering::EmitInstrWithCustomInserter;
|          usesCustomInserter フラグが立っている ある MachineInstr の代わりに
|          複数の MachineInstr を挿入したり MachineBasicBlock を追加したりする。
|
|  &lt;-- SSA上での最適化
|
|  &lt;-- レジスタ割り付け
v

LLVM MIR (MachineInstr); 物理レジスタのみを含む命令列（仮想レジスタを含まない）

|
|  &lt;-- RV16KInstrInfo::expandPostRAPseudo
|
|  &lt;-- RV16KFrameLowering::processFunctionBeforeFrameFinalized
|
|  &lt;-- スタックサイズの確定
|
|  &lt;-- RV16KFrameLowering::emitPrologue; 関数プロローグの挿入
|  &lt;-- RV16KFrameLowering::emitEpilogue; 関数エピローグの挿入
|  &lt;-- RV16KRegisterInfo::eliminateFrameIndex; frame indexの消去
|
|  &lt;-- llvm::scavengeFrameVirtualRegs;
|          frame lowering中に必要になった仮想レジスタをscavengeする
v

LLVM MIR (MachineInstr); frame index が削除された命令列

|
|  &lt;-- RV16KPassConfig::addPreEmitPass
|  &lt;-- RV16KPassConfig::addPreEmitPass2
|
|
|  &lt;-- RV16KAsmPrinter
|  &lt;-- PseudoInstExpansion により指定された擬似命令展開の実行
v

MC (MCInst); アセンブリと等価な中間表現</pre>
</div>
</div>
<div class="paragraph">
<p>LLVM MIRについては<a href="#llvm-welcome_to_the_back_end_2017">[46]</a>に詳しい。
各フェーズでの <code>MachineInstr</code> をデバッグ出力させる場合は <code>llc</code> に <code>-print-machineinstrs</code> を
渡せば良い。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_llvmのソースコードを用意する">LLVMのソースコードを用意する</h2>
<div class="sectionbody">
<div class="paragraph">
<p>LLVMのソースコードを取得する。今回の開発ではv8.0.0をベースとする。
Git上でrv16kブランチを作り、その上で開発する。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ git clone https://github.com/llvm/llvm-project.git
$ cd llvm-project
$ git checkout llvmorg-8.0.0
$ git checkout -b rv16k</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_スケルトンバックエンドを追加する">スケルトンバックエンドを追加する</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_rv16kをtripleに追加する">RV16KをTripleに追加する</h3>
<div class="paragraph">
<p>RV16Kは名実ともに16bitアーキテクチャなので、RV32Kとの変更点がままある。
RISC Vは32bitか64bitで参考にならないので、例えばavrなどを参考にすると次のようになる。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>  T.setArch(Triple::rv16k);
  EXPECT_TRUE(T.isArch16Bit());
  EXPECT_FALSE(T.isArch32Bit());
  EXPECT_FALSE(T.isArch64Bit());</pre>
</div>
</div>
<div class="paragraph">
<p>ちなみにavrは<strong>8bit</strong>アーキテクチャだが、8bitを引数に取る命令をLLVMがうまく扱えないらしく
C\++コードを大量に書いてよしなにしているらしい<a href="#llvm-ml-129089">[52]</a>。</p>
</div>
<div class="paragraph">
<p>ところでRV32Kは32bitアーキテクチャとして登録していたが、一方で
<code>get32BitArchVariant</code> で <code>UnknownArch</code> を返しており、ねじれていたのだと分かる。
結局の所このあたりは32bit/64bitで一部同じ命令を使うとか、ユーザーインターフェースの部分とかで
関係する話のようで、とりあえず開発を行う分にはあまり関係なさそうだ。</p>
</div>
</div>
<div class="sect2">
<h3 id="_rv16kのelf定義を追加する">RV16KのELF定義を追加する</h3>
<div class="paragraph">
<p><code>RV16K.def</code> でリロケーションの情報を記載できる。</p>
</div>
<div class="paragraph">
<p><code>ELFObjectFile.h</code> では <code>ELF32</code> としておく。AVRもこうなっている。
多分名前だけの問題だと思う。</p>
</div>
<div class="paragraph">
<p><code>elf-flags.yaml</code> は作らない。</p>
</div>
</div>
<div class="sect2">
<h3 id="_バックエンドを追加する">バックエンドを追加する</h3>
<div class="paragraph">
<p>Apache 2.0 Licenseを明記。</p>
</div>
<div class="paragraph">
<p>Data Layoutの文字列を正確に指定する必要がある。詳細はLLVM IRの言語仕様<a href="#llvm-langref-datalayout">[53]</a>
に載っている。 <code>P</code> を指定してやることでハーバード・アーキテクチャの場合のプログラムメモリ（ROM）
の位置を指定できるようだ。</p>
</div>
<div class="paragraph">
<p>ビルドする。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cmake -G Ninja \
    -DLLVM_ENABLE_PROJECTS="clang;lld" \
    -DCMAKE_BUILD_TYPE="Debug" \
    -DBUILD_SHARED_LIBS=True \
    -DLLVM_USE_SPLIT_DWARF=True \
    -DLLVM_OPTIMIZED_TABLEGEN=True \
    -DLLVM_BUILD_TESTS=True \
    -DCMAKE_C_COMPILER=clang \
    -DCMAKE_CXX_COMPILER=clang++ \
    -DLLVM_USE_LINKER=lld \
    -DLLVM_TARGETS_TO_BUILD="X86" \
    -DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD="RISCV;RV16K" \
    ../llvm
$ cmake --build .</pre>
</div>
</div>
<div class="paragraph">
<p>大量のオプションはビルドを早くするためのものである<a href="#llvm_dev_ml-106187">[96]</a>。</p>
</div>
<div class="paragraph">
<p>RV16Kバックエンドが追加された。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ bin/llc --version
LLVM (http://llvm.org/):
  LLVM version 8.0.0
  DEBUG build with assertions.
  Default target: x86_64-unknown-linux-gnu
  Host CPU: skylake

  Registered Targets:
    riscv32 - 32-bit RISC-V
    riscv64 - 64-bit RISC-V
    rv16k   - RV16K
    x86     - 32-bit X86: Pentium-Pro and above
    x86-64  - 64-bit X86: EM64T and AMD64</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_簡易的なアセンブラを実装する">簡易的なアセンブラを実装する</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_tablegenファイルを追加する">TableGenファイルを追加する</h3>
<div class="paragraph">
<p><code>llvm/include/llvm/Target/Target.td</code> に 主なclassが定義されているので、
overrideしたいフィールドなどは、コメントなどを見ながらここで確認する。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>//===----------------------------------------------------------------------===//
// Instruction set description - These classes correspond to the C++ classes in
// the Target/TargetInstrInfo.h file.
//
class Instruction {
  string Namespace = "";

  dag OutOperandList;       // An dag containing the MI def operand list.
  dag InOperandList;        // An dag containing the MI use operand list.
  string AsmString = "";    // The .s format to print the instruction with.

  // Pattern - Set to the DAG pattern for this instruction, if we know of one,
  // otherwise, uninitialized.
  list&lt;dag&gt; Pattern;

  // The follow state will eventually be inferred automatically from the
  // instruction pattern.

  list&lt;Register&gt; Uses = []; // Default to using no non-operand registers
  list&lt;Register&gt; Defs = []; // Default to modifying no non-operand registers

  // Predicates - List of predicates which will be turned into isel matching
  // code.
  list&lt;Predicate&gt; Predicates = [];

  // Size - Size of encoded instruction, or zero if the size cannot be determined
  // from the opcode.
  int Size = 0;

  // DecoderNamespace - The "namespace" in which this instruction exists, on
  // targets like ARM which multiple ISA namespaces exist.
  string DecoderNamespace = "";

  // Code size, for instruction selection.
  // FIXME: What does this actually mean?
  int CodeSize = 0;

  // Added complexity passed onto matching pattern.
  int AddedComplexity  = 0;

  // These bits capture information about the high-level semantics of the
  // instruction.
  bit isReturn     = 0;     // Is this instruction a return instruction?
  bit isBranch     = 0;     // Is this instruction a branch instruction?
  bit isEHScopeReturn = 0;  // Does this instruction end an EH scope?
  bit isIndirectBranch = 0; // Is this instruction an indirect branch?
  bit isCompare    = 0;     // Is this instruction a comparison instruction?
  bit isMoveImm    = 0;     // Is this instruction a move immediate instruction?
  bit isMoveReg    = 0;     // Is this instruction a move register instruction?
  bit isBitcast    = 0;     // Is this instruction a bitcast instruction?
  bit isSelect     = 0;     // Is this instruction a select instruction?
  bit isBarrier    = 0;     // Can control flow fall through this instruction?
  bit isCall       = 0;     // Is this instruction a call instruction?
  bit isAdd        = 0;     // Is this instruction an add instruction?
  bit isTrap       = 0;     // Is this instruction a trap instruction?
  bit canFoldAsLoad = 0;    // Can this be folded as a simple memory operand?
  bit mayLoad      = ?;     // Is it possible for this inst to read memory?
  bit mayStore     = ?;     // Is it possible for this inst to write memory?
  bit isConvertibleToThreeAddress = 0;  // Can this 2-addr instruction promote?
  bit isCommutable = 0;     // Is this 3 operand instruction commutable?
  bit isTerminator = 0;     // Is this part of the terminator for a basic block?
  bit isReMaterializable = 0; // Is this instruction re-materializable?
  bit isPredicable = 0;     // Is this instruction predicable?
  bit hasDelaySlot = 0;     // Does this instruction have an delay slot?
  bit usesCustomInserter = 0; // Pseudo instr needing special help.
  bit hasPostISelHook = 0;  // To be *adjusted* after isel by target hook.
  bit hasCtrlDep   = 0;     // Does this instruction r/w ctrl-flow chains?
  bit isNotDuplicable = 0;  // Is it unsafe to duplicate this instruction?
  bit isConvergent = 0;     // Is this instruction convergent?
  bit isAsCheapAsAMove = 0; // As cheap (or cheaper) than a move instruction.
  bit hasExtraSrcRegAllocReq = 0; // Sources have special regalloc requirement?
  bit hasExtraDefRegAllocReq = 0; // Defs have special regalloc requirement?
  bit isRegSequence = 0;    // Is this instruction a kind of reg sequence?
                            // If so, make sure to override
                            // TargetInstrInfo::getRegSequenceLikeInputs.
  bit isPseudo     = 0;     // Is this instruction a pseudo-instruction?
                            // If so, won't have encoding information for
                            // the [MC]CodeEmitter stuff.
  bit isExtractSubreg = 0;  // Is this instruction a kind of extract subreg?
                             // If so, make sure to override
                             // TargetInstrInfo::getExtractSubregLikeInputs.
  bit isInsertSubreg = 0;   // Is this instruction a kind of insert subreg?
                            // If so, make sure to override
                            // TargetInstrInfo::getInsertSubregLikeInputs.
  bit variadicOpsAreDefs = 0; // Are variadic operands definitions?

  // Does the instruction have side effects that are not captured by any
  // operands of the instruction or other flags?
  bit hasSideEffects = ?;

  // Is this instruction a "real" instruction (with a distinct machine
  // encoding), or is it a pseudo instruction used for codegen modeling
  // purposes.
  // FIXME: For now this is distinct from isPseudo, above, as code-gen-only
  // instructions can (and often do) still have encoding information
  // associated with them. Once we've migrated all of them over to true
  // pseudo-instructions that are lowered to real instructions prior to
  // the printer/emitter, we can remove this attribute and just use isPseudo.
  //
  // The intended use is:
  // isPseudo: Does not have encoding information and should be expanded,
  //   at the latest, during lowering to MCInst.
  //
  // isCodeGenOnly: Does have encoding information and can go through to the
  //   CodeEmitter unchanged, but duplicates a canonical instruction
  //   definition's encoding and should be ignored when constructing the
  //   assembler match tables.
  bit isCodeGenOnly = 0;

  // Is this instruction a pseudo instruction for use by the assembler parser.
  bit isAsmParserOnly = 0;

  // This instruction is not expected to be queried for scheduling latencies
  // and therefore needs no scheduling information even for a complete
  // scheduling model.
  bit hasNoSchedulingInfo = 0;

  InstrItinClass Itinerary = NoItinerary;// Execution steps used for scheduling.

  // Scheduling information from TargetSchedule.td.
  list&lt;SchedReadWrite&gt; SchedRW;

  string Constraints = "";  // OperandConstraint, e.g. $src = $dst.

  /// DisableEncoding - List of operand names (e.g. "$op1,$op2") that should not
  /// be encoded into the output machineinstr.
  string DisableEncoding = "";

  string PostEncoderMethod = "";
  string DecoderMethod = "";

  // Is the instruction decoder method able to completely determine if the
  // given instruction is valid or not. If the TableGen definition of the
  // instruction specifies bitpattern A??B where A and B are static bits, the
  // hasCompleteDecoder flag says whether the decoder method fully handles the
  // ?? space, i.e. if it is a final arbiter for the instruction validity.
  // If not then the decoder attempts to continue decoding when the decoder
  // method fails.
  //
  // This allows to handle situations where the encoding is not fully
  // orthogonal. Example:
  // * InstA with bitpattern 0b0000????,
  // * InstB with bitpattern 0b000000?? but the associated decoder method
  //   DecodeInstB() returns Fail when ?? is 0b00 or 0b11.
  //
  // The decoder tries to decode a bitpattern that matches both InstA and
  // InstB bitpatterns first as InstB (because it is the most specific
  // encoding). In the default case (hasCompleteDecoder = 1), when
  // DecodeInstB() returns Fail the bitpattern gets rejected. By setting
  // hasCompleteDecoder = 0 in InstB, the decoder is informed that
  // DecodeInstB() is not able to determine if all possible values of ?? are
  // valid or not. If DecodeInstB() returns Fail the decoder will attempt to
  // decode the bitpattern as InstA too.
  bit hasCompleteDecoder = 1;

  /// Target-specific flags. This becomes the TSFlags field in TargetInstrDesc.
  bits&lt;64&gt; TSFlags = 0;

  ///@name Assembler Parser Support
  ///@{

  string AsmMatchConverter = "";

  /// TwoOperandAliasConstraint - Enable TableGen to auto-generate a
  /// two-operand matcher inst-alias for a three operand instruction.
  /// For example, the arm instruction "add r3, r3, r5" can be written
  /// as "add r3, r5". The constraint is of the same form as a tied-operand
  /// constraint. For example, "$Rn = $Rd".
  string TwoOperandAliasConstraint = "";

  /// Assembler variant name to use for this instruction. If specified then
  /// instruction will be presented only in MatchTable for this variant. If
  /// not specified then assembler variants will be determined based on
  /// AsmString
  string AsmVariantName = "";

  ///@}

  /// UseNamedOperandTable - If set, the operand indices of this instruction
  /// can be queried via the getNamedOperandIdx() function which is generated
  /// by TableGen.
  bit UseNamedOperandTable = 0;

  /// Should FastISel ignore this instruction. For certain ISAs, they have
  /// instructions which map to the same ISD Opcode, value type operands and
  /// instruction selection predicates. FastISel cannot handle such cases, but
  /// SelectionDAG can.
  bit FastISelShouldIgnore = 0;
}</pre>
</div>
</div>
<div class="paragraph">
<p>RISC Vがx0〜x7について <code>CostPerUse</code> を <code>1</code> に設定しているのは、
圧縮命令セット（RV32C）の命令のオペランドにも使えるレジスタを優先的に使ってほしいかららしい。
この設定はRV32Cが有効になっていないとき（ <code>llvm-mc</code> に <code>-mattr=c</code> を渡さないとき）にも
反映されるが、とくに不都合はないようだ。</p>
</div>
<div class="paragraph">
<p><code>field bits&lt;16&gt; Inst</code> はどこからも参照されていないが、なぜか命令のエンコードとしてはたらく。
ハードコードされているようだ（TODO　未確認）。 <code>Inst</code> を使う場合は
<code>MCCodeEmitter::encodeInstrution</code> で <code>getBinaryCodeForInstr</code> を呼ぶだけでエンコードが原則完了する。
一方使わない場合（x86など）は自前でコード生成を行う必要があるようだ。</p>
</div>
<div class="paragraph">
<p><code>field</code> がついている場合といない場合の違いは良くわからない（TODO）が、
フィールドであることを明示する以上の意味はなさそうだ。</p>
</div>
<div class="paragraph">
<p>TableGenファイルを書いた後はそれが正しいかテストをしておく。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ bin/llvm-tblgen -I ../llvm/lib/Target/RV16K/ -I ../llvm/include/ -I ../llvm/lib/Target/ ../llvm/lib/Target/RV16K/RV16K.td</pre>
</div>
</div>
<div class="paragraph">
<p>またTableGenが仕事をするように <code>CMakeLists.txt</code> を書き換えておく。</p>
</div>
</div>
<div class="sect2">
<h3 id="_rv16k用の_mctargetdesc_を追加する">RV16K用の <code>MCTargetDesc</code> を追加する</h3>
<div class="paragraph">
<p><code>createRV16KMCRegisterInfo</code> 内で呼び出す <code>InitRV16KMCRegisterInfo</code> はTableGenが生成する関数で、
内部で <code>llvm::MCRegisterInfo::InitMCRegisterInfo</code> <a href="#llvm_doxygen-InitMCRegisterInfo">[55]</a>
を呼び出している。したがって第一引数に <code>MCRegisterInfo *</code> をとり、
第二引数はreturn addressが入っているレジスタ（RV16Kv2では <code>x0</code> ）を渡せば良い<sup class="footnote">[<a id="_footnoteref_5" class="footnote" href="#_footnotedef_5" title="View footnote.">5</a>]</sup>。また第五引数にはPCを表すレジスタを渡すことができるが、
指定しなければ <code>0</code> が渡される。レジスタ番号 <code>0</code> は無指定であることを意味するようだ（未確認；TODO）。</p>
</div>
<div class="paragraph">
<p><code>RV16KMCCodeEmitter::encodeInstruction</code> では</p>
</div>
<div class="literalblock">
<div class="content">
<pre>const MCInstrDesc &amp;Desc = MCII.get(MI.getOpcode());
unsigned Size = Desc.getSize();</pre>
</div>
</div>
<div class="paragraph">
<p>とすることで、命令の大きさを取得できる。ここで <code>getOpcode</code> で得られる値は
TableGenのフィールドとして指定する <code>Opcode</code> ではなく、LLVMが自動的につける通し番号が返ってくる
（多分。どこかにそう書いてあった気がするが見つけられない。；TODO）。</p>
</div>
<div class="paragraph">
<p>buildしようとするとTableGenがSegmentation falutで落ちた。どうやらCodeEmitter用の
ファイル生成に失敗しているらしい。原因は <code>NOP</code> の <code>rs</code> と <code>rd</code> に <code>0</code> を入れ忘れていたことだった。</p>
</div>
<div class="paragraph">
<p>そうこうしていると命令を限った簡易的なアセンブラができる。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cat foo.s
mov x2, x1
add x2, x1
sub x2, x1
and x2, x1
or  x2, x1
xor x2, x1
lsl x2, x1
lsr x2, x1
asr x2, x1
cmp x2, x1
li x1, 0x7fff
li x1, -0x8000
addi x1, 7
addi x1, -8
cmpi x1, 7
cmpi x1, -8
nop

$ bin/llvm-mc -arch=rv16k -filetype=obj foo.s | od -tx1z -Ax -v
000000 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00  &gt;.ELF............&lt;
000010 01 00 f6 00 01 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
000020 84 00 00 00 00 00 00 00 34 00 00 00 00 00 28 00  &gt;........4.....(.&lt;
000030 04 00 01 00 12 c0 12 e2 12 e3 12 e4 12 e5 12 e6  &gt;................&lt;
000040 12 ea 12 ea 12 ed 12 c3 01 78 ff 7f 01 78 00 80  &gt;.........x...x..&lt;
000050 71 f2 81 f2 71 d3 81 d3 00 00 00 00 00 00 00 00  &gt;q...q...........&lt;
000060 00 00 00 00 00 00 00 00 00 00 00 00 00 2e 74 65  &gt;..............te&lt;
000070 78 74 00 2e 73 74 72 74 61 62 00 2e 73 79 6d 74  &gt;xt..strtab..symt&lt;
000080 61 62 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;ab..............&lt;
000090 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  &gt;................&lt;
0000a0 00 00 00 00 00 00 00 00 00 00 00 00 07 00 00 00  &gt;................&lt;
0000b0 03 00 00 00 00 00 00 00 00 00 00 00 6c 00 00 00  &gt;............l...&lt;
0000c0 17 00 00 00 00 00 00 00 00 00 00 00 01 00 00 00  &gt;................&lt;
0000d0 00 00 00 00 01 00 00 00 01 00 00 00 06 00 00 00  &gt;................&lt;
0000e0 00 00 00 00 34 00 00 00 26 00 00 00 00 00 00 00  &gt;....4...&amp;.......&lt;
0000f0 00 00 00 00 04 00 00 00 00 00 00 00 0f 00 00 00  &gt;................&lt;
000100 02 00 00 00 00 00 00 00 00 00 00 00 5c 00 00 00  &gt;............\...&lt;
000110 10 00 00 00 01 00 00 00 01 00 00 00 04 00 00 00  &gt;................&lt;
000120 10 00 00 00                                      &gt;....&lt;
000124</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_簡易アセンブラのテストを書く">簡易アセンブラのテストを書く</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_rv16kinstprinter_を実装する"><code>RV16KInstPrinter</code> を実装する</h3>
<div class="paragraph">
<p><code>AltNames</code> でアセンブリに出力させる場合、 <code>AltNames</code> が指定されていないレジスタが
あるとエラーが出る。そこで <code>FLAGS</code> にもダミーの <code>AltNames</code> を与えた。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>def FLAGS : RV16KReg&lt;0, "flags", ["flags"]&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>次のように <code>-show-encoding</code> オプションが動くようになった。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ bin/llvm-mc -arch=rv16k -show-encoding foo.s
    .text
    mov     fp, sp                  # encoding: [0x12,0xc0]
    add     fp, sp                  # encoding: [0x12,0xe2]
    sub     fp, sp                  # encoding: [0x12,0xe3]
    and     fp, sp                  # encoding: [0x12,0xe4]
    or      fp, sp                  # encoding: [0x12,0xe5]
    xor     fp, sp                  # encoding: [0x12,0xe6]
    lsl     fp, sp                  # encoding: [0x12,0xea]
    lsr     fp, sp                  # encoding: [0x12,0xea]
    asr     fp, sp                  # encoding: [0x12,0xed]
    cmp     fp, sp                  # encoding: [0x12,0xc3]
    li      sp, 32767               # encoding: [0x01,0x78,0xff,0x7f]
    li      sp, -32768              # encoding: [0x01,0x78,0x00,0x80]
    addi    sp, 7                   # encoding: [0x71,0xf2]
    addi    sp, -8                  # encoding: [0x81,0xf2]
    cmpi    sp, 7                   # encoding: [0x71,0xd3]
    cmpi    sp, -8                  # encoding: [0x81,0xd3]
    nop                             # encoding: [0x00,0x00]</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_テストを書く">テストを書く</h3>
<div class="paragraph">
<p>すべての命令を網羅するようにテストを書く。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_アセンブラに残りの命令を追加する">アセンブラに残りの命令を追加する</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_lwlbulbswsb_命令を追加する"><code>lw/lbu/lb/sw/sb</code> 命令を追加する</h3>
<div class="paragraph">
<p>TableGenにエントリを増やし、またオペランドにメモリ表記をとれるように
<code>AsmParser</code> を変更すれば良い。この時点では <code>getImmOpValue</code> を実装する必要はない。</p>
</div>
<div class="paragraph">
<p>ここで <code>li x11, x12</code> を入力すると、期待しているエラーメッセージ
<code>invalid operand for instruction</code> ではなく
<code>immediate must be an integer in the range [-32768, 32767]</code> が出てしまう。
これはアセンブリをパーズするときに使用する関数 <code>RV16KAsmParser::MatchAndEmitInstruction</code> 内で
呼んでいる、TableGenが生成する <code>MatchInstructionImpl</code> の挙動のためである。
すなわち <code>MatchInstructionImpl</code> が呼ぶ <code>validateOperandClass</code> では、例えば符号付き16bit即値を
期待しているときにi) まず <code>isSImm16</code> を用いて即値として正しいかを調べii)
正しければ <code>Match_Success</code> を返しiii)
正しくなければ <code>Match_InvalidSImm16</code> を返している。そしてiv) これが <code>MatchAndEmitInstruction</code> で
補足されて、即値幅のエラーとして表示される。すなわち「そもそもオペランドが即値か」という
条件分岐が行われていないことが、この挙動の原因である。
そこで <code>MatchInstructionImpl</code> から即値エラーが返ってきた場合には
「そもそもオペランドが即値か」を次のように判定し、即値でない場合に <code>invalid operand</code> エラーを
返すことで、この問題を解決できる。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>RV16KOperand &amp;Operand = (RV16KOperand &amp;)*Operands[ErrorInfo];
if (!Operand.isImm())
  return Error(Operand.getStartLoc(), "invalid operand for instruction");</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_lwspswsp_命令を追加する"><code>lwsp/swsp</code> 命令を追加する</h3>
<div class="paragraph">
<p>やるだけ。</p>
</div>
</div>
<div class="sect2">
<h3 id="_jjaljalrjrjljlejejnejbjbe_命令を追加する"><code>j/jal/jalr/jr/jl/jle/je/jne/jb/jbe</code> 命令を追加する</h3>
<div class="paragraph">
<p>やるだけ。先達はあらまほしきことなり。</p>
</div>
</div>
<div class="sect2">
<h3 id="_属性を指定する">属性を指定する</h3>
<div class="paragraph">
<p><code>llvm/include/llvm/Target/Target.td</code> を参考に、必要なフィールドを <code>let</code> を使って上書きする。</p>
</div>
<div class="paragraph">
<p>どの程度の粒度で設定すべきなのか良くわからない。例えば <code>isAdd</code> というフラグがあるが、
誰も使っていない。また <code>isCommutable</code> はx86やLanaiは使っているが、RISC Vは使っていない。
おそらくTableGenが推論してくれる部分などがあるのだろうが、どれを指定してどれを指定するべきでないのか
全然わからない。</p>
</div>
<div class="paragraph">
<p>x86を見るとmov命令には <code>Defs = [EFLAGS]</code> の記載がない。Intel SDMを見ると、
実はx86のMOVやJccはEFLAGSを書き換えないことが分かる。意外だ。</p>
</div>
<div class="paragraph">
<p>とりあえず分かる範囲で設定して先に進む。不都合が起きたら戻ってこよう。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ディスアセンブラを実装する">ディスアセンブラを実装する</h2>
<div class="sectionbody">
<div class="paragraph">
<p>途中でバグらせてつらかったが、LLVM流printfデバッグの方法が分かった。
<code>LLVM_DEBUG(dbgs() &lt;&lt; "message");</code> とすることでデバッグ情報を出力できる。
<code>message</code> の部分に変数などを仕込みたい場合は <code>formatv</code> を使うのが安全である。
このようにして出力したデバッグ情報は、ツールの
コマンドライン引数に <code>-debug</code> を渡すことで見ることができる。
例えばディスアセンブラの挙動についてデバッグしたい場合は、まず情報を表示するように仕込み</p>
</div>
<div class="literalblock">
<div class="content">
<pre>LLVM_DEBUG(dbgs() &lt;&lt; formatv("HOGEHOGE {0} {1} {2} {3}\n", bit15, bit14,
                             bit12, isNIAI));</pre>
</div>
</div>
<div class="paragraph">
<p>つぎにそれを表示させる。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ bin/llvm-mc -filetype=obj -triple=rv16k &lt; foo.s | bin/llvm-objdump -debug -d -</pre>
</div>
</div>
<div class="paragraph">
<p>なおこのあたりの技法についてはLLVM Programmer&#8217;s Manual<a href="#llvm-programmers_manual">[56]</a>が詳しい。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_relocationとfixupに対応する">relocationとfixupに対応する</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_fixupを定義する">Fixupを定義する</h3>
<div class="paragraph">
<p><code>j</code> や <code>jal</code> のために <code>fixup_rv16k_pcrel_16bit</code> を、 <code>jl</code> や <code>jle</code> のために <code>fixup_rv16k_pcrel_8bit</code> を
定義した。なおグローバル変数などのリロケーションに必要なfixupは <code>FK_Data_2</code> を使えば良いようだ。</p>
</div>
</div>
<div class="sect2">
<h3 id="_fixupを適用する関数を定義する">Fixupを適用する関数を定義する</h3>
<div class="paragraph">
<p>やるだけ。RV32Kと比べて即値の埋め込み方が簡単なため、これ自体はそれほど難しくない。</p>
</div>
</div>
<div class="sect2">
<h3 id="_アセンブラにfixupを生成させる">アセンブラにFixupを生成させる</h3>
<div class="paragraph">
<p>Fixupは <code>RV16KMCCodeEmitter::getImmOpValue</code> が即値の <code>EncoderMethod</code> として呼ばれることにより
生成される。すなわち <code>getImmOpValue</code> の中で、当該オペランドの値が <code>MCSymbolRefExpr</code> の場合には
Fixupを生成するようにすればよい。また <code>isSImm16Lsb0</code> などは <code>MCSymbolRefExpr</code> に対して <code>true</code>
を返すようにしておく<sup class="footnote">[<a id="_footnoteref_6" class="footnote" href="#_footnotedef_6" title="View footnote.">6</a>]</sup>。</p>
</div>
<div class="paragraph">
<p>またそもそもアセンブリをパーズするときに文字列が <code>MCSymbolRefExpr</code> として読み込まれるように、
<code>AsmParser</code> を変更する必要がある。
そこで <code>RV16KAsmParser::parseImmediate</code> を変更する。</p>
</div>
<div class="paragraph">
<p>作り終わったらFixupのテストを書く。RV16Kv2仕様の詰めが甘かったので若干修正した。</p>
</div>
</div>
<div class="sect2">
<h3 id="_relocationに対応する">Relocationに対応する</h3>
<div class="paragraph">
<p>最後まで修正できずに残ったFixupをRelocationに変換してELFに埋め込み、
リンカに解決させるようにする。 <code>RV16KELFObjectWriter::getRelocType</code> にFixupとRelocationの
対応を書けば良いが、そのまえにどのようなRelocationが存在するかについて
<code>include/llvm/BinaryFormat/ELFRelocs/RISCV.def</code> に記述する必要がある。</p>
</div>
<div class="paragraph">
<p><code>.int foo</code> として <code>li x2, foo</code> とすると <code>FK_Data_4</code> が生成されてしまう。
解決策を探して他のターゲットの <code>RV16KELFObjectWriter.cpp</code> を見たが、
どれも <code>FK_Data_4</code> を捕捉し処理していた。とりあえず <code>.2byte foo</code> とすることで回避する。</p>
</div>
<div class="paragraph">
<p><code>llvm-readobj</code> でできたELFバイナリを見ると <code>AddressSize</code> が <code>32bit</code> となっているが、
変え方がわからない。と思ったが、どうやらELFバイナリそのものが32bit/64bit限定のようだ。</p>
</div>
<div class="paragraph">
<p>全体的にLLVMは32bit以上を念頭において開発されているように思う。</p>
</div>
</div>
<div class="sect2">
<h3 id="_即値に定数式を書けるようにする">即値に定数式を書けるようにする</h3>
<div class="paragraph">
<p>すなわち <code>.2byte foo</code> があったときに <code>li x3, foo+3</code> などと書けるようにするということである。
これのためには <code>AsmParser</code> に手を入れて適当な箇所で <code>parseExpression</code> を呼び<sup class="footnote">[<a id="_footnoteref_7" class="footnote" href="#_footnotedef_7" title="View footnote.">7</a>]</sup>、
また <code>isSImm16</code> など即値判定の関数でこのような式に対して <code>true</code> を返すようにする。
なおFixup時の式の評価などはLLVMが勝手にやってくれるようだ<sup class="footnote">[<a id="_footnoteref_8" class="footnote" href="#_footnotedef_8" title="View footnote.">8</a>]</sup>。</p>
</div>
<div class="paragraph">
<p><code>CodeEmitter</code> では、即値の <code>Expr</code> に対して適切にFixupを生成する必要がある。
「いつ、どのFixupを作成するべきか」を判断するためには
命令のハードコーディングが必要になる。それよりはむしろRISC Vが導入しているような <code>InstFormat</code> を
命令に埋め込むほうが後々の拡張性に優れるが、とりあえずこのままにしておく<sup class="footnote">[<a id="_footnoteref_9" class="footnote" href="#_footnotedef_9" title="View footnote.">9</a>]</sup>。</p>
</div>
<div class="paragraph">
<p>RISC Vの実装では <code>jal</code> のみを別枠として処理している。おそらくこれは <code>R_RISCV_JAL</code> などが
addendに対応しないためである。RV16Kの場合も <code>R_RV16K_16</code> のみがaddendに対応するので<sup class="footnote">[<a id="_footnoteref_10" class="footnote" href="#_footnotedef_10" title="View footnote.">10</a>]</sup>これに従う。
したがって結局、単なるシンボルのみだけでなく式を受け取れるのは <code>li</code> 命令のみとなる<sup class="footnote">[<a id="_footnoteref_11" class="footnote" href="#_footnotedef_11" title="View footnote.">11</a>]</sup>。</p>
</div>
<div class="paragraph">
<p>ところでLanaiの実装では、二項演算について左辺のみを取得してFixupに追加している。
これはaddendなどについて誤ったfixupを生成すると思われるが、調べていない（TODO）。</p>
</div>
<div class="paragraph">
<p>結局即値に定数式を書けるようにするためにはi) <code>AsmParser</code> に手を入れて式をパーズするようにしii)
<code>isSImm16</code> などで正しい定数式か否かを判断するようにしiii) <code>CodeEmitter</code> に手を入れて
正しいfixupを作成するようにする必要がある。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_コンパイラのスケルトンを作成する">コンパイラのスケルトンを作成する</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_rv16kasmprinter_と_rv16kmcinstlower_を追加"><code>RV16KAsmPrinter</code> と <code>RV16KMCInstLower</code> を追加</h3>
<div class="paragraph">
<p>やるだけ</p>
</div>
</div>
<div class="sect2">
<h3 id="_rv16kinstrinfo_を追加"><code>RV16KInstrInfo</code> を追加</h3>
<div class="paragraph">
<p>やるだけ</p>
</div>
</div>
<div class="sect2">
<h3 id="_rv16kregisterinfo_を追加"><code>RV16KRegisterInfo</code> を追加</h3>
<div class="paragraph">
<p><code>RV16KGenRegisterInfo</code> の第一引数にはreturn addressを渡せば良い。</p>
</div>
<div class="paragraph">
<p>frame pointerはx86で言うところのrbpのことのようだ。</p>
</div>
</div>
<div class="sect2">
<h3 id="_rv16ksubtarget_を追加"><code>RV16KSubtarget</code> を追加</h3>
<div class="paragraph">
<p>やるだけ</p>
</div>
</div>
<div class="sect2">
<h3 id="_rv16kpassconfig_を追加"><code>RV16KPassConfig</code> を追加</h3>
<div class="paragraph">
<p>やるだけ</p>
</div>
</div>
<div class="sect2">
<h3 id="_rv16kiseldagtodag_を追加"><code>RV16KISelDAGToDAG</code> を追加</h3>
<div class="paragraph">
<p>SelectionDAGをMachineDAGに変換するときに使用される。</p>
</div>
</div>
<div class="sect2">
<h3 id="_rv16kcallingconv_td_を追加"><code>RV16KCallingConv.td</code> を追加</h3>
<div class="paragraph">
<p>関数呼び出し規約について記述する。ここの記法については<a href="#llvm-writing_backend-calling_conventions">[57]</a>が
詳しい。ここで <code>CSR</code> としてcallee-savedなレジスタを指定する必要がある。</p>
</div>
<div class="paragraph">
<p>RISC Vの実装を参考にするとreturn addressを格納するレジスタはこれに<strong>指定する</strong>一方で、
stack pointer registerは<strong>指定しない</strong>。RISC Vの仕様<a href="#riscv-calling">[58]</a>によれば
<code>ra</code> はcaller-saved、 <code>sp</code> はcallee-savedとなっており良くわからない。</p>
</div>
</div>
<div class="sect2">
<h3 id="_rv16kinstrinfo_td_を修正"><code>RV16KInstrInfo.td</code> を修正</h3>
<div class="paragraph">
<p>まず <code>RetFlag</code> を <code>SDNode</code> として追加する。
これはすなわち <code>RetFlag</code> がSelectionDAGのノード（命令）として新たに使えるようになる
ということを意味する。
実際 <code>RV16KTargetLowering::LowerReturn</code> では <code>DAG.getNode</code> に <code>RV16KISD::RET_FLAG</code> を渡すことで
このノードを作成している。
ここで第一引数に渡す <code>RV16KISD::RET_FLAG</code> は別のところ（ <code>RV16KISelLowering.h</code> ）で
定義する必要がある。また第二引数に <code>SDTNone</code> が渡されているため
オペランドを取らないことがわかる（ほんまか？；TODO）</p>
</div>
<div class="paragraph">
<p>その他命令を変換するための <code>Pat</code> を追加する。</p>
</div>
</div>
<div class="sect2">
<h3 id="_その他">その他</h3>
<div class="paragraph">
<p><code>RV32K.td</code> の <code>RV16KInstrInfo</code> では <code>guessInstructionProperties</code> に <code>0</code> を
設定している。これによって <code>mayLoad, mayStore, hasSideEffects</code> に対する
自動的な値の推論がなくなり、
明示的に設定していない場合にはエラーが出力されるようになる<sup class="footnote">[<a id="_footnoteref_12" class="footnote" href="#_footnotedef_12" title="View footnote.">12</a>]</sup>。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_定数に対応する">定数に対応する</h2>
<div class="sectionbody">
<div class="paragraph">
<p>やるだけ</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_メモリ操作に対応する">メモリ操作に対応する</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>load</code> が16bitの操作に対応することに注意。
具体的にどのようなパターンを書けばよいかわからないときは <code>-debug-only=isel</code>
を使用すると便利である<a href="#llvm_dev_ml-how_to_debug_instruction_selection">[59]</a>。
例えば <code>load</code> を実装した後では、次のようにLLVM IRが変換されていくことが分かる。
一方で途中で変換が失敗する場合は、パターンに誤りがあることが示唆される。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cat foo.ll
define i16 @lw(i16 *%a) nounwind {
  %1 = getelementptr i16, i16* %a, i16 3
  %2 = load i16, i16* %1
  %3 = load volatile i16, i16* %a
  ret i16 %2
}

$ bin/llc -mtriple=rv16k -verify-machineinstrs -debug-only=isel &lt; foo.ll
	.text
	.file	"&lt;stdin&gt;"



=== lw
Initial selection DAG: %bb.0 'lw:'
SelectionDAG has 12 nodes:
  t0: ch = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %0
  t5: i16 = Constant<b class="conum">(0)</b>
    t4: i16 = add t2, Constant:i16<b class="conum">(6)</b>
  t7: i16,ch = load&lt;(load 2 from %ir.1)&gt; t0, t4, undef:i16
    t8: i16,ch = load&lt;(volatile load 2 from %ir.a)&gt; t7:1, t2, undef:i16
  t10: ch,glue = CopyToReg t8:1, Register:i16 $x8, t7
  t11: ch = RV16KISD::RET_FLAG t10, Register:i16 $x8, t10:1


Optimized lowered selection DAG: %bb.0 'lw:'
SelectionDAG has 12 nodes:
  t0: ch = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %0
    t4: i16 = add t2, Constant:i16<b class="conum">(6)</b>
  t7: i16,ch = load&lt;(load 2 from %ir.1)&gt; t0, t4, undef:i16
      t12: i16,ch = load&lt;(volatile load 2 from %ir.a)&gt; t0, t2, undef:i16
    t13: ch = TokenFactor t7:1, t12:1
  t10: ch,glue = CopyToReg t13, Register:i16 $x8, t7
  t11: ch = RV16KISD::RET_FLAG t10, Register:i16 $x8, t10:1


Type-legalized selection DAG: %bb.0 'lw:'
SelectionDAG has 12 nodes:
  t0: ch = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %0
    t4: i16 = add t2, Constant:i16<b class="conum">(6)</b>
  t7: i16,ch = load&lt;(load 2 from %ir.1)&gt; t0, t4, undef:i16
      t12: i16,ch = load&lt;(volatile load 2 from %ir.a)&gt; t0, t2, undef:i16
    t13: ch = TokenFactor t7:1, t12:1
  t10: ch,glue = CopyToReg t13, Register:i16 $x8, t7
  t11: ch = RV16KISD::RET_FLAG t10, Register:i16 $x8, t10:1


Legalized selection DAG: %bb.0 'lw:'
SelectionDAG has 12 nodes:
  t0: ch = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %0
    t4: i16 = add t2, Constant:i16<b class="conum">(6)</b>
  t7: i16,ch = load&lt;(load 2 from %ir.1)&gt; t0, t4, undef:i16
      t12: i16,ch = load&lt;(volatile load 2 from %ir.a)&gt; t0, t2, undef:i16
    t13: ch = TokenFactor t7:1, t12:1
  t10: ch,glue = CopyToReg t13, Register:i16 $x8, t7
  t11: ch = RV16KISD::RET_FLAG t10, Register:i16 $x8, t10:1


Optimized legalized selection DAG: %bb.0 'lw:'
SelectionDAG has 12 nodes:
  t0: ch = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %0
    t4: i16 = add t2, Constant:i16<b class="conum">(6)</b>
  t7: i16,ch = load&lt;(load 2 from %ir.1)&gt; t0, t4, undef:i16
      t12: i16,ch = load&lt;(volatile load 2 from %ir.a)&gt; t0, t2, undef:i16
    t13: ch = TokenFactor t7:1, t12:1
  t10: ch,glue = CopyToReg t13, Register:i16 $x8, t7
  t11: ch = RV16KISD::RET_FLAG t10, Register:i16 $x8, t10:1


===== Instruction selection begins: %bb.0 ''

ISEL: Starting selection on root node: t11: ch = RV16KISD::RET_FLAG t10, Register:i16 $x8, t10:1
ISEL: Starting pattern match
  Morphed node: t11: ch = PseudoRET Register:i16 $x8, t10, t10:1
ISEL: Match complete!

ISEL: Starting selection on root node: t10: ch,glue = CopyToReg t13, Register:i16 $x8, t7

ISEL: Starting selection on root node: t13: ch = TokenFactor t7:1, t12:1

ISEL: Starting selection on root node: t7: i16,ch = load&lt;(load 2 from %ir.1)&gt; t0, t4, undef:i16
ISEL: Starting pattern match
  Initial Opcode index to 5
  Morphed node: t7: i16,i16,ch = LW&lt;Mem:(load 2 from %ir.1)&gt; t2, TargetConstant:i16&lt;6&gt;, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t12: i16,ch = load&lt;(volatile load 2 from %ir.a)&gt; t0, t2, undef:i16
ISEL: Starting pattern match
  Initial Opcode index to 5
  Match failed at index 10
  Continuing at 95
  Morphed node: t12: i16,i16,ch = LW&lt;Mem:(volatile load 2 from %ir.a)&gt; t2, TargetConstant:i16&lt;0&gt;, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t2: i16,ch = CopyFromReg t0, Register:i16 %0

ISEL: Starting selection on root node: t9: i16 = Register $x8

ISEL: Starting selection on root node: t1: i16 = Register %0

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.0 'lw:'
SelectionDAG has 11 nodes:
  t0: ch = EntryToken
  t2: i16,ch = CopyFromReg t0, Register:i16 %0
  t7: i16,i16,ch = LW&lt;Mem:(load 2 from %ir.1)&gt; t2, TargetConstant:i16&lt;6&gt;, t0
      t12: i16,i16,ch = LW&lt;Mem:(volatile load 2 from %ir.a)&gt; t2, TargetConstant:i16&lt;0&gt;, t0
    t13: ch = TokenFactor t7:2, t12:2
  t10: ch,glue = CopyToReg t13, Register:i16 $x8, t7
  t11: ch = PseudoRET Register:i16 $x8, t10, t10:1


Total amount of phi nodes to update: 0
*** MachineFunction at end of ISel ***
# Machine code for function lw: IsSSA, TracksLiveness
Function Live Ins: $x8 in %0

bb.0 (%ir-block.0):
  liveins: $x8
  %0:gpr = COPY $x8
  %1:gpr = LW %0:gpr, 0, implicit-def dead $flags :: (volatile load 2 from %ir.a)
  %2:gpr = LW %0:gpr, 6, implicit-def dead $flags :: (load 2 from %ir.1)
  $x8 = COPY %2:gpr
  PseudoRET implicit $x8

# End machine code for function lw.

	.globl	lw                      # -- Begin function lw
	.p2align	1
	.type	lw,@function
lw:                                     # @lw
# %bb.0:
	lw	a1, 0(a0)
	lw	a0, 6(a0)
	jr	ra
.Lfunc_end0:
	.size	lw, .Lfunc_end0-lw
                                        # -- End function

	.section	".note.GNU-stack","",@progbits</pre>
</div>
</div>
<div class="paragraph">
<p><code>RV16KTargetLowering</code> で次のように <code>Promote</code> を指定すると</p>
</div>
<div class="literalblock">
<div class="content">
<pre>for (auto N : {ISD::EXTLOAD, ISD::SEXTLOAD, ISD::ZEXTLOAD})
    setLoadExtAction(N, MVT::i16, MVT::i1, Promote);</pre>
</div>
</div>
<div class="paragraph">
<p><code>i1</code> に対する <code>extload, sextload, zextload</code> が <code>i16</code> のそれに変換される（TODO；多分）。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_グローバル変数に対応する">グローバル変数に対応する</h2>
<div class="sectionbody">
<div class="paragraph">
<p>グローバル変数に対するlw/swに対応する<a href="#github_riscv-llvm_patch_16">[38]</a><a href="#fpga_develop_diary-20190612040000">[60]</a>。
SelectionDAGノードである <code>GlobalAddress</code> を処理するために</p>
</div>
<div class="literalblock">
<div class="content">
<pre>setOperationAction(ISD::GlobalAddress, MVT::i16, Custom);</pre>
</div>
</div>
<div class="paragraph">
<p>とし <code>lowerOperation</code> から <code>lowerGlobalAddress</code> を呼び出す。ここでは即値を <code>LI</code> を利用して
読み込むためのDAGを作成する。</p>
</div>
<div class="paragraph">
<p>とりあえず次のようなLLVM IRを読み込ませる。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>@G = global i16 0

define i16 @lw_sw_global(i16 %a) nounwind {
  %1 = load volatile i16, i16* @G
  store i16 %a, i16* @G
  %2 = getelementptr i16, i16* @G, i16 9
  %3 = load volatile i16, i16* %2
  store i16 %a, i16* %2
  ret i16 0
}</pre>
</div>
</div>
<div class="paragraph">
<p>すると <code>LLVM ERROR: LowerRV16KMachineInstrToMCInst: unknown operand type</code>
とエラーがでるので修正する。</p>
</div>
<div class="paragraph">
<p>アセンブリを出力するために <code>MachineInstr</code> を <code>MCInst</code> に変換するときに、
<code>MachineInstr</code> に含まれる <code>MachineOperand</code> の <code>MO_GlobalAddress</code> に対応する必要がある。
これはこのオペランドのシンボル（名前）を取得し、オフセットを含めた <code>MCExpr</code> として構築しなおし、
<code>MCOperand::createExpr</code> に渡して <code>MCOperand</code> とすればよい。
これで上記のLLVM IRが正しくコンパイルされるようになる。</p>
</div>
<div class="paragraph">
<p>一方で <code>ret i16 0</code> を <code>ret i16 %1</code> としたLLVM IRは、次のようなエラーが出力され
コンパイルされない。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ bin/llc -mtriple=rv16k -verify-machineinstrs &lt; foo.ll
	.text
	.file	"&lt;stdin&gt;"

# After Post-RA pseudo instruction expansion pass
# Machine code for function lw_sw_global: NoPHIs, NoVRegs
Function Live Ins: $x8

bb.0 (%ir-block.0):
  $x10 = LI @G, implicit-def dead $flags
  $x9 = LW $x10, 0, implicit-def dead $flags :: (volatile dereferenceable load 2 from @G)
  SW $x8, killed $x10, 0, implicit-def dead $flags :: (store 2 into @G)
  $x10 = LI @G + 18, implicit-def dead $flags
  dead $x11 = LW $x10, 0, implicit-def dead $flags :: (volatile load 2 from %ir.2)
  SW killed $x8, killed $x10, 0, implicit-def dead $flags :: (store 2 into %ir.2)
  $x8 = MOV killed $x9(tied-def 0), implicit-def $flags
  PseudoRET implicit $x8

# End machine code for function lw_sw_global.

*** Bad machine code: Tied physical registers must match. ***
- function:    lw_sw_global
- basic block: %bb.0  (0xf02c98)
- instruction: $x8 = MOV killed $x9(tied-def 0), implicit-def $flags
- operand 0:   $x8

*** Bad machine code: Two-address instruction operands must be identical ***
- function:    lw_sw_global
- basic block: %bb.0  (0xf02c98)
- instruction: $x8 = MOV killed $x9(tied-def 0), implicit-def $flags
- operand 1:   killed $x9(tied-def 0)

*** Bad machine code: Explicit operand marked as def ***
- function:    lw_sw_global
- basic block: %bb.0  (0xf02c98)
- instruction: $x8 = MOV killed $x9(tied-def 0), implicit-def $flags
- operand 2:   implicit-def $flags

*** Bad machine code: Explicit operand marked as implicit ***
- function:    lw_sw_global
- basic block: %bb.0  (0xf02c98)
- instruction: $x8 = MOV killed $x9(tied-def 0), implicit-def $flags
- operand 2:   implicit-def $flags

*** Bad machine code: Illegal physical register for instruction ***
- function:    lw_sw_global
- basic block: %bb.0  (0xf02c98)
- instruction: $x8 = MOV killed $x9(tied-def 0), implicit-def $flags
- operand 2:   implicit-def $flags
$flags is not a GPR register.
LLVM ERROR: Found 5 machine code errors.</pre>
</div>
</div>
<div class="paragraph">
<p>これは <code>MOV</code> の定義が入力を2つ受け取っていたためである
<sup class="footnote">[<a id="_footnoteref_13" class="footnote" href="#_footnotedef_13" title="View footnote.">13</a>]</sup>。
正しい形式となるように変更しておく。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>let hasSideEffects = 0, mayLoad = 0, mayStore = 0, Defs = [FLAGS] in
def MOV : RV16KInstRR16&lt;0b11000000, (outs GPR:$rd), (ins GPR:$rs),
                       "mov", "$rd, $rs"&gt;;</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_条件分岐に対応する">条件分岐に対応する</h2>
<div class="sectionbody">
<div class="paragraph">
<p>これが複雑。LLVMはネイティブで <code>CMP</code> 命令相当のSelectionDAGノードを有しないため、
独自に実装する必要がある。これをやっている例はいまのところx86しか見つけていない
<sup class="footnote">[<a id="_footnoteref_14" class="footnote" href="#_footnotedef_14" title="View footnote.">14</a>]</sup>。</p>
</div>
<div class="paragraph">
<p>x86ではまず <code>ISD::BRCOND</code> に対して <code>Custom</code> 指定をし <code>LowerOperation</code> から
<code>LowerBRCOND</code> を呼び出す。ここでは`brcond` を <code>X86ISD::BRCOND</code> に変換する。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>def SDTX86BrCond  : SDTypeProfile&lt;0, 3,
                                  [SDTCisVT&lt;0, OtherVT&gt;,
                                   SDTCisVT&lt;1, i8&gt;, SDTCisVT&lt;2, i32&gt;]&gt;;
def X86brcond  : SDNode&lt;"X86ISD::BRCOND",   SDTX86BrCond,
                        [SDNPHasChain]&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p><code>X86ISD::BRCOND</code> はオペランドを3個とり、順に飛ぶ先・条件の種類・ <code>X86ISD::CMP</code> ノードと
なっているようだが、詳細不明。</p>
</div>
<div class="paragraph">
<p><code>LowerBRCOND</code> 内ではかなりの最適化が図られているが <code>ISD::SETCC</code> に対する処理のみ
追いかければ当分問題ないはず。TODO</p>
</div>
<div class="paragraph">
<p>他の簡易な実装としてLEG<a href="#LLVMBackend_2015_03_26_v2">[49]</a>があった。
ここでは <code>LEGDAGToDAGISel::Select</code> で割り込み <code>ISD::BR_CC</code> に対して <code>CMP</code> と <code>Bcc</code> の
MachineNodeを作成している。これは <a href="#llvm_dev_ml-br_cc_questions">[61]</a>と同じ手法のようだ。
ここの依存関係を表現するために <code>SDValue</code> の配列を作成しているが詳細不明。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>SDNode *LEGDAGToDAGISel::SelectConditionalBranch(SDNode *N) {
  SDValue Chain = N-&gt;getOperand(0);
  SDValue Cond = N-&gt;getOperand(1);
  SDValue LHS = N-&gt;getOperand(2);
  SDValue RHS = N-&gt;getOperand(3);
  SDValue Target = N-&gt;getOperand(4);

  // Generate a comparison instruction.
  EVT CompareTys[] = { MVT::Other, MVT::Glue };
  SDVTList CompareVT = CurDAG-&gt;getVTList(CompareTys);
  SDValue CompareOps[] = {LHS, RHS, Chain};
  SDNode *Compare = CurDAG-&gt;getMachineNode(LEG::CMP, N, CompareVT, CompareOps);

  // Generate a predicated branch instruction.
  CondCodeSDNode *CC = cast&lt;CondCodeSDNode&gt;(Cond.getNode());
  SDValue CCVal = CurDAG-&gt;getTargetConstant(CC-&gt;get(), N, MVT::i32);
  SDValue BranchOps[] = {CCVal, Target, SDValue(Compare, 0),
                         SDValue(Compare, 1)};
  return CurDAG-&gt;getMachineNode(LEG::Bcc, N, MVT::Other, BranchOps);
}</pre>
</div>
</div>
<div class="paragraph">
<p>結局 <code>BR_CC</code> や <code>BRCOND</code> に対して <code>CMP</code> と <code>Jcc</code> を同時に発行できればよく、
問題はここに依存関係が存在することである。すなわちこの間に <code>EFLAGS</code> を
いじるような命令が来てはいけないのである。ただこの関係は <code>Defs</code> の
定義によってよしなになるような気はする。</p>
</div>
<div class="paragraph">
<p>TableGenのパターンでは複数命令を発行することはできないようなので
<a href="#llvm_dev_ml-multiple_result_instrs">[62]</a>、どこかでフックする他ない。</p>
</div>
<div class="paragraph">
<p><code>SDValue(hoge, 1)</code> と書くと <code>hoge</code> がdefするものの2番めを取ってくるようだ。
ただしこれは要確認だが、例えばx86で</p>
</div>
<div class="literalblock">
<div class="content">
<pre>    SDValue Sub = DAG.getNode(X86ISD::SUB, dl, VTs, Op0, Op1);
    return SDValue(Sub.getNode(), 1);</pre>
</div>
</div>
<div class="paragraph">
<p>とかくと <code>EFLAGS</code> を返していることになりそうだ。</p>
</div>
<div class="paragraph">
<p>ここからの類推で <code>Uses</code> に書けばオペランドとして渡せるのではないかと思い次のように書いたが</p>
</div>
<div class="literalblock">
<div class="content">
<pre>def : Pat&lt;(brcond (i16 (seteq GPR:$rs1, GPR:$rs2)), bb:$imm),
          (JE simm8_lsb0:$imm, (CMP GPR:$rs1, GPR:$rs2))&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>次のようにエラーが出た。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>anonymous_978: 	(JE simm8_lsb0:{ *:[i16] }:$imm, (CMP:{}:{} GPR:{}:$rs1, GPR:{}:$rs2))
Included from /home/anqou/ano/secure_vm/llvm-project/llvm/lib/Target/RV16K/RV16K.td:23:
/home/anqou/ano/secure_vm/llvm-project/llvm/lib/Target/RV16K/RV16KInstrInfo.td:215:1: error: In anonymous_978: Instruction 'JE' was provided 2 operands but expected only 1!
def : Pat&lt;(brcond (i16 (seteq GPR:$rs1, GPR:$rs2)), bb:$imm),</pre>
</div>
</div>
<div class="paragraph">
<p>せやろな<sup class="footnote">[<a id="_footnoteref_15" class="footnote" href="#_footnotedef_15" title="View footnote.">15</a>]</sup>。</p>
</div>
<div class="paragraph">
<p>Lanaiがよく見ると <code>CMP</code> と <code>Jcc</code> パターンだった。
<code>CMP</code> に相当するのは <code>SFSUB_F</code> で、条件分岐自体は <code>BRCC</code> で行う。
全体としてx86の方式を <code>BR_CC</code> に変換しつつ簡易化したような構成になっている。
RV16Kv2でもこの方式を採用することにする。</p>
</div>
<div class="paragraph">
<p>まず <code>BRCOND</code> はexpandするようにし <code>BR_CC</code> はcustom指定を行う。
ここで <code>BRCOND</code> には <code>MVT::Other</code> を指定することに注意する。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>setOperationAction(ISD::BRCOND, MVT::Other, Expand);
setOperationAction(ISD::BR_CC, MVT::i16, Custom);</pre>
</div>
</div>
<div class="paragraph">
<p>こうすることで、次のように条件が別の場所で作られて <code>br</code> に持ち込まれる場合に対応できる。
なぜかは良くわからない（TODO）。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>test11:
  %val11 = load volatile i16, i16* %b
  br i1 %c, label %end, label %test12</pre>
</div>
</div>
<div class="paragraph">
<p>さて <code>BR_CC</code> を処理するための関数 <code>LowerBR_CC</code> を作成し作業を行う。
ここでは <code>BR_CC</code> を <code>RV16KISD::CMP</code> と <code>RV16KISD::BR_CC</code> に構成し直す。
すなわち <code>ISD::CondCode</code> を <code>RV16KISD::CondCode</code> に変換し、
これを子ノードに持つような <code>RV16KISD::CMP</code> を作り、さらにそれを持つような <code>RV16KISD::BR_CC</code> を
作成する。</p>
</div>
<div class="paragraph">
<p><code>RV16KISD::CMP</code> と <code>RV16KISD::BR_CC</code> は <code>RV16KInstrInfo.td</code> で新しいSelectionDAGの
ノード（ <code>SDNode</code> ）として定義する。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>def SDT_RV16KCmp      : SDTypeProfile&lt;0,  2, [SDTCisSameAs&lt;0, 1&gt;]&gt;;
def SDT_RV16KBrCC     : SDTypeProfile&lt;0,  2, [SDTCisVT&lt;0, OtherVT&gt;,
                                                  SDTCisVT&lt;1, i16&gt;]&gt;;

def RV16KCmp : SDNode&lt;"RV16KISD::CMP", SDT_RV16KCmp, [SDNPOutGlue]&gt;;
def RV16BrCC : SDNode&lt;"RV16KISD::BR_CC", SDT_RV16KBrCC, [SDNPHasChain, SDNPInGlue]&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p><code>SDTCisSameAs</code> は指定するオペランドの型が全く同一であることを意味する。</p>
</div>
<div class="paragraph">
<p>この構成では <code>RV16KISD::BR_CC</code> は第二オペランドに条件分岐の種類を持つため、
それを利用してTableGen上でパターンマッチが可能である。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>def : Pat&lt;(RV16KCmp GPR:$rs1, GPR:$rs2), (CMP GPR:$rs1, GPR:$rs2)&gt;;
def : Pat&lt;(RV16KBrCC bb:$imm7, RV16K_COND_E), (JE simm8_lsb0:$imm7)&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p><code>br</code> を <code>J</code> に対応させるために <code>simm16_lsb0</code> が <code>Operand&lt;OtherVT&gt;</code> を継承するようにすると、
同じオペランドをとる <code>load</code> が正しく動かなくなってしまう。
そこで <code>simm16_lsb0_j</code> という新しい <code>def</code> を用意し、これは <code>Operand&lt;OtherVT&gt;</code> を
継承するようにした上で <code>j</code> や <code>jal</code> 命令はこれを参照するようにする。</p>
</div>
<div class="paragraph">
<p><code>MachineInstr</code> のオペランド中に <code>MachineOperand::MO_MachineBasicBlock</code> が登場するようになるので
<code>LowerRV32KMachineOperandToMCOperand</code> の修正が必要である。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_関数呼び出しを実装する">関数呼び出しを実装する</h2>
<div class="sectionbody">
<div class="paragraph">
<p>関数呼び出しをサポートするためにi) <code>PseudoCALL</code> を実装しii) <code>RV16KTargetLowering::LowerCall</code> を実装する。
<code>PseudoCALL</code> は <code>RV16KISD::CALL</code> に対してパターンマッチし <code>JALR</code> に伸張される<sup class="footnote">[<a id="_footnoteref_16" class="footnote" href="#_footnotedef_16" title="View footnote.">16</a>]</sup>。
<code>ra</code> を変更するため <code>Defs</code> を上書きする必要がある。</p>
</div>
<div class="paragraph">
<p><code>RV16KISD::CALL</code> は <code>LowerCall</code> にて挿入される。これの前後には <code>ISD::CALLSEQ_START</code> と
<code>ISD::CALLSEQ_END</code> が挿入される。 <code>ISD::CALLSEQ_START</code> は <code>ADJCALLSTACKDOWN</code> に、
<code>ISD::CALLSEQ_END</code> は <code>ADJCALLSTACKUP</code> にパターンマッチで変換される。
これらは <code>RV16KGenInstrInfo</code> のコンストラクタに渡され処理されるようだ（詳細要確認；TODO）<a id="adjcallstack"></a>。</p>
</div>
<div class="paragraph">
<p>これらが具体的に何をやっているかはよくわからない（TODO）が、
<code>RV16KFrameLowering::eliminateCallFramePseudoInstr</code> にて <code>ADJCALLSTACKDOWN</code> と
<code>ADJCALLSTACKUP</code> は削除する際にフックを仕掛け、関数呼び出しの前後で行う処理を記述することが
可能のようだ<a href="#llvm_phabricator-d43752">[67]</a>。</p>
</div>
<div class="paragraph">
<p><code>ISDOpcodes.h</code> にはこうある。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/// CALLSEQ_START/CALLSEQ_END - These operators mark the beginning and end
/// of a call sequence, and carry arbitrary information that target might
/// want to know.  The first operand is a chain, the rest are specified by
/// the target and not touched by the DAG optimizers.
/// Targets that may use stack to pass call arguments define additional
/// operands:
/// - size of the call frame part that must be set up within the
///   CALLSEQ_START..CALLSEQ_END pair,
/// - part of the call frame prepared prior to CALLSEQ_START.
/// Both these parameters must be constants, their sum is the total call
/// frame size.
/// CALLSEQ_START..CALLSEQ_END pairs may not be nested.
CALLSEQ_START,  // Beginning of a call sequence
CALLSEQ_END,    // End of a call sequence</pre>
</div>
</div>
<div class="paragraph">
<p>スタックサイズを渡している？</p>
</div>
<div class="paragraph">
<p><code>AnalyzeCallOperands</code> で、各々のオペランドをどの位置に置くか（どのレジスタか・スタックの何番目か）
を決める。この関数はTableGenによって生成される。</p>
</div>
<div class="paragraph">
<p><code>NumBytes</code> はスタックに積まれる引数のサイズを表す（多分；要確認；TODO）。</p>
</div>
<div class="paragraph">
<p>引数が <code>ByVal</code> であるというのは、その引数がレジスタに収まらないサイズの値渡しであることを意味するはず。
例えば構造体を値渡しする場合などが含まれる。（詳細な条件を要確認；TODO）。
ここではとりあえず対応しない。</p>
</div>
<div class="paragraph">
<p>可変長引数にはここではとりあえず対応しない。</p>
</div>
<div class="paragraph">
<p><code>LowerCall</code> はおおまかにi) 引数の解析を行いii) <code>CALLSEQ_START</code> を発行しiii)
各引数について <code>CopyToReg</code> を発行して仮想レジスタから物理レジスタへの
割付を行いiv) 呼出し先がグローバルアドレスの場合は<sup class="footnote">[<a id="_footnoteref_17" class="footnote" href="#_footnotedef_17" title="View footnote.">17</a>]</sup>
このアドレスをレジスタに読み込むために <code>li</code> を発行し<sup class="footnote">[<a id="_footnoteref_18" class="footnote" href="#_footnotedef_18" title="View footnote.">18</a>]</sup>iv)
引数に使用するレジスタ及びcallee-savedなレジスタは関数呼び出し中も継続して
生存していることを表すためにオペランドに追加し<sup class="footnote">[<a id="_footnoteref_19" class="footnote" href="#_footnotedef_19" title="View footnote.">19</a>]</sup>)
<code>RV16KISD::CALL</code> を発行しvi) <code>RV16KISD::CALLSEQ_END</code> を発行しvii)
戻り値を解析して戻り値のどの部分がどのレジスタ／スタックに載って返ってくるかを求めviii)
<code>CopyFromReg</code> を発行して物理レジスタから仮想レジスタへの割付を行う<sup class="footnote">[<a id="_footnoteref_20" class="footnote" href="#_footnotedef_20" title="View footnote.">20</a>]</sup>。</p>
</div>
<div class="paragraph">
<p>途中で <code>getCallPreservedMask</code> の戻り値をオペランドに追加している。
これによってcaller-savedなレジスタが関数呼び出しによって上書きされることが
指定されている。</p>
</div>
<div class="paragraph">
<p>関数呼び出しの前後で <code>ra</code> を保存するために、スタックへのレジスタの退避と復帰を各々
<code>RV16KInstrInfo::storeRegToStackSlot</code> と <code>RV16KInstrInfo::loadRegFromStackSlot</code> として
実装する必要がある。このとき <code>addFrameIndex</code> を利用して <code>fp</code> からの距離で <code>lw/sw</code> を
発行する。このときの距離は <code>RV16KRegisterInfo::eliminateFrameIndex</code> にて正しい値に変更する。
将来的にはこの操作は <code>sp</code> からの距離に変更し <code>lwsp/swsp</code> 命令を使うように
最適化したいが、とりあえずはこのままにしておく。どの部分で <code>fp</code> を <code>sp</code> に変換しているのかは
要調査（TODO）。</p>
</div>
<div class="paragraph">
<p>実装すると次のようなLLVM IRが</p>
</div>
<div class="literalblock">
<div class="content">
<pre>define i16 @defined_function(i16 %a) nounwind {
  %1 = add i16 %a, 1
  ret i16 %1
}

define i16 @test_call_defined(i16 %a) nounwind {
  %1 = call i16 @defined_function(i16 %a) nounwind
  %2 = add i16 %a, %1
  ret i16 %2
}</pre>
</div>
</div>
<div class="paragraph">
<p>次のようなアセンブリに変換される。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>	.text
	.file	"&lt;stdin&gt;"
	.globl	defined_function        # -- Begin function defined_function
	.p2align	1
	.type	defined_function,@function
defined_function:                       # @defined_function
# %bb.0:
	addi	a0, 1
	jr	ra
.Lfunc_end0:
	.size	defined_function, .Lfunc_end0-defined_function
                                        # -- End function
	.globl	test_call_defined       # -- Begin function test_call_defined
	.p2align	1
	.type	test_call_defined,@function
test_call_defined:                      # @test_call_defined
# %bb.0:
	sw	ra, 2(fp)
	sw	s0, 0(fp)
	mov	s0, a0
	li	a1, defined_function
	jalr	a1
	add	s0, a0
	mov	a0, s0
	lw	s0, 0(fp)
	lw	ra, 2(fp)
	jr	ra
.Lfunc_end1:
	.size	test_call_defined, .Lfunc_end1-test_call_defined
                                        # -- End function

	.section	".note.GNU-stack","",@progbits</pre>
</div>
</div>
<div class="paragraph">
<p>ここで <code>2(fp)</code> などと出ているのは明確に<strong>間違っており</strong> <code>2(sp)</code> と出るべきである。
というのも <code>fp</code> はアドレス上高位に位置する一方、 <code>sp</code> は低位に存在するからである<sup class="footnote">[<a id="_footnoteref_21" class="footnote" href="#_footnotedef_21" title="View footnote.">21</a>]</sup>。
これは <code>getFrameIndexReference</code> をオーバーライドすることによって
将来的に解決される<sup class="footnote">[<a id="_footnoteref_22" class="footnote" href="#_footnotedef_22" title="View footnote.">22</a>]</sup><sup class="footnote">[<a id="_footnoteref_23" class="footnote" href="#_footnotedef_23" title="View footnote.">23</a>]</sup>。</p>
</div>
<div class="paragraph">
<p>またこの段階では関数プロローグ・エピローグの出力には対応していないため、
複雑な関数をネストして呼び出すような場合については対応していない。</p>
</div>
<div class="paragraph">
<p>さてRISC Vではこの段階で <code>fastcc</code> 関数呼び出し規約に対応している
<sup class="footnote">[<a id="_footnoteref_24" class="footnote" href="#_footnotedef_24" title="View footnote.">24</a>]</sup>。
だがここではとりあえず放置する。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_getframeindexreference_をオーバーライドする"><code>getFrameIndexReference</code> をオーバーライドする</h2>
<div class="sectionbody">
<div class="paragraph">
<p>さて <code>RV16KFrameLowering::getFrameIndexReference</code> では次のようにして
オフセットを求める。これはframe pointer相対になっている。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>  int Offset = MFI.getObjectOffset(FI) - getOffsetOfLocalArea() +
               MFI.getOffsetAdjustment();</pre>
</div>
</div>
<div class="paragraph">
<p><code>getObjectOffset</code> はスタック中のオフセットを返す。基本的にはこれでよい。
他に <code>getOffsetOfLocalArea()</code> はローカル変数の保存場所へのオフセットを返し（多分；TODO）、
<code>getOffsetAdjustment</code> はそれ以外の調整値のようだ<sup class="footnote">[<a id="_footnoteref_25" class="footnote" href="#_footnotedef_25" title="View footnote.">25</a>]</sup>。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>  explicit RV16KFrameLowering(const RV16KSubtarget &amp;STI)
      : TargetFrameLowering(StackGrowsDown,
                            /*StackAlignment=*/2,
                            /*LocalAreaOffset=*/0) {}</pre>
</div>
</div>
<div class="paragraph">
<p>現状このように定義されるため <code>LocalAreaOffset</code> は <code>0</code> である。
また <code>OffsetAdjustment</code> の定義には次のようなコメントが記載されている。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>  /// The amount that a frame offset needs to be adjusted to
  /// have the actual offset from the stack/frame pointer.  The exact usage of
  /// this is target-dependent, but it is typically used to adjust between
  /// SP-relative and FP-relative offsets.  E.G., if objects are accessed via
  /// SP then OffsetAdjustment is zero; if FP is used, OffsetAdjustment is set
  /// to the distance between the initial SP and the value in FP.  For many
  /// targets, this value is only used when generating debug info (via
  /// TargetRegisterInfo::getFrameIndexReference); when generating code, the
  /// corresponding adjustments are performed directly.</pre>
</div>
</div>
<div class="paragraph">
<p>デバッグ情報などを出力する際に使用されるようだ。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_関数プロローグとエピローグを出力する">関数プロローグとエピローグを出力する</h2>
<div class="sectionbody">
<div class="paragraph">
<p>関数プロローグではi) その関数中で利用するスタックフレームのサイズを算出しii)
<code>sp</code> をその分押し下げiii) callee-savedなレジスタをスタックに保存する
命令分イテレータを先に進め<sup class="footnote">[<a id="_footnoteref_26" class="footnote" href="#_footnotedef_26" title="View footnote.">26</a>]</sup>iii) <code>fp</code> を <code>sp</code> にスタックサイズを加算したものとして算出する。
関数エピローグではi) callee-savedなレジスタをスタックから復帰する命令分
イテレータを戻しii) <code>sp</code> がアセンブリ中で変更された場合にはこれを <code>fp</code> から復帰しiii)
<code>sp</code> にスタックサイズを足して元の位置に戻す。
これらの動作は教科書通りのものであるから、結局問題になるのはi) どのように
スタックサイズを算出するかii) どこで・いつcallee-savedなレジスタのスタック退避が
行われるかである。</p>
</div>
<div class="paragraph">
<p><code>determineFrameLayout</code> では <code>MaxCallFrameSize</code> と <code>StackSize</code> について
正しい値を求める。</p>
</div>
<div class="paragraph">
<p><code>MaxCallFrameSize</code> は事前に <code>computeMaxCallFrameSize</code> <sup class="footnote">[<a id="_footnoteref_27" class="footnote" href="#_footnotedef_27" title="View footnote.">27</a>]</sup>が呼ばれるなどしなければ
デフォルトの値 <code>0</code> となる。</p>
</div>
<div class="paragraph">
<p><code>StackSize</code> は使用するスタックのバイト数である。</p>
</div>
<div class="paragraph">
<p>現在のRISC V実装ではより簡素になっている<a href="#llvm_phabricator-d43752">[67]</a>。
またstack realignment（とは？；TODO）については2019年8月現在でもWIPのようだ<a href="#llvm-github_cd44ae">[66]</a>
<sup class="footnote">[<a id="_footnoteref_28" class="footnote" href="#_footnotedef_28" title="View footnote.">28</a>]</sup>。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>// Determines the size of the frame and maximum call frame size.
void RISCVFrameLowering::determineFrameLayout(MachineFunction &amp;MF) const {
  MachineFrameInfo &amp;MFI = MF.getFrameInfo();
  const RISCVRegisterInfo *RI = STI.getRegisterInfo();

  // Get the number of bytes to allocate from the FrameInfo.
  uint64_t FrameSize = MFI.getStackSize();

  // Get the alignment.
  uint64_t StackAlign = RI-&gt;needsStackRealignment(MF) ? MFI.getMaxAlignment()
                                                      : getStackAlignment();

  // Make sure the frame is aligned.
  FrameSize = alignTo(FrameSize, StackAlign);

  // Update frame info.
  MFI.setStackSize(FrameSize);
}</pre>
</div>
</div>
<div class="paragraph">
<p><code>RV16KFrameLowering::determineCalleeSaves</code> ではcallee-savedなレジスタを特定し、
<code>SavedRegs</code> に追加する。基本的には <code>TargetFrameLowering::determineCalleeSaves</code> を
内部で呼ぶことによってi) <code>TargetRegisterInfo::getCalleeSavedRegs()</code> にてcallee-savedと
指定されていてii) 実際に関数中で編集がなされるレジスタが特定される。
一方で <code>fp</code> は <code>emitPrologue</code> 内で<strong>callee-savedなレジスタ退避のためのコード生成が終わった後に</strong>
<code>fp</code> を設定するコードが出力される。したがってこのデフォルトの仕組みでは保存するべきレジスタと
判断されない。そこで <code>RV16KFrameLowering::determineCalleeSaves</code> 内で明示的に
指定する必要がある<sup class="footnote">[<a id="_footnoteref_29" class="footnote" href="#_footnotedef_29" title="View footnote.">29</a>]</sup>
<sup class="footnote">[<a id="_footnoteref_30" class="footnote" href="#_footnotedef_30" title="View footnote.">30</a>]</sup><sup class="footnote">[<a id="_footnoteref_31" class="footnote" href="#_footnotedef_31" title="View footnote.">31</a>]</sup>。</p>
</div>
<div class="paragraph">
<p>これによって次のようなLLVM IRが</p>
</div>
<div class="literalblock">
<div class="content">
<pre>define i16 @defined_function(i16 %a) nounwind {
  %1 = add i16 %a, 1
  ret i16 %1
}

define i16 @test_call_defined(i16 %a) nounwind {
  %1 = call i16 @defined_function(i16 %a) nounwind
  %2 = add i16 %a, %1
  ret i16 %2
}</pre>
</div>
</div>
<div class="paragraph">
<p>次のようなアセンブリに化けるようになった。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>    .text
    .file    "&lt;stdin&gt;"
    .globl    defined_function        # -- Begin function defined_function
    .p2align    1
    .type    defined_function,@function
defined_function:                       # @defined_function
# %bb.0:
    addi    sp, -2
    sw    fp, 0(sp)
    mov    fp, sp
    addi    fp, 2
    addi    a0, 1
    lw    fp, 0(sp)
    addi    sp, 2
    jr    ra
.Lfunc_end0:
    .size    defined_function, .Lfunc_end0-defined_function
                                        # -- End function
    .globl    test_call_defined       # -- Begin function test_call_defined
    .p2align    1
    .type    test_call_defined,@function
test_call_defined:                      # @test_call_defined
# %bb.0:
    addi    sp, -6
    sw    ra, 4(sp)
    sw    fp, 2(sp)
    sw    s0, 0(sp)
    mov    fp, sp
    addi    fp, 6
    mov    s0, a0
    li    a1, defined_function
    jalr    a1
    add    s0, a0
    mov    a0, s0
    lw    s0, 0(sp)
    lw    fp, 2(sp)
    lw    ra, 4(sp)
    addi    sp, 6
    jr    ra
.Lfunc_end1:
    .size    test_call_defined, .Lfunc_end1-test_call_defined
                                        # -- End function

    .section    ".note.GNU-stack","",@progbits</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_select_に対応する"><code>select</code> に対応する</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>select</code> は条件に応じて2つの値の一方を選択する命令である。
C言語の条件演算子<sup class="footnote">[<a id="_footnoteref_32" class="footnote" href="#_footnotedef_32" title="View footnote.">32</a>]</sup>
<code>?:</code> に対応するようだ<sup class="footnote">[<a id="_footnoteref_33" class="footnote" href="#_footnotedef_33" title="View footnote.">33</a>]</sup>。対応するSelectionDAGノードは <code>SELECT</code> と <code>SELECT_CC</code> で、
次のように定義される。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/// Select(COND, TRUEVAL, FALSEVAL).  If the type of the boolean COND is not
/// i1 then the high bits must conform to getBooleanContents.
SELECT,

/// Select with condition operator - This selects between a true value and
/// a false value (ops #2 and #3) based on the boolean result of comparing
/// the lhs and rhs (ops #0 and #1) of a conditional expression with the
/// condition code in op #4, a CondCodeSDNode.
SELECT_CC,</pre>
</div>
</div>
<div class="paragraph">
<p>RISC Vでは <code>SELECT_CC</code> をexpandした上で <code>SELECT</code> をcustomにlowerして
<code>RISCVISD::SELECT_CC</code> とし、これを擬似命令 <code>Select_GPR_Using_CC_GPR</code> で捕捉している。
この擬似命令にはcustom inserterが付随していて、
<code>RISCVTargetLowering::EmitInstrWithCustomInserter</code> にてこの擬似命令を
<code>MachineInstr</code> に変換している。</p>
</div>
<div class="paragraph">
<p><code>EmitInstrWithCustomInserter</code> は <code>usesCustomInserter</code> フラグが立っている
<code>MachineInstr</code> に対してフックし、これを適切な命令に変換・伸張する。
すなわち <code>MachineInstr</code> を異なる <code>MachineInstr</code> に変換するということである。</p>
</div>
<div class="paragraph">
<p>SparcもRISC Vと同様の手法を取っている<sup class="footnote">[<a id="_footnoteref_34" class="footnote" href="#_footnotedef_34" title="View footnote.">34</a>]</sup>が、
<code>SELECT</code> ではなく <code>SELECT_CC</code> をlowerしている。
そのため <code>LowerSELECT_CC</code> で比較命令と <code>SPISD::SELECT_ICC</code> を作成し、
これを <code>EmitInstrWithCustomInserter</code> で処理している。
なお <code>setcc</code> が使用された場合に冗長なコードが出力されるのを防ぐためSparc
バックエンドでは <code>LookThroughSetCC</code> という関数を定義し、
<code>(cmpLHS &lt; cmpRHS ? 1 : 0) != 0 ? TrueVal : FalseVal</code> というノードが現れた
場合は <code>cmpLHS &lt; cmpRHS ? TrueVal : FalseVal</code> と変換する処理を行っている<sup class="footnote">[<a id="_footnoteref_35" class="footnote" href="#_footnotedef_35" title="View footnote.">35</a>]</sup>。</p>
</div>
<div class="paragraph">
<p>Lanaiでは <code>SELECT_CC</code> のハードウェアサポートが存在するため、
<code>ISD::SELECT_CC</code> を <code>LanaiISD::SELECT_CC</code> に置換した後、その命令にパターンマッチさせて
いる。</p>
</div>
<div class="paragraph">
<p>x86では <code>SELECT_CC</code> をexpandしたうえで <code>SELECT</code> を捕捉し、
<code>Select (COND, TRUEVAL, FALSEVAL)</code> に対し、 <code>COND</code> が真ならば <code>TRUEVAL</code> を
<code>FALSEVAL</code> に代入するような <code>X86ISD::CMOV</code> を発行している。
これはパターンマッチによって <code>CMOVcc</code> <sup class="footnote">[<a id="_footnoteref_36" class="footnote" href="#_footnotedef_36" title="View footnote.">36</a>]</sup>に変換される。</p>
</div>
<div class="paragraph">
<p>RV16KではRISC Vの手法をとる。すなわち <code>SELECT_CC</code> はexpandした上で <code>SELECT</code> と
それに付随する <code>setcc</code> を <code>RV16KISD::SELECT_CC</code> にlowerする。
<code>setcc</code> がない場合は定数 <code>0</code> を補う。その後 <code>RV16KISD::SELECT_CC</code> を
擬似命令 <code>SelectCCrr</code> に変換し、これに対してcustom inserterを適用して
処理を行う。</p>
</div>
<div class="paragraph">
<p><code>getNode</code> に <code>SDVTList</code> を渡しているのは <code>RV16KISD::SELECT_CC</code> の出力の型として
<code>i16</code> とGlueの2種類があるからのようだが、判然としない（要確認；TODO）。</p>
</div>
<div class="paragraph">
<p><code>EmitInstrWithCustomInserter</code> では新たに制御構造を追加し、
<code>SelectCCrr</code> を具体的な <code>MachineInstr</code> に変換する。
<code>BuildMI</code> を用いて比較命令とジャンプ命令の2つを生成する。
この比較命令とジャンプ命令の間に、後々のパスで別の命令が入る可能性は
<code>Defs</code> と <code>Uses</code> の適切な指定によって排除されている（要確認；TODO）。</p>
</div>
<div class="paragraph">
<p>新たに擬似命令として <code>SelectCCri</code> を追加し、右辺が即値の場合には <code>cmpi</code> を出力するように
した。</p>
</div>
<div class="paragraph">
<p>ところでわざわざ <code>EmitInstrWithCustomInserter</code> など使わずとも、
<code>LowerSELECT</code> で適当なSelectionDAGを作り <code>SELECT</code> の挙動を実現することは
できないのだろうか。調べた限りでは、LLVMのバックエンドにおいて新たなbasic blockを
作成することはできず<sup class="footnote">[<a id="_footnoteref_37" class="footnote" href="#_footnotedef_37" title="View footnote.">37</a>]</sup>、そのためにジャンプ先の
<code>SDValue</code> を作ることができないように見えるが、判然としない（要確認；TODO）。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_落穂拾いをする">落穂拾いをする</h2>
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<img src="img/gleaners.jpg" alt="gleaners">
</div>
</div>
<div class="paragraph">
<p><em>The Gleaners</em>&#8201;&#8212;&#8201;Jean-François Millet<a href="#wikipedia-The_Gleaners">[69]</a></p>
</div>
<div class="paragraph">
<p>上記で最低限のコード生成は行えるようになったが、未だ多くの（雑多な）IRに対応していない。
そこで今までに作成した部分を利用してこれらに対応する。
またその途中で必要となる未サポートの機能に対応する。
参考にするRISC Vのパッチは主に<a href="#github_riscv-llvm_patch_20">[70]</a>である。</p>
</div>
<div class="paragraph">
<p>以下では <code>setOperationAction</code> を利用してコード生成を可能にする場合が多い。
関数定義に付されたコメントによれば、この関数に指定する型は入力と出力のどちらをも
表す場合があるようだ<sup class="footnote">[<a id="_footnoteref_38" class="footnote" href="#_footnotedef_38" title="View footnote.">38</a>]</sup>。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/// Indicate that the specified operation does not work with the specified
/// type and indicate what to do about it. Note that VT may refer to either
/// the type of a result or that of an operand of Op.
void setOperationAction(unsigned Op, MVT VT,
                      LegalizeAction Action) {
  assert(Op &lt; array_lengthof(OpActions[0]) &amp;&amp; "Table isn't big enough!");
  OpActions[(unsigned)VT.SimpleTy][Op] = Action;
}</pre>
</div>
</div>
<div class="sect2">
<h3 id="_大きなスタックフレームに対応する">大きなスタックフレームに対応する</h3>
<div class="paragraph">
<p>関数プロローグでは <code>sp</code> を押し下げるコードを出力する必要がある。
このとき小さいスタックフレームであれば <code>addi</code> のみで対応できるため問題にならない。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>define void @test() nounwind {
  %tmp = alloca [ 3 x i8 ] , align 2
  ret void
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ bin/llc -mtriple=rv16k -verify-machineinstrs -print-after=prologepilog &lt; foo.ll &gt; /dev/null
# *** IR Dump After Prologue/Epilogue Insertion &amp; Frame Finalization ***:
# Machine code for function test: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=3, align=2, at location [SP-6]
  fi#1: size=2, align=2, at location [SP-2]

bb.0 (%ir-block.0):
  $x1 = frame-setup ADDI $x1(tied-def 0), -6, implicit-def $flags
  SW killed $x2, $x1, 4, implicit-def $flags
  $x2 = MOV $x1, implicit-def $flags
  $x2 = frame-setup ADDI $x2(tied-def 0), 6, implicit-def $flags
  $x2 = LW $x1, 4, implicit-def $flags
  $x1 = frame-destroy ADDI $x1(tied-def 0), 6, implicit-def $flags
  PseudoRET

# End machine code for function test.</pre>
</div>
</div>
<div class="paragraph">
<p>一方で大きなスタックフレームでは <code>li</code> と <code>add</code> <sup class="footnote">[<a id="_footnoteref_39" class="footnote" href="#_footnotedef_39" title="View footnote.">39</a>]</sup> を組み合わせる必要がある。
このとき一度使い捨てのレジスタに <code>li</code> で即値を読み込み、
その上で <code>add</code> しなければならない。これをナイーブに実装する<sup class="footnote">[<a id="_footnoteref_40" class="footnote" href="#_footnotedef_40" title="View footnote.">40</a>]</sup>
と次のようなエラーが出る。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>define void @test() nounwind {
  %tmp = alloca [ 30000 x i8 ] , align 2
  ret void
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ bin/llc -mtriple=rv16k -verify-machineinstrs  &lt; foo.ll
	.text
	.file	"&lt;stdin&gt;"

# After Prologue/Epilogue Insertion &amp; Frame Finalization
# Machine code for function test: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=30000, align=2, at location [SP-30002]
  fi#1: size=2, align=2, at location [SP-2]

bb.0 (%ir-block.0):
  %0:gpr = frame-setup LI 30002, implicit-def $flags
  $x1 = frame-setup SUB $x1(tied-def 0), killed %0:gpr, implicit-def $flags
  SW killed $x2, $x1, 30000, implicit-def $flags
  $x2 = MOV $x1, implicit-def $flags
  %1:gpr = frame-setup LI 30002, implicit-def $flags
  $x2 = frame-setup ADD $x2(tied-def 0), killed %1:gpr, implicit-def $flags
  $x2 = LW $x1, 30000, implicit-def $flags
  %2:gpr = frame-destroy LI 30002, implicit-def $flags
  $x1 = frame-destroy ADD $x1(tied-def 0), killed %2:gpr, implicit-def $flags
  PseudoRET

# End machine code for function test.

*** Bad machine code: Function has NoVRegs property but there are VReg operands ***
- function:    test
LLVM ERROR: Found 1 machine code errors.</pre>
</div>
</div>
<div class="paragraph">
<p>これはおそらく <code>frame-setup/frame-destroy</code> に仮想レジスタ <code>%0/%1/%2</code> が登場していることが
原因である。これらは本来物理レジスタに割り付けられなければならないためエラーが
発生している<sup class="footnote">[<a id="_footnoteref_41" class="footnote" href="#_footnotedef_41" title="View footnote.">41</a>]</sup>。
スタックフレームの調整値が大きい場合 <code>addi</code> を使用することが出来ず <code>li</code> と <code>add</code> を
組み合わせて実現する必要がある。ここで使用する使い捨ての仮想レジスタに物理レジスタが
割り付けられていないようだ。これに対応するためには <code>RV16KRegisterInfo</code> にて
<code>requiresRegisterScavenging</code> と <code>requiresFrameIndexScavenging</code> から <code>true</code> を返すよう
オーバーライドする必要がある<a href="#github_riscv-llvm_patch_27">[77]</a>。
LLVMはレジスタ割付をした後に関数プロローグ・エピローグの挿入を行う
<a href="#llvm-code_generator">[31]</a>。そのため関数プロローグ・エピローグで挿入される
仮想レジスタに正しく物理レジスタを割り付ける特別な仕組みが必要となるようだ
<sup class="footnote">[<a id="_footnoteref_42" class="footnote" href="#_footnotedef_42" title="View footnote.">42</a>]</sup>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_命令に対するフラグを追加する">命令に対するフラグを追加する</h3>
<div class="paragraph">
<p>2オペランド命令のうち左右辺を入れ替えられるものについては <code>isCommutable</code> を <code>1</code> にする。
これによって生成される命令が効率化される<sup class="footnote">[<a id="_footnoteref_43" class="footnote" href="#_footnotedef_43" title="View footnote.">43</a>]</sup>。
また <code>isMoveImm</code> や <code>isMoveReg</code> ・ <code>isAdd</code> フラグなども（おまじない程度に）立てておく。</p>
</div>
</div>
<div class="sect2">
<h3 id="_setcc_に対応する"><code>SETCC</code> に対応する</h3>
<div class="paragraph">
<p>条件分岐や <code>SELECT</code> に付随する <code>SETCC</code> には対応したが、
単発の <code>SETCC</code> には対応できていない。RV16Kには対応する命令がないため、
これはexpandして <code>SELECT</code> として扱う<sup class="footnote">[<a id="_footnoteref_44" class="footnote" href="#_footnotedef_44" title="View footnote.">44</a>]</sup>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_キャリー付き加減算に対応する">キャリー付き加減算に対応する</h3>
<div class="paragraph">
<p><a href="#github_riscv-llvm_patch_20">[70]</a>では <code>ADDC/ADDE/SUBC/SUBE</code> に対応している。
これらは他倍長の加減算に対応するための命令でcarryを（明示的に）
受け取り・出力する加減を行う。このような命令はRV16Kにはないためexpandする必要がある。</p>
</div>
<div class="paragraph">
<p>しかし試してみると、expandしなくともすでにi32の演算に対応していた<sup class="footnote">[<a id="_footnoteref_45" class="footnote" href="#_footnotedef_45" title="View footnote.">45</a>]</sup>。実際
現在のRISC V実装でもこれらに対するexpandは明示されていない。
どうやらLLVM core側で指定されるようになったようだ<a href="#llvm_phabricator-d47422">[71]</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_lowercall_内で_externalsymbolsdnode_を処理する"><code>LowerCall</code> 内で <code>ExternalSymbolSDNode</code> を処理する</h3>
<div class="paragraph">
<p>すでに <code>GlobalAddress</code> については対応しているが、同様に <code>ExternalSymbol</code> についても
対応する。 <code>TargetExternalSymbol</code> に変換した上で <code>LI</code> にて値を読み込むようにする。
これによって <code>MachineOperand::MO_ExternalSymbol</code> が <code>MachineInstr</code> 中に出現するようになるため、
<code>LowerRV16KMachineOperandToMCOperand</code> にてこれに対処する。</p>
</div>
<div class="paragraph">
<p>なお <code>ExternalSymbol</code> は、そのシンボルが指す関数をLLVMが把握していないときに用いられる点で
<code>GlobalAddress</code> と異なる<a href="#llvm_dev_ml-001264">[73]</a><sup class="footnote">[<a id="_footnoteref_46" class="footnote" href="#_footnotedef_46" title="View footnote.">46</a>]</sup>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_掛け算に対応する">掛け算に対応する</h3>
<div class="paragraph">
<p>後の <code>CTLZ</code> の実装などでも必要となる掛け算を実装する。RV16Kv2では掛け算命令が存在しないため
<code>MUL/SMUL_LOHI/UMUL_LOHI/MULHS/MULHU</code> についてexpandする。ここで <code>SMUL_LOHI/UMUL_LOHI</code> は
Nビット二数を掛けて得られる2Nビットの結果を2つのNビットレジスタにて返す。
また <code>MULHS/MULHU</code> は同様の2Nビットの結果のうち、上位Nビットのみを返す。
なおLLVMにおいて <code>mul</code> は符号の有無を問わない<sup class="footnote">[<a id="_footnoteref_47" class="footnote" href="#_footnotedef_47" title="View footnote.">47</a>]</sup>。</p>
</div>
<div class="paragraph">
<p>さてこれらの命令は <code><em>mulhi3</code> と <code></em>mulsi3</code> を呼ぶようにexpandされる。
<code><em>mulhi3</code> は16bit整数の掛け算を行い <code></em>mulsi3</code> は32bit整数の掛け算を行う（ぽい；要確認 TODO）。
したがってこれらの関数がリンクされる必要がある。たとえばRISC Vではcompiler-rtに
<code>__mulsi3</code> を追加して目的を達成している<a href="#github-riscv_compiler_rt">[76]</a><a href="#llvm_phabricator-d42958">[74]</a>。
compiler-rtは主にClangやLLVMのためのランタイムライブラリである<a href="#compiler_rt">[75]</a>。</p>
</div>
<div class="paragraph">
<p>とりあえずここではcompiler-rtまで踏み込むことは後回しにし、
文字列として <code>__mulhi3</code> などを出すまでに留める。</p>
</div>
</div>
<div class="sect2">
<h3 id="_rotlrotrbswapcttzctlzctpop_に対応する"><code>ROTL/ROTR/BSWAP/CTTZ/CTLZ/CTPOP</code> に対応する</h3>
<div class="paragraph">
<p>特殊な<sup class="footnote">[<a id="_footnoteref_48" class="footnote" href="#_footnotedef_48" title="View footnote.">48</a>]</sup>ビット演算に対応する。
RV16Kにはこれらに対応する命令が直接は存在しないためexpandする。
各々の操作の意味については<a href="#llvm-langref">[43]</a>に詳しい。</p>
</div>
<div class="paragraph">
<p><code>rotl</code> のようなLLVM IRレベルで対応する関数のことをintrinsic functionと呼ぶ。
the intrinsicと呼称される場合もある。ようするにビルトイン関数のことのようだ。
拡張方法が<a href="#llvm-extendingllvm">[72]</a>にある。</p>
</div>
</div>
<div class="sect2">
<h3 id="_除算剰余に対応する">除算・剰余に対応する</h3>
<div class="paragraph">
<p>RV16Kv2には除算・剰余のための命令が存在しないため
<code>SREM/SDIVREM/SDIV/UREM/UDIVREM/UDIV</code> についてexpandする。</p>
</div>
</div>
<div class="sect2">
<h3 id="_32bitのシフトに対応する">32bitのシフトに対応する</h3>
<div class="paragraph">
<p><code>SHL_PARTS/SRL_PARTS/SRA_PARTS</code> についてexpandする。
これによって <code><em>lshrsi3/</em>ashrsi3/__ashlsi3</code> を各々呼ぶように伸張される。</p>
</div>
</div>
<div class="sect2">
<h3 id="_単体の_sextzexttrunc_に対応する">単体の <code>sext/zext/trunc</code> に対応する</h3>
<div class="paragraph">
<p><code>SIGN_EXTEND_INREG</code> を <code>i1</code> と <code>i8</code> についてexpandする<sup class="footnote">[<a id="_footnoteref_49" class="footnote" href="#_footnotedef_49" title="View footnote.">49</a>]</sup>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_間接ジャンプに対応する">間接ジャンプに対応する</h3>
<div class="paragraph">
<p><code>brind</code> に対するパターンをTableGenファイルに記述する。</p>
</div>
<div class="paragraph">
<p>間接ジャンプに関するRISC Vのテストでは <code>getelementptr inbounds</code> が使用されている<a href="#github_riscv-llvm_patch_20">[70]</a>。
LLVM IRの言語仕様<a href="#llvm-langref">[43]</a>によれば、 <code>inbounds</code> が指定される場合、
第二引数として渡すbase pointerが適切なアドレスを指して
いないときには結果の値としてpoison value <sup class="footnote">[<a id="_footnoteref_50" class="footnote" href="#_footnotedef_50" title="View footnote.">50</a>]</sup>が返される。
ここでどのようにその適切性を調べるのかは判然としない。
実際関数の引数が第二引数にくるような今回の場合では、実行時にならなければ
判断がつかないように思われる<sup class="footnote">[<a id="_footnoteref_51" class="footnote" href="#_footnotedef_51" title="View footnote.">51</a>]</sup>。
要確認；TODO。実際この例では <code>inbounds</code> がなくとも正常に動作したが、おまじない程度につけておく。</p>
</div>
</div>
<div class="sect2">
<h3 id="_blockaddress_のlowerに対応する"><code>BlockAddress</code> のlowerに対応する</h3>
<div class="paragraph">
<p><code>BlockAddress</code> はbasic blockのアドレスを表す。C言語においてラベルのアドレスを取得し
<code>goto</code> する場合などに用いられる<a href="#github-emscripten-issues-34">[81]</a><sup class="footnote">[<a id="_footnoteref_52" class="footnote" href="#_footnotedef_52" title="View footnote.">52</a>]</sup>。
LLVM IRでは <code>blockaddress</code> 定数を利用することで取得できる<a href="#llvm-langref">[43]</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_ジャンプテーブルに対応しない">ジャンプテーブルに対応しない</h3>
<div class="paragraph">
<p>LLVM IRには <code>switch</code> という命令があり、意味論はC言語の <code>switch</code> 文と対応する<sup class="footnote">[<a id="_footnoteref_53" class="footnote" href="#_footnotedef_53" title="View footnote.">53</a>]</sup>。
これに対応したい。</p>
</div>
<div class="paragraph">
<p>LLVMは <code>switch</code> をコンパイルする際にjump tableを用いる場合がある<a href="#switch_lowering_in_llvm">[82]</a>。
これに対応するためには <code>ISD::BR_JT</code> と <code>ISD::JumpTable</code> を適切に処理する必要がある。
しかしRISC Vではこれを無効化している。AVRも同様である<a href="#github-avr_llvm-issues-88">[83]</a>。
Lanaiの実装を参考にすると <code>GlobalAddress</code> などと同様に処理すれば良いように見える。</p>
</div>
<div class="paragraph">
<p>とりあえずここではRISC V・AVRと同様に <code>setMinimumJumpTableEntries(INT_MAX);</code> とすることで
ジャンプテーブルの生成を抑止することで解決する<sup class="footnote">[<a id="_footnoteref_54" class="footnote" href="#_footnotedef_54" title="View footnote.">54</a>]</sup>。これによって <code>switch</code> は当面
<code>if-else</code> の連続としてコンパイルされることになるようだ<sup class="footnote">[<a id="_footnoteref_55" class="footnote" href="#_footnotedef_55" title="View footnote.">55</a>]</sup>。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_frame_pointer_eliminationに対応する">frame pointer eliminationに対応する</h2>
<div class="sectionbody">
<div class="paragraph">
<p>現在の実装では <code>sp</code> と <code>fp</code> の両方を使用してスタックの操作を行っている。
これはスタックに対する操作全てをカバーするためには必要だ<sup class="footnote">[<a id="_footnoteref_56" class="footnote" href="#_footnotedef_56" title="View footnote.">56</a>]</sup>が、
一方で <code>sp</code> のみで十分である関数も多い。そこでそのような場合に限って
<code>fp</code> の使用をやめ、全て <code>sp</code> を通じてスタックを操作することで、
レジスタを1つ多く使用することができる。これを実装する。
参考にするパッチは<a href="#github_riscv-llvm_patch_27">[77]</a>。</p>
</div>
<div class="paragraph">
<p>まず <code>RV16KFrameLowering::hasFP</code> を実装する。この関数は引数に <code>MachineFunction</code> をとり、
この関数に <code>fp</code> が必要か否かを返す。その後prologue/epilogueやRegisterInfoなどを適切に
実装すればよい。</p>
</div>
<div class="paragraph">
<p>この変更によってテストの正解コードが多く変更されるので頑張って修正する。
Vimで置換すると楽だった。コマンドラインウィンドウはいいぞ。</p>
</div>
<div class="paragraph">
<p>幾つかのテスト（ <code>large-stack.ll</code> ）については、これによってテストしたい内容が
最終的なアセンブリから消えてしまう場合があるため <code>-frame-pointer=all</code> オプションを
つけてframe pointer eliminationを無効化した場合の結果もテストするようにする。
なお<a href="#github_riscv-llvm_patch_27">[77]</a>ではこれのために <code>-disable-fp-elim</code> オプションが
使われているが、オプションの名前が最近変更されたようだ<a href="#llvm_phabricator-d56351">[85]</a>。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_動的なスタック領域確保に対応する">動的なスタック領域確保に対応する</h2>
<div class="sectionbody">
<div class="paragraph">
<p>C99の可変長配列（VLA; Variable-Length Array）のような、スタック領域の動的確保に対応する。
領域の確保そのものは <code>alloca</code> 命令によって行われる。したがってこの命令が動的な値をオペランドに
取れるように <code>DYNAMIC_STACKALLOC</code> をexpandする。</p>
</div>
<div class="paragraph">
<p>また一般的に、動的スタック領域確保にはスタック状態の退避・復帰<sup class="footnote">[<a id="_footnoteref_57" class="footnote" href="#_footnotedef_57" title="View footnote.">57</a>]</sup>が必要である
<a href="#llvm_dev_ml-115805">[87]</a><a href="#hatenablog-rhysd-230119">[86]</a>。
このために <code>llvm.stacksave</code> と <code>llvm.stackrestore</code> 命令が用いられるため、これらに対応する
<code>STACKSAVE</code> と <code>STACKRESTORE</code> をexpandする。命令の詳細は<a href="#llvm-langref">[43]</a>を参照する。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_関数呼び出しを_jal_で行うようにする">関数呼び出しを <code>jal</code> で行うようにする</h2>
<div class="sectionbody">
<div class="paragraph">
<p>現状関数呼び出しは、まず <code>li</code> で関数のアドレスをレジスタに格納し、
その後に <code>jalr</code> を実行して関数にジャンプしている。しかしRV16Kv2では
<code>jal</code> 命令が16bitのアドレスをそのままとることができるため、
この2命令を <code>jal</code> 1命令に置き換えることが可能である。</p>
</div>
<div class="paragraph">
<p>RISC Vのアセンブリ上では、関数呼び出しを <code>call</code> という一命令で表現している。
これは <code>PseudoCALL</code> と1対1に対応する。
しかしこのような命令はRISC Vに存在せず、
内部的には <code>auipc</code> と <code>jalr</code> の二命令を用いて表現される。
一方で、RISC Vには <code>jal</code> 命令が存在し、
これを用いれば一命令で関数呼び出しを実現できるように思えるが、
実際にはビット幅の制限からすべての関数呼び出しにおいて <code>jal</code> を使えるわけではない。
さらに悪いことに <code>jal</code> が適用できるか否か、一般的にはリンク時まで判断できない。
したがってRISC Vのバックエンドは、すべての <code>PseudoCALL</code> を <code>auipc</code> と <code>jalr</code> に置き換える手法を
採用している<a href="#llvm_phabricator-d44885">[78]</a><a href="#llvm_phabricator-d45859">[79]</a>。</p>
</div>
<div class="paragraph">
<p>対してRV16Kはすべての関数呼び出しを <code>jal</code> で扱うことができ、
またアセンブリ上も <code>jal</code> と表記される。したがって <code>PseudoCALL</code> 疑似命令を導入するメリットは
少なく、単にパターンマッチを行えば良い。</p>
</div>
<div class="paragraph">
<p>そこで従来の <code>PseudoCALL</code> の代わりに <code>def : Pat&lt;(Call GPR:$rs), (JALR GPR:$rs)&gt;;</code> を追加すると
<code>LowerRV16KMachineInstrToMCInst</code> が <code>MO_RegisterMask</code> を扱えないというエラーが出る。
<code>MO_RegisterMask</code> は関数呼び出しを行う際などに指定され、
関数呼び出しなどによって非明示的に書き換わるレジスタを表す<a href="#llvm-code_generator">[31]</a><sup class="footnote">[<a id="_footnoteref_58" class="footnote" href="#_footnotedef_58" title="View footnote.">58</a>]</sup>。
これはレジスタのimplicit defと同じ役割のため <code>MCInst</code>
においては無視するように変更する<a href="#github_riscv-llvm_patch_18">[42]</a>。</p>
</div>
<div class="paragraph">
<p>続いて <code>jalr</code> のオペランドに直接シンボルを指定するように変更する。これが本題である。
シンボルというのは結局 <code>GlobalAddress</code> と <code>ExternalSymbol</code> のことなので、
これらについてパターンマッチを追加する。次いで、現在 <code>LowerCall</code> で<sup class="footnote">[<a id="_footnoteref_59" class="footnote" href="#_footnotedef_59" title="View footnote.">59</a>]</sup>行っている
<code>LI</code> ノードの作成をやめ、 <code>TargetGlobalAddress</code> と <code>TargetExternalSymbol</code> の変換のみを
行うようにする。</p>
</div>
<div class="paragraph">
<p>ここで次のように指定すると正しく動作する。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>def : Pat&lt;(Call GPR:$rs), (JALR GPR:$rs)&gt;;
def : Pat&lt;(Call tglobaladdr:$dst), (JAL tglobaladdr:$dst)&gt;;
def : Pat&lt;(Call texternalsym:$dst), (JAL texternalsym:$dst)&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>ここで下2つをコメントアウトすると <code>jal</code> の代わりに <code>jalr</code> が使用される。
どうやら <code>tglobaladdr</code> が <code>GPR</code> にマッチするようだが、原因不明（TODO）。</p>
</div>
<div class="paragraph">
<p>いままでのテストが壊れるので頑張って直す。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_frameindex_をlowerする"><code>FrameIndex</code> をlowerする</h2>
<div class="sectionbody">
<div class="paragraph">
<p>現在のバックエンドで次のようなLLVM IRをコンパイルしようとするとエラーが出力される。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cat foo.ll
define void @test() {
entry:
  %retval = alloca i16, align 2
  store i16 0, i16* %retval, align 2
  ret void
}

$ bin/llc -mtriple=rv16k -verify-machineinstrs &lt; foo.ll
	.text
	.file	"&lt;stdin&gt;"
LLVM ERROR: Cannot select: t2: i16 = FrameIndex\&lt;0\&gt;
In function: test</pre>
</div>
</div>
<div class="paragraph">
<p>SelectionDAGの <code>FrameIndex</code> に対してパターンマッチが存在しないために
<code>MachineInstr</code> を選択できないというエラーである。</p>
</div>
<div class="paragraph">
<p>そもそも <code>FrameIndex</code> とは何か。<a href="#stackoverflow-frame_lowering">[63]</a>では次のように説明される。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>When variables on the stack are referred to before the prologue-epilogue insertion (PEI) step, they are addressed using "frame indexes", an arbitrary name for a location that will eventually resolve to a stack-pointer relative offset.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p><code>TargetSelectionDAG.td</code> には次のように定義される。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>def frameindex  : SDNode&lt;"ISD::FrameIndex",           SDTPtrLeaf, [],
                         "FrameIndexSDNode"&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p><a href="#llvm-welcome_to_the_back_end_2017">[46]</a><a href="#llvm_dev_ml-selecting_frame_index">[64]</a>や
上記によれば、
frame indexとはフレーム上に割り付けられた変数の位置を表す抽象的なアドレスのこと
<sup class="footnote">[<a id="_footnoteref_60" class="footnote" href="#_footnotedef_60" title="View footnote.">60</a>]</sup>であり、
関数プロローグ・エピローグ挿入時に具体的な値（ <code>sp</code> や <code>fp</code> からの相対アドレスなど）
に置き換えられる。
逆に言えば命令選択時などはこのframe indexを各種命令のオペランドとすることになる。
そのような状態に対処するために <code>ISD::FrameIndex</code> が用意されている。
これについて独自アーキテクチャ側で対応するためには、まずi) <code>frameindex</code> をオペランドとして受け取る
ような命令を定義する。ただし直接 <code>frameindex</code>
をオペランドに指定することはLLVMの仕様上できない<a href="#github_riscv-llvm_patch_22">[91]</a>ため、
<code>frameindex</code> をtarget frame indexに変換するような <code>ComplexPattern</code> を定義し、
これをオペランドの型として指定する<sup class="footnote">[<a id="_footnoteref_61" class="footnote" href="#_footnotedef_61" title="View footnote.">61</a>]</sup>。これによってオペランドの <code>frameindex</code> は適切に処理されることになる。
ついで <code>frameindex</code> （を含む <code>ComplexPattern</code> ）をオペランドとして持たない場所で
<code>frameindex</code> が使用された場合に対処するため <code>RV16KDAGToDAGISel::Select</code> で <code>ISD::FrameIndex</code> を
トラップする。ここではレジスタに格納されたframe indexに即値0を足すようなDAGノードを
RISC VやLanaiは返している。よくわからない。TODO
とりあえず <code>llvm_unreachable</code> を仕込んで、エラーになるまで
放置する<sup class="footnote">[<a id="_footnoteref_62" class="footnote" href="#_footnotedef_62" title="View footnote.">62</a>]</sup>。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>//===----------------------------------------------------------------------===//
// Complex pattern definitions.
//

// Complex patterns, e.g. X86 addressing mode, requires pattern matching code
// in C++. NumOperands is the number of operands returned by the select function;
// SelectFunc is the name of the function used to pattern match the max. pattern;
// RootNodes are the list of possible root nodes of the sub-dags to match.
// e.g. X86 addressing mode - def addr : ComplexPattern&lt;4, "SelectAddr", [add]&gt;;
//
class ComplexPattern&lt;ValueType ty, int numops, string fn,
                     list&lt;SDNode&gt; roots = [], list&lt;SDNodeProperty&gt; props = [],
                     int complexity = -1&gt; {
  ValueType Ty = ty;
  int NumOperands = numops;
  string SelectFunc = fn;
  list&lt;SDNode&gt; RootNodes = roots;
  list&lt;SDNodeProperty&gt; Properties = props;
  int Complexity = complexity;
}</pre>
</div>
</div>
<div class="paragraph">
<p><code>ComplexPattern</code> に指定するroot nodesは、パターンマッチが試行されるべきノードを
表している。例えばx86の <code>lea32addr</code> では次のように定義され、
通常の四則演算を <code>lea</code> 命令に変更できることを示唆している<sup class="footnote">[<a id="_footnoteref_63" class="footnote" href="#_footnotedef_63" title="View footnote.">63</a>]</sup>。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>def lea32addr : ComplexPattern&lt;i32, 5, "selectLEAAddr",
                               [add, sub, mul, X86mul_imm, shl, or, frameindex],
                               []&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>ここで、これはSelectionDAGからMachineDAGに変換する部分に影響することに注意が必要である。
例えば <code>RV16KInstrInfo::storeRegToStackSlot</code> などで <code>addFrameIndex</code> を使用して
frame indexを指定するが、これはすでに <code>MachineDAG</code> ノードであるため、
frame indexを処理する機構を必要としない。</p>
</div>
<div class="paragraph">
<p>ここで登場した抽象的なスタックは <code>MachineFrameInfo</code> によって管理される。</p>
</div>
<div class="paragraph">
<p><code>add</code> のみならず <code>add</code> と等価な <code>or</code> についてもパターンが定義される。
これは存在価値が良くわからないのと、他の命令中でやらない理由がわからない。
とりあえずやめておく。TODO</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_clangをrv16kに対応させる">ClangをRV16Kに対応させる</h2>
<div class="sectionbody">
<div class="paragraph">
<p>今までRV16KバックエンドはLLVM IRを受け取りアセンブリ（やオブジェクトファイル）を出力する
ものとして作成してきた。しかし我々が本当にほしいものはCコンパイラであり、
その入力はC言語ソースコードである。
そこでClangをRV16Kに対応させ、本当の「コンパイラ」として駆動するようにする。</p>
</div>
<div class="paragraph">
<p>これに際して参照するRISC Vのパッチは <code>clang</code> ディレクトリにまとめられている
<a href="#github-riscv_llvm-clang">[89]</a>。また単純な32bitRISCアーキテクチャでない
バックエンドのClang対応としてAVRのものや、
ELVMバックエンドのClang対応<a href="#github-elvm_clang">[90]</a>も参考になる。</p>
</div>
<div class="sect2">
<h3 id="_clangのターゲットにrv16kを追加する">ClangのターゲットにRV16Kを追加する</h3>
<div class="paragraph">
<p><code>clang/lib/Basic/Targets.cpp</code> の <code>AllocateTarget</code> にて
<code>rv16k</code> のtripleが渡された場合には <code>RV16KTargetInfo</code> のインスタンスを返すようにし、
<code>clang/lib/Basic/Targets/RV16K.{cpp,h}</code> にその定義を記述する。</p>
</div>
<div class="paragraph">
<p>ここで整数や浮動小数点などのビット幅を指定する<a href="#elvm-slide">[37]</a>。
<code>RV16KTargetInfo</code> が継承する <code>TargetInfo</code> は32bit RISCアーキテクチャを
念頭においた値をデフォルトとしているため、これを16bit用に適宜変更する。
似たようなアーキテクチャとしてAVRのバックエンドが参考になる。</p>
</div>
<div class="paragraph">
<p>以上により <code>clang</code> が一応動作するようになる。動かすときには次のように
<code>-target rv16k</code> を指定することでrv16kを指定する<sup class="footnote">[<a id="_footnoteref_64" class="footnote" href="#_footnotedef_64" title="View footnote.">64</a>]</sup>。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ bin/clang -S -c -target rv16k foo.c -o foo.s</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_clangのdriverにrv16kを追加する">ClangのdriverにRV16Kを追加する</h3>
<div class="paragraph">
<p>先程のコマンドで、直接オブジェクトファイルを出力させるために
<code>-S</code> オプションを外すとエラーとなる。これはclangが内部的にGNU asを呼ぶためである。
これをllvm-mcに変更するためには <code>-fintegrated-as</code> オプションを指定すればよいが、
いちいちユーザが指定するよりはむしろ内部的にデフォルトの設定とすれば良い
<a href="#llvm_dev_ml-087879">[92]</a><a href="#stackoverflow-27467293">[93]</a>。</p>
</div>
<div class="paragraph">
<p>そのために <code>clang/lib/Driver/Driver.cpp</code> を書き換えrv16kのtripleに対して
<code>RV16KToolChain</code> のインスタンスを返すようにし、またその定義を
<code>clang/lib/Driver/ToolChains/RV16K.h</code> に記述する。
RISC Vの対応するパッチ<a href="#github-riscv_llvm-clang-03">[94]</a>では
<code>RV16K.cpp</code> も記述し、コンパイル時に必要なinclude flagsの設定や
リンカのための設定を行っているが、RV16Kv2では現状そこまでの記述は
必要ない<sup class="footnote">[<a id="_footnoteref_65" class="footnote" href="#_footnotedef_65" title="View footnote.">65</a>]</sup>。そこでLanaiバックエンドの
記述を参考にし <code>-fintegrated-as</code> に対応する <code>IsIntegratedAssemblerDefault</code> のみを
記述し、その他の関数は空にしておく。</p>
</div>
</div>
<div class="sect2">
<h3 id="_frame_pointer_eliminationを最適化時に有効にする">frame pointer eliminationを最適化時に有効にする</h3>
<div class="paragraph">
<p><code>clang/lib/Driver/ToolChains/Clang.cpp</code> の <code>useFramePointerForTargetByDefault</code>
に <code>Triple::rv16k</code> を追加すれば良い。このファイルでは他にターゲットに依存した
コマンドラインオプション等を追加できるが、RV16Kv2では存在しないのでその変更は
行わない。</p>
</div>
<div class="paragraph">
<p>また同じファイルに <code>char</code> 型が <code>signed</code> か否かを決める <code>isSignedCharDefault</code> という
関数がある。デフォルトでは <code>signed</code> になるようだが、RISC Vは <code>unsigned</code> に
変更している。RV16Kv2では <code>signed</code> なので<sup class="footnote">[<a id="_footnoteref_66" class="footnote" href="#_footnotedef_66" title="View footnote.">66</a>]</sup>このままにしておく。</p>
</div>
<div class="paragraph">
<p>このようなLLVM IRを入力してみる。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>char add(char a, char b)
{
    return a + b;
}</pre>
</div>
</div>
<div class="paragraph">
<p>signedの場合。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>define dso_local signext i8 @add(i8 signext %a, i8 signext %b) local_unnamed_addr #0 {
entry:
  %add = add i8 %b, %a
  ret i8 %add
}</pre>
</div>
</div>
<div class="paragraph">
<p>unsignedの場合。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>define dso_local zeroext i8 @add(i8 zeroext %a, i8 zeroext %b) local_unnamed_addr #0 {
entry:
  %add = add i8 %b, %a
  ret i8 %add
}</pre>
</div>
</div>
<div class="paragraph">
<p><code>signedext/zeroext</code> が切り替わっていることが分かる。</p>
</div>
<div class="paragraph">
<p>以上のClangへの変更により、次のように動くようになった<sup class="footnote">[<a id="_footnoteref_67" class="footnote" href="#_footnotedef_67" title="View footnote.">67</a>]</sup>。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cat foo.c
int main()
{
    return 42;
}

$ bin/clang -c -O2 -target rv16k foo.c -o foo.o

$ bin/llvm-objdump -d foo.o

foo.o:	file format ELF32-rv16k

Disassembly of section .text:
0000000000000000 main:
       0:	08 78 2a 00 	li	a0, 42
       4:	00 40 	jr	ra</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_スタック経由の引数渡しに対応する">スタック経由の引数渡しに対応する</h2>
<div class="sectionbody">
<div class="paragraph">
<p>関数引数の数の制限を取り払い、レジスタに収まらないものはスタックを経由して渡す。</p>
</div>
<div class="paragraph">
<p>RISC Vでは、TableGenが生成する呼び出し規則解決のコードではRV32Iの
呼び出し規則を達成できないため、新たにフルスクラッチで書き直している
<a href="#github_riscv-llvm_patch_25">[95]</a>。</p>
</div>
<div class="paragraph">
<p><code>LowerFormalArguments</code> は <code>SelectionDAGISel::LowerArguments</code> から呼ばれる。
これは <code>SmallVectorImpl&lt;ISD::InputArg&gt; Ins</code> を作るときにsplitのフラグを
設定する。必要なレジスタ数は <code>TargetLowering::getNumRegisters</code> によって見積もられる。
したがって <code>Ins</code> にはすでにsplitされた入力が保存されている。</p>
</div>
<div class="paragraph">
<p><code>CC_RISCV</code> は <code>ISD::InputArg</code> の内容を引数の順に受け取り、
それをレジスタに保存する（／に保存されている<sup class="footnote">[<a id="_footnoteref_68" class="footnote" href="#_footnotedef_68" title="View footnote.">68</a>]</sup>）かメモリに保存するかを決め <code>CCState::addLoc</code> を呼ぶ。
このとき、複数の引数がまとめて一つの値を示す場合があるため、
それを検知し処理する必要がある。2つに分かれている場合は
各々をレジスタないしスタックに積む。それ以上に別れている場合は
スタックにすべて積み、その先頭アドレスをレジスタないしスタックに積む。
このアドレスのみを渡す手法は <code>CCValAssign::Indirect</code> に対応する。</p>
</div>
<div class="paragraph">
<p>RV16KではLanaiに準じたナイーブな手法でスタックを使用する。すなわち
2バイト毎に引数を区切り順にスタックに格納する。
このためには <code>LowerFormalArguments/LowerCall</code> にてスタック上に
領域が割り振られた場合に <code>DAG.getLoad/DAG.getStore</code> を使用して <code>load/store</code> 命令を
出力する必要がある。また <code>LowerCall</code> における <code>store</code> 命令は互いに関係がなく
順序に意味はないため <code>Chain</code> で結ぶことはせず <code>ISD::TokenFactor</code> で
一つにまとめ挿入する。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/// TokenFactor - This node takes multiple tokens as input and produces a
/// single token result. This is used to represent the fact that the operand
/// operators are independent of each other.
TokenFactor,</pre>
</div>
</div>
<div class="paragraph">
<p>ここで <code>SDValue</code> まわりの疑問が出てきた。現状の <code>LowerCall</code> の最後には
戻り値に <code>CopyFromReg</code> を適用するため次のようなコード片がある。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>  // Copy all of the result registers out of their specified physreg.
  for (auto &amp;VA : RVLocs) {
    // Copy the value out, gluing the copy to the end of the call sequence.
    SDValue RetValue =
        DAG.getCopyFromReg(Chain, DL, VA.getLocReg(), VA.getLocVT(), Glue);
    Chain = RetValue.getValue(1);
    Glue = RetValue.getValue(2);

    InVals.push_back(Chain.getValue(0));
  }</pre>
</div>
</div>
<div class="paragraph">
<p>RISC Vでは最後を <code>InVals.push_back(RetValue)</code> と書き換えている。
この意味を理解したい。</p>
</div>
<div class="paragraph">
<p>上のコードは物理レジスタで戻される結果を仮想レジスタに引き込むための
<code>CopyFromReg</code> ノードを作成するものである。実際にDAGを出力させると
次のようになる。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/sdvalue_copyfromreg.png" alt="sdvalue copyfromreg">
</div>
</div>
<div class="paragraph">
<p>コードと対照させると <code>DAG.getNode</code> はそのノードへの<strong>最初の入力</strong>を
<code>SDValue</code> として返すことが分かる。これはしばしば <code>Chain</code> である。
逆に言えば、子ノードの <code>Chain</code> を <code>DAG.getNode</code> に渡すことによって
DAGをより根の方へ伸ばすことができる。</p>
</div>
<div class="paragraph">
<p>その使われ方から分かるように <code>SDValue</code> は <code>SDNode</code> と添字を持つ。
これによって「どのノードの何番目の入力か」を表している。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/// Unlike LLVM values, Selection DAG nodes may return multiple
/// values as the result of a computation.  Many nodes return multiple values,
/// from loads (which define a token and a return value) to ADDC (which returns
/// a result and a carry value), to calls (which may return an arbitrary number
/// of values).
///
/// As such, each use of a SelectionDAG computation must indicate the node that
/// computes it as well as which return value to use from that node.  This pair
/// of information is represented with the SDValue value type.
///
class SDValue {
  friend struct DenseMapInfo&lt;SDValue&gt;;

  SDNode *Node = nullptr; // The node defining the value we are using.
  unsigned ResNo = 0;     // Which return value of the node we are using.</pre>
</div>
</div>
<div class="paragraph">
<p>ただしここで「入力」とは「DAGの矢印が入ってくる方」という意味で用いている。
実際のコード実行はDAGの葉の方から根の方へ、つまり矢印の方向とは逆の方向に
行われることに注意が必要である<sup class="footnote">[<a id="_footnoteref_69" class="footnote" href="#_footnotedef_69" title="View footnote.">69</a>]</sup>。</p>
</div>
<div class="paragraph">
<p>ここで <code>SDValue::getValue</code> の定義を見ると次のようになっている。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>  SDValue getValue(unsigned R) const {
    return SDValue(Node, R);
  }</pre>
</div>
</div>
<div class="paragraph">
<p>よって <code>getValue</code> が返す <code>SDValue</code> は、そのインスタンスが持つノードの
<strong>兄弟ノード</strong>である<sup class="footnote">[<a id="_footnoteref_70" class="footnote" href="#_footnotedef_70" title="View footnote.">70</a>]</sup>。</p>
</div>
<div class="paragraph">
<p>さてここで再び <code>LowerCall</code> のコードを抜粋する。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>SDValue RetValue =
    DAG.getCopyFromReg(Chain, DL, VA.getLocReg(), VA.getLocVT(), Glue);
Chain = RetValue.getValue(1);
Glue = RetValue.getValue(2);

InVals.push_back(Chain.getValue(0));</pre>
</div>
</div>
<div class="paragraph">
<p>以上の調査から <code>Chain</code> は <code>RetValue</code> が指すノードの2番めの入力を表していることが
分かる。また <code>Chain.getValue(0)</code> は <code>Chain</code> が指すノードの0番目の入力を表し、
それはとりもなおさず <code>RetValue</code> である。
したがって <code>InVals.push_back(Chain.getValue(0));</code> を
<code>InVals.push_back(RetValue);</code> に書き換えても何ら問題はない。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_hlt_擬似命令を追加する"><code>HLT</code> 擬似命令を追加する</h2>
<div class="sectionbody">
<div class="paragraph">
<p>RV16Kv2には明示的な <code>hlt</code> 命令が存在しないが、実用的なプログラムを書く上ではかかせない。
RV16Kv2実行時には必ず動作するサイクル数が指定される<sup class="footnote">[<a id="_footnoteref_71" class="footnote" href="#_footnotedef_71" title="View footnote.">71</a>]</sup>ため、
結局 <code>hlt</code> は無限ループと対応付ければ良いことが分かる。</p>
</div>
<div class="paragraph">
<p>このためにまず <code>HLT</code> 擬似命令をTableGenに追加し、
これを <code>encodeInstruction</code> で <code>j -2</code> <sup class="footnote">[<a id="_footnoteref_72" class="footnote" href="#_footnotedef_72" title="View footnote.">72</a>]</sup>に展開する。こうすることによって
アセンブリ上で <code>hlt</code> 擬似命令を使用することができる。
なおこの手法はRISC Vの <code>PseudoCALL</code> と同じである<a href="#llvm_phabricator-d45859">[79]</a>。</p>
</div>
<div class="paragraph">
<p>ここで <code>PseudoHLT</code> に <code>isCodeGenOnly = 0</code> を指定した上で <code>AsmString</code> を
上書きしなければ、アセンブリ中の <code>hlt</code> がパーズされないことに注意が必要である。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_実行可能ファイルを作る">実行可能ファイルを作る</h2>
<div class="sectionbody">
<div class="paragraph">
<p>lld<a href="#llvm-lld">[101]</a><sup class="footnote">[<a id="_footnoteref_73" class="footnote" href="#_footnotedef_73" title="View footnote.">73</a>]</sup>
に変更を加えてRV16Kのオブジェクトファイルから実行可能ファイルを
生成するようにする。RISC Vのlld対応<a href="#llvm_phabricator-d39322">[97]</a>や
Cpu0のlld対応<a href="#cpu0-lld">[98]</a>が参考になる。
またLLVM Cauldron 2016において"How to add a new target to LLD"と
銘打たれた講演があり、YouTubeで公開されている
<a href="#youtube-how_to_add_a_new_target_to_lld">[99]</a><a href="#llvm-smith_newlldtargetpdf">[100]</a>。</p>
</div>
<div class="sect2">
<h3 id="_elfのセクション構造を考える">ELFのセクション構造を考える</h3>
<div class="imageblock">
<div class="content">
<img src="img/elfmap.png" alt="elfmap">
</div>
</div>
<div class="paragraph">
<p>ここでRV16KのアーキテクチャとELFのセクション構造を厳密に考える必要が出てきた。
すなわちRV16KはROMとRAMの両方を持つアーキテクチャであり、プログラム部分（ <code>.text</code> セクション）は
ROMに配置し、データ部分（ <code>.data</code> や <code>.rodata</code> セクション<sup class="footnote">[<a id="_footnoteref_74" class="footnote" href="#_footnotedef_74" title="View footnote.">74</a>]</sup>）はRAMに配置しなければならない。
すなわちRV16Kでは<strong>考慮するべきアドレス空間が2つある</strong>。しかしELFはこのような構造に
対応しておらず<sup class="footnote">[<a id="_footnoteref_75" class="footnote" href="#_footnotedef_75" title="View footnote.">75</a>]</sup>一つの32bit仮想
アドレス空間<sup class="footnote">[<a id="_footnoteref_76" class="footnote" href="#_footnotedef_76" title="View footnote.">76</a>]</sup>
を持つのみである。
そこでRV16KではELFにおける仮想アドレス空間のうち <code>0x00000000</code> から <code>0x0000FFFF</code> を
ROMの領域（すなわち <code>.text</code> の領域）とし<sup class="footnote">[<a id="_footnoteref_77" class="footnote" href="#_footnotedef_77" title="View footnote.">77</a>]</sup>、
<code>0x00010000</code> から <code>0x0001FFFF</code> をRAMの領域とする。
これにより後々ELFからROM/RAM用のバイナリを切り出すことが容易となる<sup class="footnote">[<a id="_footnoteref_78" class="footnote" href="#_footnotedef_78" title="View footnote.">78</a>]</sup>。</p>
</div>
<div class="paragraph">
<p>問題は、このようなアドレス配置でリンカのrelocationが正しく動作するかである。
まずPC相対のrelocationを考えよう。例えば <code>jal</code> 命令はリンク時に関数へのPC相対アドレスを
計算し当該箇所に埋め込む必要がある。指し示す関数と <code>jal</code> 命令は両者ともにROM上・ <code>.text</code> 上にある。
ここで、仮想アドレスにおいて0番地から始まる <code>.text</code> のデータはそのままROMの0番地から
配置される<sup class="footnote">[<a id="_footnoteref_79" class="footnote" href="#_footnotedef_79" title="View footnote.">79</a>]</sup>ため、
<code>.text</code> 中でのPC相対アドレスとROM上でのPC相対アドレスは一致する。
したがって問題ない。</p>
</div>
<div class="paragraph">
<p>次に絶対値によるrelocationを考える。例えばグローバル変数 <code>hoge</code> を <code>lw</code> 命令を用いて読み込む
場合、 <code>hoge</code> のアドレスはRAM上の絶対アドレスによって指定される。
ここで <code>hoge</code> は <code>0x0001xxxx</code> のようなアドレスをリンカによって
指定される<sup class="footnote">[<a id="_footnoteref_80" class="footnote" href="#_footnotedef_80" title="View footnote.">80</a>]</sup>。
これは正しいROM上の絶対アドレスではない<sup class="footnote">[<a id="_footnoteref_81" class="footnote" href="#_footnotedef_81" title="View footnote.">81</a>]</sup>。
そこで下位16bitのみを有効なアドレスとみなし、この値をELFファイルに書き込む。</p>
</div>
<div class="paragraph">
<p>以上から、ROMとRAMの両方にvalidなアドレスをリンカの再配置機構を使用して
得られることが分かった。</p>
</div>
</div>
<div class="sect2">
<h3 id="_lldにrv16kターゲットを追加する">LLDにRV16Kターゲットを追加する</h3>
<div class="paragraph">
<p><code>lld/ELF/Arch/RV16K.cpp</code> ファイルを追加し <code>getRV16KTargetInfo</code> 関数を
追加する。これはこのファイル中で定義する <code>RV16K</code> クラスのインスタンスを返す。
<code>RV16K</code> クラスは <code>TargetInfo</code> クラスを継承し <code>relocateOne</code> と <code>getRelExpr</code> 関数を
オーバーライドする。
<code>relocateOne</code> は再配置処理の本体で、再配置のタイプ（ <code>R_RV16K_16</code> など）
に応じて値の書き込みを行う。
このときに書き込む値はLLD側から与えられる。その値の種類（絶対値かPC相対かなど）を
指定するために <code>RV16K::getRelExpr</code> を記述する<sup class="footnote">[<a id="_footnoteref_82" class="footnote" href="#_footnotedef_82" title="View footnote.">82</a>]</sup>。</p>
</div>
<div class="paragraph">
<p>RV16Kが使用する再配置の種類は既存のものばかりで、それほど困難ではない。
逆に独自の再配置タイプを作成する場合はRISC Vの対応<a href="#llvm_phabricator-d39322">[97]</a>が
参考になりそうだ。</p>
</div>
<div class="paragraph">
<p>さてELFの再配置情報には <code>.rel</code> と <code>.rela</code> の2種類の形式があり、
どちらを利用するかはABIによって決まっている。LLDでは <code>Driver.cpp</code> において
次のようにハードコーディングされている。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>// ELF defines two different ways to store relocation addends as shown below:
//
//  Rel:  Addends are stored to the location where relocations are applied.
//  Rela: Addends are stored as part of relocation entry.
//
// In other words, Rela makes it easy to read addends at the price of extra
// 4 or 8 byte for each relocation entry. We don't know why ELF defined two
// different mechanisms in the first place, but this is how the spec is
// defined.
//
// You cannot choose which one, Rel or Rela, you want to use. Instead each
// ABI defines which one you need to use. The following expression expresses
// that.
Config-&gt;IsRela = M == EM_AARCH64 || M == EM_AMDGPU || M == EM_HEXAGON ||
                 M == EM_PPC || M == EM_PPC64 || M == EM_RISCV ||
                 M == EM_X86_64;</pre>
</div>
</div>
<div class="paragraph">
<p>LLVMバックエンド のレベルでは <code>.rel</code> と <code>.rela</code> のいずれを使用するかは
<code>MCELFObjectTargetWriter</code> の第四引数に <code>false/true</code> のいずれを
渡すかに対応している。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>RV16KELFObjectWriter::RV16KELFObjectWriter(uint8_t OSABI)
    : MCELFObjectTargetWriter(false, OSABI, ELF::EM_RV16K,
                              /*HasRelocationAddend*/ true) {}</pre>
</div>
</div>
<div class="paragraph">
<p>RV16Kv2では <code>.rela</code> を使用する<sup class="footnote">[<a id="_footnoteref_83" class="footnote" href="#_footnotedef_83" title="View footnote.">83</a>]</sup>ので <code>true</code> と
なっている。したがってLLDの当該箇所も更新する必要がある。</p>
</div>
<div class="paragraph">
<p>その他RV16Kを認識させるために <code>Driver.cpp</code> と <code>Target.cpp</code> を修正する。</p>
</div>
<div class="paragraph">
<p>コンパイルのために <code>cmake -DLLVM_ENABLE_PROJECTS="lld;clang"</code> として
再コンパイルしようとするとうまくいかない。途中のproject追加は対応していないようだ？
<sup class="footnote">[<a id="_footnoteref_84" class="footnote" href="#_footnotedef_84" title="View footnote.">84</a>]</sup>とりあえずスクラッチから
lldを含めたビルドを行う。</p>
</div>
<div class="paragraph">
<p>具体的に実行可能ファイルを作成するために
エントリポイント <code>_start</code> をアセンブリで作成し <code>runtime.s</code> という
名前で保存する。中身は次のように <code>main</code> を呼出した後 <code>hlt</code>
する<sup class="footnote">[<a id="_footnoteref_85" class="footnote" href="#_footnotedef_85" title="View footnote.">85</a>]</sup>。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>.global _start
_start:
	jal main
	hlt</pre>
</div>
</div>
<div class="paragraph">
<p>これをコンパイルしてオブジェクトファイル <code>runtime.o</code> とし、
<code>main</code> 関数を含む適当なオブジェクトファイル <code>foo.o</code> と次のようにリンクする。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ bin/ld.lld -Ttext=0 runtime.o foo.o -o foo.exe</pre>
</div>
</div>
<div class="paragraph">
<p>LLDのAVRのターゲットのコメントに書かれているように、
<code>-Ttext=0</code> を指定することで <code>.text</code> セクションをアドレス <code>0x0</code> に
配置することができる。これは <code>llvm-readobj</code> を利用して確かめられる。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ bin/llvm-readobj -a foo.exe | pbcopy

File: foo.exe
Format: ELF32-rv16k
Arch: rv16k
AddressSize: 32bit
LoadName:
ElfHeader {
  Ident {
    Magic: (7F 45 4C 46)
    Class: 32-bit (0x1)
    DataEncoding: LittleEndian (0x1)
    FileVersion: 1
    OS/ABI: SystemV (0x0)
    ABIVersion: 0
    Unused: (00 00 00 00 00 00 00)
  }
  Type: Executable (0x2)
  Machine: EM_RV16K (0xF6)
  Version: 1
  Entry: 0x0
  ProgramHeaderOffset: 0x34
  SectionHeaderOffset: 0x20A8
  Flags [ (0x0)
  ]
  HeaderSize: 52
  ProgramHeaderEntrySize: 32
  ProgramHeaderCount: 2
  SectionHeaderEntrySize: 40
  SectionHeaderCount: 6
  StringTableSectionIndex: 4
}
（以下略）</pre>
</div>
</div>
<div class="paragraph">
<p>テストを追加する。 <code>lld/test/ELF/basic-rv16k.s</code> というファイルを作り記述する。
Sparcのものなどが参考になる。LLDのテストをする際には <code>ninja check-lld</code> とすればよいが、
こうすると全てのテストが走ってしまう。RV16Kに限って実行するには
次のようにすればよい。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ bin/llvm-lit -as --filter 'rv16k' tools/lld/test</pre>
</div>
</div>
<div class="paragraph">
<p>しかしコマンドを手で入力した結果と <code>llvm-lit</code> での実行結果が異なる。
<code>tee</code> で内容を取得しテストの正解とした。
原因不明。 <code>.comment</code> のサイズが異なるようだ？ TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_clang_で実行可能ファイルを出力する"><code>clang</code> で実行可能ファイルを出力する</h3>
<div class="paragraph">
<p>必要な場合に <code>clang</code> が適切に <code>lld</code> を呼ぶようにする。
<code>RV16KToolChain</code> の <code>protected</code> メンバ関数として <code>buildLinker</code> を
オーバーライドし <code>tools::RV16K::Linker</code> クラスのインスタンスを
返却する。次いで <code>tools::RV16K::Linker</code> を <code>GnuTool</code> を継承するクラスとして
定義し、 <code>GnuTool</code> のコンストラクタに <code>ld.lld</code> を渡す<sup class="footnote">[<a id="_footnoteref_86" class="footnote" href="#_footnotedef_86" title="View footnote.">86</a>]</sup>。
<code>tools::RV16K::Linker::ConstructJob</code> ではリンカへのオプションなどを指定できる。
<code>.text</code> セクションをアドレス <code>0x00000000</code> 番地に割り当てるように <code>-Ttext=0</code> を、
<code>.data</code> セクションをアドレス <code>0x00010000</code> 番地に割り当てるように <code>-Tdata=0</code> を、
またページサイズ単位のセクションアラインメントを無効化するために <code>--omagic</code>
<sup class="footnote">[<a id="_footnoteref_87" class="footnote" href="#_footnotedef_87" title="View footnote.">87</a>]</sup>を指定する
<sup class="footnote">[<a id="_footnoteref_88" class="footnote" href="#_footnotedef_88" title="View footnote.">88</a>]</sup>。</p>
</div>
<div class="paragraph">
<p>以上の設定により次のように実行ファイルが生成されるようになった<sup class="footnote">[<a id="_footnoteref_89" class="footnote" href="#_footnotedef_89" title="View footnote.">89</a>]</sup>。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cat runtime.s
.global _start
_start:
	jal main
	hlt

$ cat foo.c
int main()
{
    return 42;
}

$ bin/clang -target rv16k runtime.s foo.c -o foo.exe

$ bin/llvm-readelf -a foo.exe
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0x0
  Type:                              EXEC (Executable file)
  Machine:                           RV16K
  Version:                           0x1
  Entry point address:               0x0
  Start of program headers:          52 (bytes into file)
  Start of section headers:          8360 (bytes into file)
  Flags:                             0x0
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         2
  Size of section headers:           40 (bytes)
  Number of section headers:         6
  Section header string table index: 4
There are 6 section headers, starting at offset 0x20a8:

Section Headers:
  [Nr] Name              Type            Address  Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .text             PROGBITS        00000000 001000 000026 00  AX  0   0  4
  [ 2] .comment          PROGBITS        00000000 002000 000028 01  MS  0   0  1
  [ 3] .symtab           SYMTAB          00000000 002028 000040 10      5   2  4
  [ 4] .shstrtab         STRTAB          00000000 002068 00002a 00      0   0  1
  [ 5] .strtab           STRTAB          00000000 002092 000013 00      0   0  1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)

There are no relocations in this file.

Symbol table '.symtab' contains 4 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 00000000     0 FILE    LOCAL  DEFAULT  ABS foo.c
     2: 00000000     0 NOTYPE  GLOBAL DEFAULT    1 _start
     3: 00000008    30 FUNC    GLOBAL DEFAULT    1 main
UnwindInfo not implemented.

Elf file type is EXEC (Executable file)
Entry point 0x0
There are 2 program headers, starting at offset 52

Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  LOAD           0x001000 0x00000000 0x00000000 0x01000 0x01000 R E 0x1000
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x0

 Section to Segment mapping:
  Segment Sections...
   00     .text
   01
Version symbols {
}
SHT_GNU_verdef {
}
SHT_GNU_verneed {
}
There are no section groups in this file.

$ ~/workspace/rv16k-sim/main foo.exe 20
0000 0073
0002 0600
0004 0052
0006 FEFF
0008 C1F2
000A 2192
000C 0200
000E 12E0
0010 42F2
0012 0878
0014 0000
0016 8292
0018 FCFF
001A 0878
001C 2A00
001E 12B2
0020 0200
0022 41F2
0024 0040

Inst:JAL PC &lt;= 0x0002 Reg x0 &lt;= 0x0004 PC &lt;= 0x0008 FLAGS(SZCV) &lt;= 0000
Inst:ADDI Reg x1 &lt;= 0x01FA PC &lt;= 0x000A FLAGS(SZCV) &lt;= 0000
Inst:SW PC &lt;= 0x000C DataRam[0x01FC] &lt;= 0x0000 DataRam[0x01FD] &lt;= 0x0000 PC &lt;= 0x000E FLAGS(SZCV) &lt;= 0010
Inst:MOV Reg x2 &lt;= 0x01FA PC &lt;= 0x0010 FLAGS(SZCV) &lt;= 0000
Inst:ADDI Reg x2 &lt;= 0x01FE PC &lt;= 0x0012 FLAGS(SZCV) &lt;= 0010
Inst:LI PC &lt;= 0x0014 Reg x8 &lt;= 0x0000 PC &lt;= 0x0016 FLAGS(SZCV) &lt;= 0100
Inst:SW PC &lt;= 0x0018 DataRam[0x01FA] &lt;= 0x0000 DataRam[0x01FB] &lt;= 0x0000 PC &lt;= 0x001A FLAGS(SZCV) &lt;= 0000
Inst:LI PC &lt;= 0x001C Reg x8 &lt;= 0x002A PC &lt;= 0x001E FLAGS(SZCV) &lt;= 0000
PC &lt;= 0x0020 Inst:LW Reg x2 &lt;= 0x0000 PC &lt;= 0x0022 FLAGS(SZCV) &lt;= 0010
Inst:ADDI Reg x1 &lt;= 0x01FE PC &lt;= 0x0024 FLAGS(SZCV) &lt;= 0010
Inst:JR PC &lt;= 0x0004 FLAGS(SZCV) &lt;= 0000
Inst:J PC &lt;= 0x0006 PC &lt;= 0x0004 FLAGS(SZCV) &lt;= 0000
Inst:J PC &lt;= 0x0006 PC &lt;= 0x0004 FLAGS(SZCV) &lt;= 0000
Inst:J PC &lt;= 0x0006 PC &lt;= 0x0004 FLAGS(SZCV) &lt;= 0000
Inst:J PC &lt;= 0x0006 PC &lt;= 0x0004 FLAGS(SZCV) &lt;= 0000
Inst:J PC &lt;= 0x0006 PC &lt;= 0x0004 FLAGS(SZCV) &lt;= 0000
Inst:J PC &lt;= 0x0006 PC &lt;= 0x0004 FLAGS(SZCV) &lt;= 0000
Inst:J PC &lt;= 0x0006 PC &lt;= 0x0004 FLAGS(SZCV) &lt;= 0000
Inst:J PC &lt;= 0x0006 PC &lt;= 0x0004 FLAGS(SZCV) &lt;= 0000
Inst:J PC &lt;= 0x0006 PC &lt;= 0x0004 FLAGS(SZCV) &lt;= 0000
x0=4	x1=510	x2=0	x3=0	x4=0	x5=0	x6=0	x7=0	x8=42	x9=0	x10=0	x11=0	x12=0	x13=0	x14=0	x15=0</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lwsw_の代わりに_lwspswsp_命令を使う"><code>lw/sw</code> の代わりに <code>lwsp/swsp</code> 命令を使う</h2>
<div class="sectionbody">
<div class="paragraph">
<p>現在 <code>lw/sw</code> を用いて行っているスタックの読み書きを、適用できる場合に限って <code>lwsp/swsp</code> に変更する。
結局スタックにアクセスする際には <code>eliminateFrameIndex</code> が呼ばれるため、
ここでi) <code>lw/sw</code> を使用しており ii) オペランドが <code>sp</code> で、かつ iii)
即値が9bitに収まるのであれば、これを <code>lwsp/swsp</code> に各々変換する。</p>
</div>
<div class="paragraph">
<p><code>eliminateFrameIndex</code> で命令の変更を行うバックエンドは少ないが、<sup class="footnote">[<a id="_footnoteref_90" class="footnote" href="#_footnotedef_90" title="View footnote.">90</a>]</sup>。
例えばSparcでは行われている。それによれば <code>MI.setDesc</code> を使用して
命令の変更を行えば良いようだ。</p>
</div>
<div class="paragraph">
<p>似たような変更はRISC VのRV32C対応でも行われている。ただしこちらの手法はより大胆で、
TableGen本体に手をいれることで、TableGenファイルにおいて
RV32Iその他の命令とRV32Cとの対応を取れるようにしている。</p>
</div>
<div class="paragraph">
<p>結局RV16Kでは次のようになった。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>  // Use lwsp whenever possible.
  if (MI.getOpcode() == RV16K::LW &amp;&amp; FrameReg == RV16K::X1 &amp;&amp;
      isShiftedUInt&lt;8, 1&gt;(Offset)) {
    const TargetInstrInfo &amp;TII = *MF.getSubtarget().getInstrInfo();
    MI.setDesc(TII.get(RV16K::LWSP));
  }

  // Use swsp whenever possible.
  if (MI.getOpcode() == RV16K::SW &amp;&amp; FrameReg == RV16K::X1 &amp;&amp;
      isShiftedUInt&lt;8, 1&gt;(Offset)) {
    const TargetInstrInfo &amp;TII = *MF.getSubtarget().getInstrInfo();
    MI.setDesc(TII.get(RV16K::SWSP));
  }</pre>
</div>
</div>
<div class="paragraph">
<p>ちなみにここで <code>isShiftedUInt&lt;9, 1&gt;</code> などとしてもエラーにはならない。
命令選択はすでに終わっており<sup class="footnote">[<a id="_footnoteref_91" class="footnote" href="#_footnotedef_91" title="View footnote.">91</a>]</sup>、
オペランドの幅を指定するのは命令選択に使用されるTableGenファイルを除いて
他にないからである。従ってそのまま <code>lwsp a0, 512(sp)</code> などと平気で
出力される。ではオブジェクトファイルはどうかというと、
こちらでもエラーは出力されず、逆アセンブルすると <code>lwsp a0, 0(sp)</code> と
なっていることが分かる。これはTableGenファイル中の <code>Inst</code> の指定が
bitの対応のみになっていることに起因するのだろう。
これに対して有効な手立てがあるかはちょっと分からない。TODO
<sup class="footnote">[<a id="_footnoteref_92" class="footnote" href="#_footnotedef_92" title="View footnote.">92</a>]</sup>
仕方がないので、とりあえずテストで正しい挙動となることを保証することに
する<sup class="footnote">[<a id="_footnoteref_93" class="footnote" href="#_footnotedef_93" title="View footnote.">93</a>]</sup>。</p>
</div>
<div class="paragraph">
<p>ところがこれでは関数の引数をスタックに積む際には適用されないことが分かった。
この場合は <code>DAG.getStore</code> を利用してSelectionDAGレベルでspに対するstoreが
発行され、frame indexはそのオペランド中に含まれないためと推察される（TODO）。
そこで次のようにパターンを追加した。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>def : Pat&lt;(store GPR:$rs2, SP:$rs1), (SWSP GPR:$rs2, SP:$rs1, 0)&gt;;
def : Pat&lt;(store GPR:$rs2, (add SP:$rs1, uimm9_lsb0:$imm)),
          (SWSP GPR:$rs2, SP:$rs1, uimm9_lsb0:$imm)&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>これを普通の <code>store</code> の上に置くと失敗するテストが発生した（ <code>blockaddress.ll</code> ）。
詳細不明。TODO <code>-debug</code> を付けて確認すると <code>SP</code> のレジスタが足りなくなっているような
雰囲気？ <code>sp</code> をスタックにスピルしてロードして……みたいなことをやっている気がする。
どうも <code>a0</code> を直接 <code>lw</code> で読む代わりに、
<code>a0</code> を <code>sp</code> に入れて <code>swsp</code> を実行するようなアセンブリが吐かれている。恐ろしや。
しかしこれは命令数的に不利だと思うのだが……。</p>
</div>
<div class="paragraph">
<p>しかしこの手法では、新たにload/storeを挟むたびにlwsp/swspのことを
考える必要があり、少々面倒である。lwsp/swspは条件が揃えば必ずlw/swに
書き換わるべき命令なのだから、もっと後ろ、すなわち
frame index eliminationが終わったあとにpeephole最適化<sup class="footnote">[<a id="_footnoteref_94" class="footnote" href="#_footnotedef_94" title="View footnote.">94</a>]</sup>にて処理すべきである。このような場合に対応するためにLLVMバックエンドには
"Late Machine Code Optimizations"がある<a href="#llvm-code_generator">[31]</a>が、
公式ドキュメントには"To Be Written"となっていて情報がない。</p>
</div>
<div class="paragraph">
<p>おそらくこれは <code>MachineFunctionPass</code> を継承したような最適化に対応すると
推察される（TODO）。これは <code>Target/RV16K</code> 内にて定義し、
<code>RV16KPassConfig</code> にて <code>addPreEmitPass2</code> などをオーバライドしたうえで
<code>addPass</code> を呼出し利用する<a href="#llvm_phabricator-d47882">[109]</a>。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>  /// Methods with trivial inline returns are convenient points in the common
  /// codegen pass pipeline where targets may insert passes. Methods with
  /// out-of-line standard implementations are major CodeGen stages called by
  /// addMachinePasses. Some targets may override major stages when inserting
  /// passes is insufficient, but maintaining overriden stages is more work.
  ///

  /// addPreISelPasses - This method should add any "last minute" LLVM-&gt;LLVM
  /// passes (which are run just before instruction selector).
  virtual bool addPreISel() {
    return true;
  }

  /// addMachineSSAOptimization - Add standard passes that optimize machine
  /// instructions in SSA form.
  virtual void addMachineSSAOptimization();

  /// Add passes that optimize instruction level parallelism for out-of-order
  /// targets. These passes are run while the machine code is still in SSA
  /// form, so they can use MachineTraceMetrics to control their heuristics.
  ///
  /// All passes added here should preserve the MachineDominatorTree,
  /// MachineLoopInfo, and MachineTraceMetrics analyses.
  virtual bool addILPOpts() {
    return false;
  }

  /// This method may be implemented by targets that want to run passes
  /// immediately before register allocation.
  virtual void addPreRegAlloc() { }

  /// createTargetRegisterAllocator - Create the register allocator pass for
  /// this target at the current optimization level.
  virtual FunctionPass *createTargetRegisterAllocator(bool Optimized);

  /// addFastRegAlloc - Add the minimum set of target-independent passes that
  /// are required for fast register allocation.
  virtual void addFastRegAlloc(FunctionPass *RegAllocPass);

  /// addOptimizedRegAlloc - Add passes related to register allocation.
  /// LLVMTargetMachine provides standard regalloc passes for most targets.
  virtual void addOptimizedRegAlloc(FunctionPass *RegAllocPass);

  /// addPreRewrite - Add passes to the optimized register allocation pipeline
  /// after register allocation is complete, but before virtual registers are
  /// rewritten to physical registers.
  ///
  /// These passes must preserve VirtRegMap and LiveIntervals, and when running
  /// after RABasic or RAGreedy, they should take advantage of LiveRegMatrix.
  /// When these passes run, VirtRegMap contains legal physreg assignments for
  /// all virtual registers.
  virtual bool addPreRewrite() {
    return false;
  }

  /// This method may be implemented by targets that want to run passes after
  /// register allocation pass pipeline but before prolog-epilog insertion.
  virtual void addPostRegAlloc() { }

  /// Add passes that optimize machine instructions after register allocation.
  virtual void addMachineLateOptimization();

  /// This method may be implemented by targets that want to run passes after
  /// prolog-epilog insertion and before the second instruction scheduling pass.
  virtual void addPreSched2() { }

  /// addGCPasses - Add late codegen passes that analyze code for garbage
  /// collection. This should return true if GC info should be printed after
  /// these passes.
  virtual bool addGCPasses();

  /// Add standard basic block placement passes.
  virtual void addBlockPlacement();

  /// This pass may be implemented by targets that want to run passes
  /// immediately before machine code is emitted.
  virtual void addPreEmitPass() { }

  /// Targets may add passes immediately before machine code is emitted in this
  /// callback. This is called even later than `addPreEmitPass`.
  // FIXME: Rename `addPreEmitPass` to something more sensible given its actual
  // position and remove the `2` suffix here as this callback is what
  // `addPreEmitPass` *should* be but in reality isn't.
  virtual void addPreEmitPass2() {}</pre>
</div>
</div>
<div class="paragraph">
<p><code>RV16KUseLWSPSWSP</code> という名前で実際にパスを作る。 <code>RISCVMergeBaseOffset</code> が
参考になる。 <code>MachineFunction</code> の中に <code>MachineBasicBlock</code> があり、
その中に <code>MachineInstr</code> がある。iteratorが実装されているためrange-based forが
使える。 <code>INITIALIZE_PASS</code> の第二引数はコマンドラインでの引数。第三引数は名前。</p>
</div>
<div class="paragraph">
<p>その後 <code>RV16KPassConfig::addPreEmitPass</code> から <code>addPass</code> を呼ぶようにした。
正直どれから呼べばどの順序で呼ばれるのかよくわからないが、
<code>addPreEmitPass</code> と <code>addPreEmitPass2</code> が <code>MCInst</code> にlowerされる直前に
相次いで呼ばれるという認識。要調査；TODO</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/gemba_neko.jpg" alt="gemba neko">
</div>
</div>
<div class="paragraph">
<p>テストを追加する。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_続_frameindex_をlowerする">続・ <code>FrameIndex</code> をlowerする</h2>
<div class="sectionbody">
<div class="paragraph">
<p>バグを泳がせた結果、<code>alloca</code> で確保したスタック領域へのポインタを
関数の引数に渡すようなLLVM IRを入力すると <code>RV16KDAGToDAGISel::Select</code> に
<code>ISD::FrameIndex</code> が来ることが分かった。なるほど然り。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>declare i16 @bar(i16*)

define i16 @foo() {
  %1 = alloca i16
  %2 = call i16 @bar(i16* %1)
  ret i16 %2
}</pre>
</div>
</div>
<div class="paragraph">
<p>これに対応する。オペランドにframe indexが現れた際は <code>TargetFrameIndex</code> に
変換しつつそのままオペランドとして扱った。しかし今回はframe indexが
単体で与えられているため、そのままでは <code>MachineDAG</code> のノードとして
扱えない<sup class="footnote">[<a id="_footnoteref_95" class="footnote" href="#_footnotedef_95" title="View footnote.">95</a>]</sup>。
そこで適当な命令とセットにして <code>Select</code> の
結果とする必要がある。ここでframe indexの実体は「レジスタ＋即値」である
ことに注意する。すなわち <code>eliminateFrameIndex</code> で扱うことができるような
形式でなければならない。RISC-Vでは <code>addi</code> がこれに該当するが、
RV16Kではビット幅が狭く現実的ではない。そこで、とりあえず <code>Select</code> では
<code>addi</code> を割り振り、後から <code>eliminateFrameIndex</code> で調整する手法を採用する。
そこで<a href="#github_riscv-llvm_patch_22">[91]</a>を参考にし
次のようにコードを書いた。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>  if (Node-&gt;getOpcode() == ISD::FrameIndex) {
    SDLoc DL(Node);
    SDValue Imm = CurDAG-&gt;getTargetConstant(0, DL, MVT::i16);
    int FI = dyn_cast&lt;FrameIndexSDNode&gt;(Node)-&gt;getIndex();
    EVT VT = Node-&gt;getValueType(0);
    SDValue TFI = CurDAG-&gt;getTargetFrameIndex(FI, VT);
    ReplaceNode(Node,
                CurDAG-&gt;getMachineNode(RV16K::ADDI, DL, VT, TFI, Imm));
    return;
  }</pre>
</div>
</div>
<div class="paragraph">
<p>するとエラーが出た。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ ~/workspace/llvm-project-build/bin/llc -mtriple=rv16k -verify-machineinstrs &lt; 0003.ll
	.text
	.file	"&lt;stdin&gt;"

# After Instruction Selection
# Machine code for function foo: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=2, align=2, at location [SP]

bb.0 (%ir-block.0):
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x1, implicit $x1
  %0:gpr = ADDI %stack.0, 0, implicit-def dead $flags
  $x8 = COPY %0:gpr
  JAL @bar, &lt;regmask $x0 $x2 $x3 $x4 $x5 $x6 $x7&gt;, implicit-def dead $x0, implicit $x8, implicit-def $x1, implicit-def $x8
  ADJCALLSTACKUP 0, 0, implicit-def dead $x1, implicit $x1
  %1:gpr = COPY $x8
  $x8 = COPY %1:gpr
  PseudoRET implicit $x8

# End machine code for function foo.

*** Bad machine code: Tied use must be a register ***
- function:    foo
- basic block: %bb.0  (0x5647e963da08)
- instruction: %0:gpr = ADDI %stack.0, 0, implicit-def dead $flags
- operand 1:   %stack.0
LLVM ERROR: Found 1 machine code errors.</pre>
</div>
</div>
<div class="paragraph">
<p>どうやら <code>ADDI</code> の2オペランド制約（ <code>Constraints = "$rd = $rd_w"</code> ）
を満たすことが出来ないようだ<sup class="footnote">[<a id="_footnoteref_96" class="footnote" href="#_footnotedef_96" title="View footnote.">96</a>]</sup>。
そこで同様の問題を抱えるAVRのバックエンドを参考にして <code>FRMIDX</code> という擬似命令を作成し、
これを <code>addi</code> の代わりに取り回すことにする。</p>
</div>
<div class="paragraph">
<p>まず次のように <code>FRMIDX</code> を定義し</p>
</div>
<div class="literalblock">
<div class="content">
<pre>let hasSideEffects = 0, mayLoad = 0, mayStore = 0, Defs = [FLAGS] in
def FRMIDX : Pseudo&lt;(outs GPR:$rd), (ins GPR:$rs, simm16:$imm), []&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>これを <code>Select</code> で作成する。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>  if (Node-&gt;getOpcode() == ISD::FrameIndex) {
    // Convert the frameindex into a temp instruction that will hold the
    // effective address of the final stack slot.
    int FI = cast&lt;FrameIndexSDNode&gt;(Node)-&gt;getIndex();
    SDValue TFI = CurDAG-&gt;getTargetFrameIndex(FI, MVT::i16);

    CurDAG-&gt;SelectNodeTo(Node, RV16K::FRMIDX, MVT::i16, TFI,
                         CurDAG-&gt;getTargetConstant(0, SDLoc(Node), MVT::i16));
    return;
  }</pre>
</div>
</div>
<div class="paragraph">
<p>なお <code>Pat</code> で <code>FRMIDX</code> を作成できないかとやってみたが上手く行かなかった。
そもそもどのようなパターンにマッチさせればいいのか分からなかった。TODO</p>
</div>
<div class="paragraph">
<p>ちなみにこの段階でアセンブリを出力させると空文字列で出力される。
それはそうなのだが、擬似命令でもエラーが出ず出力されるのは意外<sup class="footnote">[<a id="_footnoteref_97" class="footnote" href="#_footnotedef_97" title="View footnote.">97</a>]</sup>。</p>
</div>
<div class="paragraph">
<p>最後に <code>eliminateFrameIndex</code> で <code>FRMIDX</code> をトラップし、適切に処理する。
4bit幅に収まる場合には <code>addi</code> が使えると思ったが、
実際には <code>sp</code> を書き換えるのはまずいと判断し、
どのような場合でも <code>li</code> と <code>mov</code> で取り扱うことにした。要検討。TODO</p>
</div>
<div class="paragraph">
<p>AVRでは二命令目の最後のオペランドに <code>RegState::Dead</code> が適用されていた。
この <code>RegState</code> の意味は <code>MachineOperand</code> クラスのコメントに詳しい。</p>
</div>
<div class="paragraph">
<p>TableGenを使用した通常のパスでこれらの属性がどのように付与されるかは要調査；TODO</p>
</div>
<div class="literalblock">
<div class="content">
<pre>  /// TiedTo - Non-zero when this register operand is tied to another register
  /// operand. The encoding of this field is described in the block comment
  /// before MachineInstr::tieOperands().
  unsigned TiedTo : 4;

  /// IsDef - True if this is a def, false if this is a use of the register.
  /// This is only valid on register operands.
  ///
  unsigned IsDef : 1;

  /// IsImp - True if this is an implicit def or use, false if it is explicit.
  /// This is only valid on register opderands.
  ///
  unsigned IsImp : 1;

  /// IsDeadOrKill
  /// For uses: IsKill - True if this instruction is the last use of the
  /// register on this path through the function.
  /// For defs: IsDead - True if this register is never used by a subsequent
  /// instruction.
  /// This is only valid on register operands.
  unsigned IsDeadOrKill : 1;

  /// See isRenamable().
  unsigned IsRenamable : 1;

  /// IsUndef - True if this register operand reads an "undef" value, i.e. the
  /// read value doesn't matter.  This flag can be set on both use and def
  /// operands.  On a sub-register def operand, it refers to the part of the
  /// register that isn't written.  On a full-register def operand, it is a
  /// noop.  See readsReg().
  ///
  /// This is only valid on registers.
  ///
  /// Note that an instruction may have multiple &lt;undef&gt; operands referring to
  /// the same register.  In that case, the instruction may depend on those
  /// operands reading the same dont-care value.  For example:
  ///
  ///   %1 = XOR undef %2, undef %2
  ///
  /// Any register can be used for %2, and its value doesn't matter, but
  /// the two operands must be the same register.
  ///
  unsigned IsUndef : 1;

  /// IsInternalRead - True if this operand reads a value that was defined
  /// inside the same instruction or bundle.  This flag can be set on both use
  /// and def operands.  On a sub-register def operand, it refers to the part
  /// of the register that isn't written.  On a full-register def operand, it
  /// is a noop.
  ///
  /// When this flag is set, the instruction bundle must contain at least one
  /// other def of the register.  If multiple instructions in the bundle define
  /// the register, the meaning is target-defined.
  unsigned IsInternalRead : 1;

  /// IsEarlyClobber - True if this MO_Register 'def' operand is written to
  /// by the MachineInstr before all input registers are read.  This is used to
  /// model the GCC inline asm '&amp;' constraint modifier.
  unsigned IsEarlyClobber : 1;

  /// IsDebug - True if this MO_Register 'use' operand is in a debug pseudo,
  /// not a real instruction.  Such uses should be ignored during codegen.
  unsigned IsDebug : 1;</pre>
</div>
</div>
<div class="paragraph">
<p><code>Kill</code> はレジスタのuseのとき、 <code>Dead</code> はdefのとき用いられる。
<code>Kill/Dead</code> のフラグがたったレジスタは、その後使用されないことを意味する。
今回の場合 <code>FLAGS</code> がこの後で使用されることはない<sup class="footnote">[<a id="_footnoteref_98" class="footnote" href="#_footnotedef_98" title="View footnote.">98</a>]</sup>ので <code>FLAGS</code> に <code>Dead</code> を適用する必要がある。</p>
</div>
<div class="paragraph">
<p>なおbasic blockを前からではなく後ろから走査することで <code>Kill</code> フラグの有無に関わらず
正しいレジスタ生存期間を算出できる<sup class="footnote">[<a id="_footnoteref_99" class="footnote" href="#_footnotedef_99" title="View footnote.">99</a>]</sup>。したがって <code>Kill</code> フラグをつけるか否かは任意であり、
誤って <code>Kill</code> フラグが立つことによるバグの混入
<sup class="footnote">[<a id="_footnoteref_100" class="footnote" href="#_footnotedef_100" title="View footnote.">100</a>]</sup>
を避けるためにも、新しく書くコードでは <code>Kill</code>
を使用すべきでないらしい<a href="#llvm-welcome_to_the_back_end_2017">[46]</a><sup class="footnote">[<a id="_footnoteref_101" class="footnote" href="#_footnotedef_101" title="View footnote.">101</a>]</sup>。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cat 0003.ll
declare i16 @bar(i16*)

define i16 @foo() {
  %1 = alloca i16
  %2 = call i16 @bar(i16* %1)
  ret i16 %2
}

$ ~/workspace/llvm-project-build/bin/llc -mtriple=rv16k -verify-machineinstrs -print-after=prologepilog &lt; 0003.ll &gt; /dev/null
# *** IR Dump After Prologue/Epilogue Insertion &amp; Frame Finalization ***:
# Machine code for function foo: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=2, align=2, at location [SP-4]
  fi#1: size=2, align=2, at location [SP-2]

bb.0 (%ir-block.0):
  $x1 = frame-setup ADDI $x1(tied-def 0), -4, implicit-def $flags
  SW killed $x0, $x1, 2, implicit-def $flags
  $x8 = LI 0, implicit-def dead $flags
  $x8 = ADD killed $x8(tied-def 0), $x1, implicit-def dead $flags
  JAL @bar, &lt;regmask $x0 $x2 $x3 $x4 $x5 $x6 $x7&gt;, implicit-def dead $x0, implicit $x8, implicit-def $x1, implicit-def $x8
  $x0 = LW $x1, 2, implicit-def $flags
  $x1 = frame-destroy ADDI $x1(tied-def 0), 4, implicit-def $flags
  PseudoRET implicit $x8

# End machine code for function foo.</pre>
</div>
</div>
<div class="paragraph">
<p><code>ADD</code> に <code>dead</code> がついていることが分かる。
なお <code>implicit</code> というのはアセンブリ中（ <code>MCInst</code> 中）に表現されないということである。
実際 <code>flags</code> は各命令において勝手に書き換えられ、勝手に使用されるため、
明示的に表現することはない。また <code>tied</code> というのは2オペランド形式などにおいて
読み込むレジスタと書き込むレジスタが
一致することを意味している<a href="#llvm-welcome_to_the_back_end_2017">[46]</a>。
上のコードにはないが <code>undef</code> はその入力レジスタの値自体は重要でないこと<sup class="footnote">[<a id="_footnoteref_102" class="footnote" href="#_footnotedef_102" title="View footnote.">102</a>]</sup>を意味する。
これらの <code>RegState</code> はレジスタの生存期間を算出するために用いられる。</p>
</div>
<div class="paragraph">
<p><code>Offset</code> が <code>0</code> のときは <code>mov</code> のみでよいので条件分岐しておく。</p>
</div>
<div class="paragraph">
<p>ところでRISC-VやAVRがframeindexを取り回す方法と、x86やSparcのそれは
明らかに異なる。RISC-Vではアドレスモードらしいモードが無いのに対し、
Sparcでは <code>ADDRri</code> などが存在する。このあたりで <code>ISD::FrameIndex</code> を
直接 <code>Select</code> で対応する必要があるか否かが決まっているようだが詳細不明。TODO</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_bcc_を導入する"><code>Bcc</code> を導入する</h2>
<div class="sectionbody">
<div class="paragraph">
<p>後に行う分岐解析では「ある分岐条件を逆向きにする」という処理を行う必要があるが、
<code>CMP</code> と <code>Jcc</code> に分けていると、このとき <code>Jcc</code> の情報しか与えられず <code>CMP</code> への
変更を加えることが出来ない。そこで <code>Jcc</code> と <code>CMP</code> をまとめて <code>Bcc</code> とした
擬似命令を作成してレジスタ割り付けまでを行い<sup class="footnote">[<a id="_footnoteref_103" class="footnote" href="#_footnotedef_103" title="View footnote.">103</a>]</sup>、その後これを <code>CMP</code> と <code>Jcc</code> に
伸長することにする。
この方式ではRISC-Vの方法<a href="#github_riscv-llvm_patch_17">[39]</a>をそのまま適用することができる。</p>
</div>
<div class="paragraph">
<p>しかし単発の <code>setcc</code> を上手く取り扱うことが出来ない。 <code>SelectCCrr</code> に変換すれば
良いと思い次のように書いたが、パターンマッチに成功しない。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>def : Pat&lt;(seteq GPR:$lhs, GPR:$rhs),
          (SelectCCrr GPR:$lhs, GPR:$rhs, SETEQ, (LI 0), (LI 1))&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>調査したが原因不明。何もわからない。TODO</p>
</div>
<div class="paragraph">
<p>ところで</p>
</div>
<div class="literalblock">
<div class="content">
<pre>def : Pat&lt;(SelectCC GPR:$lhs, GPR:$rhs, (i16 imm:$imm), GPR:$src, GPR:$src2),
          (SelectCCrr GPR:$lhs, GPR:$rhs, i16imm:$imm, GPR:$src, GPR:$src2)&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>とは書けないらしい。 <code>imm</code> の部分が <code>li</code> からレジスタ渡しに
変更されてしまう。 <code>Pseudo</code> の引数にパターンとして渡さないといけないようだ。
どのような違いがあるのか全然分からない。TODO</p>
</div>
<div class="paragraph">
<p>仕方が無いので <code>BR_CC</code> で実装することにする。
<code>LowerBR_CC</code> で直接 <code>Bcc</code> を返すことができないかと試したが無理のようだ。
<code>DAG.getNode</code> が引数に受け取るのはあくまで <code>SDValue</code> のための引数であって
<code>MachineSDValue</code> ではない。ExpandやCustomの処理が終わった後に
TableGenファイルをもとに命令選択が行われるのだから、当然といえば当然である。
そこにフックしたければ <code>ComplexPattern</code> を使えということなのだろう。</p>
</div>
<div class="paragraph">
<p>結局 i) <code>BR_CC</code> を <code>LowerOperation</code> でトラップして <code>RV16KISD::BR_CC</code> を作成し ii)
TableGenファイルで <code>RV16KBrCC</code> を捕捉して擬似命令 <code>Bcc/BccI</code> とし iii)
<code>RV16KInstrInfo::expandPostRAPseudo</code> でこれを <code>CMP</code> と <code>Jcc</code> に
変換することにした<sup class="footnote">[<a id="_footnoteref_104" class="footnote" href="#_footnotedef_104" title="View footnote.">104</a>]</sup>。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_分岐解析に対応する">分岐解析に対応する</h2>
<div class="sectionbody">
<div class="paragraph">
<p>branch analysisに対応することで、分岐に関する種々の最適化を
行うことができる。参考にするRISC-Vのパッチは<a href="#github_riscv-llvm_patch_30">[112]</a>。</p>
</div>
<div class="paragraph">
<p>具体的には <code>RV16KInstrInfo::analyzeBranch</code> をオーバーライドし実装する。
<code>TargetInstrInfo::analyzeBranch</code> には次のようにコメントがある。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>  /// Analyze the branching code at the end of MBB, returning
  /// true if it cannot be understood (e.g. it's a switch dispatch or isn't
  /// implemented for a target).  Upon success, this returns false and returns
  /// with the following information in various cases:
  ///
  /// 1. If this block ends with no branches (it just falls through to its succ)
  ///    just return false, leaving TBB/FBB null.
  /// 2. If this block ends with only an unconditional branch, it sets TBB to be
  ///    the destination block.
  /// 3. If this block ends with a conditional branch and it falls through to a
  ///    successor block, it sets TBB to be the branch destination block and a
  ///    list of operands that evaluate the condition. These operands can be
  ///    passed to other TargetInstrInfo methods to create new branches.
  /// 4. If this block ends with a conditional branch followed by an
  ///    unconditional branch, it returns the 'true' destination in TBB, the
  ///    'false' destination in FBB, and a list of operands that evaluate the
  ///    condition.  These operands can be passed to other TargetInstrInfo
  ///    methods to create new branches.
  ///
  /// Note that removeBranch and insertBranch must be implemented to support
  /// cases where this method returns success.
  ///
  /// If AllowModify is true, then this routine is allowed to modify the basic
  /// block (e.g. delete instructions after the unconditional branch).
  ///
  /// The CFG information in MBB.Predecessors and MBB.Successors must be valid
  /// before calling this function.
  virtual bool analyzeBranch(MachineBasicBlock &amp;MBB, MachineBasicBlock *&amp;TBB,
                             MachineBasicBlock *&amp;FBB,
                             SmallVectorImpl&lt;MachineOperand&gt; &amp;Cond,
                             bool AllowModify = false) const {
    return true;
  }</pre>
</div>
</div>
<div class="paragraph">
<p><code>MachineBasicBlock</code> の中身を調査し、分岐でbasic blockが終わっている場合には
そのtrue/falseの際の分岐先を <code>TBB</code> と <code>FBB</code> に入れろということのようだ。
なお <code>MachineBasicBlock *&amp;</code> は「ポインタへの参照」を表す<a href="#stackoverflow-5789806">[113]</a>。
機能を考えれば妥当だ。</p>
</div>
<div class="paragraph">
<p>TableGenファイルで指定した <code>isBranch</code> などはここで使用されるようだ。
例えば無条件ジャンプか否かは <code>MachineInstr::isUnconditionalBranch</code> で
次のように判断される。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>  /// Return true if this is a branch which always
  /// transfers control flow to some other block.  The
  /// TargetInstrInfo::AnalyzeBranch method can be used to get more information
  /// about this branch.
  bool isUnconditionalBranch(QueryType Type = AnyInBundle) const {
    return isBranch(Type) &amp; isBarrier(Type) &amp; !isIndirectBranch(Type);
  }</pre>
</div>
</div>
<div class="paragraph">
<p>このあたりを見ながらTableGenファイルを書けば良いようだ。</p>
</div>
<div class="paragraph">
<p><code>analyzeBranch</code> ではおおよそ次のことをやっている。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>無条件分岐か間接分岐がある場合は、その後ろの命令は実行されないので消去する<sup class="footnote">[<a id="_footnoteref_105" class="footnote" href="#_footnotedef_105" title="View footnote.">105</a>]</sup>。</p>
</li>
<li>
<p>basic blockを抜け出る命令が1つしかなく、それがbasic block最後の無条件分岐である場合は、その分岐先を <code>TBB</code> にセットして <code>false</code> を返す。</p>
</li>
<li>
<p>basic blockを抜け出る命令が1つしかなく、それがbasic block最後の条件分岐命令である場合は、その分岐先を <code>TBB</code> にセットして <code>false</code> を返す。</p>
</li>
<li>
<p>basic blockを抜け出る命令が2つあり、それがbasic block最後の「条件分岐命令＋無条件分岐命令」ならば、前者の分岐先を <code>TBB</code> に、後者の分岐先を <code>FBB</code> にセットして <code>false</code> を返す。</p>
</li>
<li>
<p>上記以外は <code>true</code> を返し、解析が不可能であることを示す。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>LanaiとSparcのものも見たが、RISC-Vと同様のことをやっている気がする<sup class="footnote">[<a id="_footnoteref_106" class="footnote" href="#_footnotedef_106" title="View footnote.">106</a>]</sup>。
なお <code>MachineBasicBlock</code> の最後には <code>isTerminator</code> がついた命令が来ることが
制約として課されているが、これは複数個あっても良い<a href="#llvm-welcome_to_the_back_end_2017">[46]</a>。
これによって条件分岐（ <code>true</code> ならこちらに飛び、 <code>false</code> なら別のところに飛ぶ）
が自然に表現できる。</p>
</div>
<div class="paragraph">
<p>引数の <code>Cond</code> に設定したオペランドは <code>insertBranch</code> や <code>reverseBranchCondition</code>
に付加情報として渡される。</p>
</div>
<div class="paragraph">
<p><code>insertBranch</code> は引数で指示された分岐命令を挿入する。
そのときに <code>Cond</code> に指定した値が同時に渡される。RV16Kでは「どの種類の分岐なのか」
が分かればよいのでopcodeを <code>Cond</code> に <code>push_back</code> しておく。</p>
</div>
<div class="paragraph">
<p><code>removeBranch</code> では <code>MBB</code> 末尾にある分岐命令を削除する。
「条件分岐命令＋無条件分岐命令」の場合はその両方を削除する。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>  /// Remove the branching code at the end of the specific MBB.
  /// This is only invoked in cases where AnalyzeBranch returns success. It
  /// returns the number of instructions that were removed.
  /// If \p BytesRemoved is non-null, report the change in code size from the
  /// removed instructions.
  virtual unsigned removeBranch(MachineBasicBlock &amp;MBB,
                                int *BytesRemoved = nullptr) const {
    llvm_unreachable("Target didn't implement TargetInstrInfo::removeBranch!");
  }

  /// Insert branch code into the end of the specified MachineBasicBlock. The
  /// operands to this method are the same as those returned by AnalyzeBranch.
  /// This is only invoked in cases where AnalyzeBranch returns success. It
  /// returns the number of instructions inserted. If \p BytesAdded is non-null,
  /// report the change in code size from the added instructions.
  ///
  /// It is also invoked by tail merging to add unconditional branches in
  /// cases where AnalyzeBranch doesn't apply because there was no original
  /// branch to analyze.  At least this much must be implemented, else tail
  /// merging needs to be disabled.
  ///
  /// The CFG information in MBB.Predecessors and MBB.Successors must be valid
  /// before calling this function.
  virtual unsigned insertBranch(MachineBasicBlock &amp;MBB, MachineBasicBlock *TBB,
                                MachineBasicBlock *FBB,
                                ArrayRef&lt;MachineOperand&gt; Cond,
                                const DebugLoc &amp;DL,
                                int *BytesAdded = nullptr) const {
    llvm_unreachable("Target didn't implement TargetInstrInfo::insertBranch!");
  }</pre>
</div>
</div>
<div class="paragraph">
<p><code>Bcc/BccI</code> に対して <code>reverseBranchCondition</code> が作用するようにする<sup class="footnote">[<a id="_footnoteref_107" class="footnote" href="#_footnotedef_107" title="View footnote.">107</a>]</sup>。</p>
</div>
<div class="paragraph">
<p>実はregister allocationのあとにもbranch analysisが実行されるため
上の設計ではエラーが出る<sup class="footnote">[<a id="_footnoteref_108" class="footnote" href="#_footnotedef_108" title="View footnote.">108</a>]</sup>。
仕方がないのでRISC-Vのatomic命令を見習い<a href="#llvm_phabricator-d47882">[109]</a>
コードが出力される直前に
変換することにする<sup class="footnote">[<a id="_footnoteref_109" class="footnote" href="#_footnotedef_109" title="View footnote.">109</a>]</sup>。</p>
</div>
<div class="paragraph">
<p>と思ったらこれでもだめだった。仕方がないので <code>MCInst</code> に変換する直前で
行うことにする。複数命令に展開されるため <code>AsmPrinter</code> の方に
変更を加える。</p>
</div>
<div class="paragraph">
<p>ここまでpeephole最適化<sup class="footnote">[<a id="_footnoteref_110" class="footnote" href="#_footnotedef_110" title="View footnote.">110</a>]</sup>
のことを気にしてきたが、よく考えると
<code>CMP+Jcc</code> のpeephole最適化とbranch analysisは不可分なのではないか。
結局peephole最適化と <code>Bcc</code> のいずれか一方のみしか対応できないのではないか
と思われる<sup class="footnote">[<a id="_footnoteref_111" class="footnote" href="#_footnotedef_111" title="View footnote.">111</a>]</sup>。TODO</p>
</div>
<div class="paragraph">
<p>しかしこれもつらい。基本的に <code>AsmPrinter</code> は一命令を複数の命令に展開することを
想定していない<sup class="footnote">[<a id="_footnoteref_112" class="footnote" href="#_footnotedef_112" title="View footnote.">112</a>]</sup>。せっかくPassとして整備したのだから、
Passとして追加したい。</p>
</div>
<div class="paragraph">
<p>結局問題になっているのは <code>CMP+Jcc</code> に置換された後に <code>analyzeBranch</code> が
実行されてしまうことである。エラーログを見ると、どうやら <code>-verify-machineinstrs</code>
がこれを実行しているようだ。</p>
</div>
<div class="paragraph">
<p><code>TargetPassConfig::addMachinePasses</code> の実装を読む。
本当の最後に実行されるパスは <code>addPreEmitPass2</code> で追加されるもののようだ。
また <code>addPass</code> の第一引数に <code>false</code> を渡せばmachine instruction verifierが
走ることを抑制できるようだ。ということで、次のように書くとうまくいった<sup class="footnote">[<a id="_footnoteref_113" class="footnote" href="#_footnotedef_113" title="View footnote.">113</a>]</sup>。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>void RV16KPassConfig::addPreEmitPass2() {
  addPass(createRV16KExpandPseudoPass(), false, true);
}</pre>
</div>
</div>
<div class="paragraph">
<p>ちなみにELVMバックエンド<a href="#elvm-llvm_backend">[36]</a>には分岐解析は実装されているが
<code>reverseBranchCondition</code> は実装されていない。なぜだろう。TODO</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_jcc_の分岐先が8bitに収まらない場合に対応する"><code>jcc</code> の分岐先が8bitに収まらない場合に対応する</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>je</code> などの条件分岐命令は、その分岐先を指定するための即値が符号付き7bit以内
であるという制約がある。従ってPC相対で前後128バイト<sup class="footnote">[<a id="_footnoteref_114" class="footnote" href="#_footnotedef_114" title="View footnote.">114</a>]</sup>にジャンプすることができるが、場合によっては
この幅に収まらないことがありうる。そのような場合には <code>j</code> 命令と組み合わせて
用いる。問題は <code>j</code> 命令を使うか否かの判断をいつするかということである。</p>
</div>
<div class="paragraph">
<p>RISC-Vではこの問題に対応していることが、次のようなCプログラムを
入力することで分かる。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>int test(int a, int b)
{
    if (a &lt; 0) {
        a += b;
        a += b;
        // ... 以下 a += b が続く
        a += b;
    }
    return a;
}</pre>
</div>
</div>
<div class="paragraph">
<p><code>a += b</code> の部分を増減させることで <code>blt</code> と <code>bge</code> 命令の内で適当な方が
出力されることが分かる。</p>
</div>
<div class="paragraph">
<p>これはbranch relaxationと呼ばれるようだ<a href="#github_riscv-llvm_patch_31">[111]</a></p>
</div>
<div class="literalblock">
<div class="content">
<pre>Branch relaxation is needed to support branch displacements that overflow the
instruction's immediate field.</pre>
</div>
</div>
<div class="paragraph">
<p>RISC-Vでの対応<a href="#github_riscv-llvm_patch_31">[111]</a>を参考に実装する。
まず <code>addPreEmitPass</code> に <code>addPass(&amp;BranchRelaxationPassID);</code> を追加する。
ついで <code>lib/CodeGen/BranchRelaxation.cpp</code> を見ると、次の関数を <code>RV16KInstrInfo</code> に
実装すれば良いことが分かる。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getInstSizeInBytes</code></p>
</li>
<li>
<p><code>isBranchOffsetInRange</code></p>
</li>
<li>
<p><code>getBranchDestBlock</code></p>
</li>
<li>
<p><code>insertIndirectBranch</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>順に実装する。 <code>getInstSizeInBytes</code> は命令のサイズを返す。
基本的には <code>MCInstrDesc</code> の <code>getSize</code> を呼べばよいが、 <code>Bcc</code> の <code>Size</code> をTableGenにて
32bitに設定しておく必要がある。</p>
</div>
<div class="paragraph">
<p><code>getBranchDestBlock</code> の実装では、ジャンプ先のbasic blockを返却する必要がある。
RISC-Vではこれは必ず最後のオペランドになるのだが、RV16Kでは下手に <code>Bcc</code>
疑似命令を作ってしまったためにそうはならない。仕方がないので
命令の種類で分けて処理することにする。TODO</p>
</div>
<div class="paragraph">
<p>実際のところRV16Kv2では <code>insertIndirectBranch</code> を実装する必要は<strong>ない</strong>。
<code>BranchRelaxation</code> は、即値で飛ぶようなジャンプ命令
（要するに <code>isBranchOffsetsInRange</code> が対象とするような命令）
では対処できないほどの大きなジャンプに対して
<code>insertIndirectBranch</code> を呼ぶ。したがって、そもそも
<code>J</code> 命令が16bitの即値をとるようなRV16Kv2では、これで対応できないジャンプには
ISAレベルで対応できない。AVRバックエンドには次のようにある。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>// This method inserts a *direct* branch (JMP), despite its name.
// LLVM calls this method to fixup unconditional branches; it never calls
// insertBranch or some hypothetical "insertDirectBranch".
// See lib/CodeGen/RegisterRelaxation.cpp for details.
// We end up here when a jump is too long for a RJMP instruction.</pre>
</div>
</div>
<div class="paragraph">
<p>次いで <code>insertBranch/removeBranch</code> で挿入・削除したバイト数を数え
<code>BytesAdded/BytesRemoved</code> に保存する。 <code>BuildMI</code> の返却値を間接参照すると
<code>MachineInstr</code> への参照が受け取れるらしい。</p>
</div>
<div class="paragraph">
<p>ここでどさくさに紛れて <code>PseudoBR</code> をただの <code>Pat</code> に直そうとしたところ
<code>br</code> にパターンマッチしなかった。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>// Old
let hasSideEffects = 0, mayStore = 0, mayLoad = 0,
    isBarrier = 1, isBranch = 1, isTerminator = 1 in
def PseudoBR : Pseudo&lt;(outs), (ins simm16_lsb0_j:$imm15), [(br bb:$imm15)]&gt;,
               PseudoInstExpansion&lt;(J simm16_lsb0_j:$imm15)&gt;;

// New
def : Pat&lt;(br bb:$imm), (J simm16_lsb0_j:$imm)&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>それから間接分岐に <code>jalr</code> を使うのは、RISC-Vでは正しいがRV16Kでは間違っている。
RISC-Vでは <code>jr</code> は <code>jalr</code> へのaliasとなっていて、次のように定義される。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>def : InstAlias&lt;"jr $rs",      (JALR X0, GPR:$rs, 0)&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>したがって <code>brind</code> は <code>JALR</code> にパターンマッチさせるべきなのだが、
一方で <code>JALR</code> は<strong>一般には</strong>間接分岐の命令ではないため、
<code>isIndirectBranch</code> などのフラグが立っていない。
そこで <code>PseudoBRIND</code> 疑似命令を作成してフラグを立て、
その上で <code>brind</code> を <code>PseudoBRIND</code> にマッチさせている<sup class="footnote">[<a id="_footnoteref_115" class="footnote" href="#_footnotedef_115" title="View footnote.">115</a>]</sup>。
このように、既存の命令に異なるフラグを立てたい場合に
<code>PseudoInstExpansion</code> が使えるようだ。
<a href="#github-llvm-bcb36be8e3f5dced36710ba1a2e2206071ccc7ba">[115]</a>。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>let isCall = 1, Defs=[X1] in
let isBarrier = 1, isBranch = 1, isIndirectBranch = 1, isTerminator = 1 in
def PseudoBRIND : Pseudo&lt;(outs), (ins GPR:$rs1, simm12:$imm12), []&gt;,
                  PseudoInstExpansion&lt;(JALR X0, GPR:$rs1, simm12:$imm12)&gt;;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>def : Pat&lt;(brind GPR:$rs1), (PseudoBRIND GPR:$rs1, 0)&gt;;
def : Pat&lt;(brind (add GPR:$rs1, simm12:$imm12)),
          (PseudoBRIND GPR:$rs1, simm12:$imm12)&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>さてではRV16Kはどうかというと、 <code>jalr</code> と <code>jr</code> はまったく異なる
命令である。ただの間接分岐では <code>jr</code> を使うことが望ましく、
一方でレジスタに入った関数の呼び出し時には <code>jalr</code> を使うべきである。
そこで次のようにパターンマッチできる。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>def : Pat&lt;(brind GPR:$rs), (JR GPR:$rs)&gt;;
def : Pat&lt;(Call GPR:$rs), (JALR GPR:$rs)&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>先の <code>Bcc</code> を導入した際にも実験したが、どうやら <code>Pseudo</code> のパターンは
少々違う性質を持っているようだ。TODO</p>
</div>
<div class="paragraph">
<p>ところでアセンブラ（ <code>MCInst</code> ）レベルでbranch relaxationに対応するのは
良い考えでは無いらしい<a href="#llvm_dev_ml-128257">[110]</a>。</p>
</div>
<div class="paragraph">
<p>大きめのプログラムを入力したところ、正しくrelaxされないことがあった。
原因は i) 疑似命令のサイズが（ <code>Bcc/BccI</code> を除いて）すべて16bit
であったことと ii) <code>Bcc/BccI</code> のoffset計算では <code>CMP</code> の分（2バイト）を
減算する必要があったことであった。特に前者が重要で、
<code>PseudoBR</code> や <code>PseudoRET</code> のように <code>PseudoInstExpansion</code> を用いて
疑似命令を展開する場合、これらは <code>AsmPrinter</code> で展開されるため
<a href="#github-llvm-bcb36be8e3f5dced36710ba1a2e2206071ccc7ba">[115]</a>branch relaxation
時点でもそのまま入力される。したがって命令サイズの情報が必要である。
さらに遅く展開される <code>PseudoHLT</code> についても同様である。
一方で <code>FRMIDX</code> などの疑似命令は
関数エピローグ・プロローグの挿入時点で展開される。
したがって命令サイズの情報は必要ではない<sup class="footnote">[<a id="_footnoteref_116" class="footnote" href="#_footnotedef_116" title="View footnote.">116</a>]</sup>。</p>
</div>
<div class="paragraph">
<p>branch relaxationの結果によっては <code>BccI imm, reg, &#8230;&#8203;</code> のような分岐を
<code>reverseBranchCondition</code> が作成し、これを
<code>insertBranch</code> で挿入される可能性がある。これは <code>cmpi imm, reg</code> に
相当するため、そのままではいけない。まず <code>ScratchReg</code> を用意し
<code>li ScratchReg, imm</code> としたうえで <code>Bcc ScratchReg, reg</code> とする。
しかしbranch relaxationはregister allocationが終わった後に実行される。
そのため新しいレジスタを確保するためにはregister scavengerを使用する
必要がある。register scavengerはレジスタ割り付けが終わったあとに
レジスタを確保するためのヘルパである<a href="#llvm_dev_ml-111697">[119]</a>。
RISC-V・AMDバックエンドの <code>insertIndirectBranch</code> では実際にこれが
使われている。なおこれらのバックエンドでは、
仮想アドレスを物理アドレスに置換し終わったあとに
<code>MRI.clearVirtRegs()</code> を呼んでいる。これは <code>insertIndirectBranch</code> は
BranchRelaxationパスからのみ呼ばれるため、この段階で仮想レジスタが
存在しないことを保証できるためである。一方で <code>insertBranch</code> は
他のパスからも呼ばれうるため、ここで呼ぶことは適当でない<sup class="footnote">[<a id="_footnoteref_117" class="footnote" href="#_footnotedef_117" title="View footnote.">117</a>]</sup></p>
</div>
<div class="paragraph">
<p>machine basic blockの終わりにセットし、逆向きにレジスタを探すのが
推奨される<sup class="footnote">[<a id="_footnoteref_118" class="footnote" href="#_footnotedef_118" title="View footnote.">118</a>]</sup>。
必要であればemergency spillが行われるようだ（要確認；TODO）<sup class="footnote">[<a id="_footnoteref_119" class="footnote" href="#_footnotedef_119" title="View footnote.">119</a>]</sup>。</p>
</div>
<div class="paragraph">
<p><code>BccI imm, reg, &#8230;&#8203;</code> となるようなテストを書こうとしたが挫折した。TODO
とりあえずテストなしにしておく。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_リンカスクリプトを書く">リンカスクリプトを書く</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_text_data_rodata_に対応する"><code>.text/.data/.rodata</code> に対応する</h3>
<div class="paragraph">
<p>ROM を <code>0x00000000</code> から <code>0x0000FFFF</code> まで、
RAM を <code>0x00010000</code> から <code>0x0001FFFF</code> までと定めたが、
現状これに即して設定しているのは <code>.text</code> と <code>.data</code> のみで
他のセクションには対応していない。これに対応するためには
リンカスクリプトを書いてリンク時に指定する他ないようなので設定する。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>SECTIONS
{
    . = 0x00000000;
    .text : { *(.text) }
    . = 0x00010000;
    .data : { *(.data) }
    .rodata : { *(.rodata) }
    .bss : { *(.bss) }
}</pre>
</div>
</div>
<div class="paragraph">
<p><a href="#redhat-ld_simple_example">[124]</a><a href="#takayuki-no09">[120]</a><a href="#hwenginner-linker">[121]</a>を参考にして、
<code>.text</code> をROMに割り付け <code>.rodata</code> と <code>.data</code> をRAMに割り付ける
シンプルなスクリプトになった。次のように <code>-Xlinker</code> オプションで
<code>--script</code> オプションをlldに渡す<sup class="footnote">[<a id="_footnoteref_120" class="footnote" href="#_footnotedef_120" title="View footnote.">120</a>]</sup>。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ bin/clang -target rv16k runtime.s foo.c -o foo.exe -Xlinker "--script=/home/anqou/workspace/llvm-project-build/rv16k.ld"</pre>
</div>
</div>
<div class="paragraph">
<p>さてこれをClang側で指定したかったのだが、そもそもこのリンカスクリプトを
どこに配置すればいいかわからない。例えばGCCでは内部的にリンカスクリプトを
持っておりこれを利用してリンクを行っている<a href="#koikikukan-000300">[122]</a>が、Clangではそうではなく
lldへのコマンドラインオプションを適切に指定することでこれを達成しているように
思える<sup class="footnote">[<a id="_footnoteref_121" class="footnote" href="#_footnotedef_121" title="View footnote.">121</a>]</sup>。
一方で上記のリンカスクリプトのような指定をlldのコマンドラインオプションでは
達成できないように思える。良くわからない。TODO 仕方がないので当分手で <code>-Xlinker</code> をつける
ことにする。</p>
</div>
</div>
<div class="sect2">
<h3 id="_bss_に対応する"><code>.bss</code> に対応する</h3>
<div class="paragraph">
<p><code>.bss</code> セクションは <code>.data</code> や <code>.rodata</code> セクションとは異なり初期値を直接持たず、
アドレスとサイズだけが格納されている<sup class="footnote">[<a id="_footnoteref_122" class="footnote" href="#_footnotedef_122" title="View footnote.">122</a>]</sup>非初期化領域である<a href="#man-elf">[107]</a>。
「非初期化」といいつつ、一般的なアーキテクチャ<sup class="footnote">[<a id="_footnoteref_123" class="footnote" href="#_footnotedef_123" title="View footnote.">123</a>]</sup>では
<code>0</code> で初期化される。</p>
</div>
<div class="paragraph">
<p>RV16Kでは <code>.bss</code> を、メモリ上一番最後に配置されるセクションとすることで、
他のセクションに使用されないRAM領域をそのまま利用することにする<sup class="footnote">[<a id="_footnoteref_124" class="footnote" href="#_footnotedef_124" title="View footnote.">124</a>]</sup></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_脇道_brainfuckインタプリタを動かす">[脇道] Brainfuckインタプリタを動かす</h2>
<div class="sectionbody">
<div class="paragraph">
<p>このあたりでBrainfuckのインタプリタが動くようになる。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>void jumpFront(const char *str, int *index)
{
    if (str[*index] != '[') return;
    for (int count = 0; str[*index] != '\0'; (*index)++) {
        if (str[*index] == '[')
            count++;
        else if (str[*index] == ']')
            count--;
        if (count == 0) break;
    }
}

void jumpBack(const char *str, int *index)
{
    if (str[*index] != ']') return;
    for (int count = 0; *index &gt;= 0; (*index)--) {
        if (str[*index] == '[')
            count--;
        else if (str[*index] == ']')
            count++;
        if (count == 0) break;
    }
}

int brainfuck(const char *str)
{
    static int data[100];

    int pointer = sizeof(data) / sizeof(int) / 2;
    for (int index = 0; str[index] != '\0'; index++) {
        switch (str[index]) {
        case '+':
            data[pointer]++;
            break;
        case '-':
            data[pointer]--;
            break;
        case '&gt;':
            pointer++;
            break;
        case '&lt;':
            pointer--;
            break;
        case '.':
            break;
        case ',':
            break;
        case '[':
            if (data[pointer] == 0) jumpFront(str, &amp;index);
            break;
        case ']':
            if (data[pointer] != 0) jumpBack(str, &amp;index);
            break;
        }
    }
    return data[pointer];
}

int main()
{
    return brainfuck("+++++[&gt;++++++++++&lt;-]&gt;++");
}</pre>
</div>
</div>
<div class="paragraph">
<p>AWS Lambdaの出来上がりである<sup class="footnote">[<a id="_footnoteref_125" class="footnote" href="#_footnotedef_125" title="View footnote.">125</a>]</sup>。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_byvalに対応する">byvalに対応する</h2>
<div class="sectionbody">
<div class="paragraph">
<p>構造体などレジスタに収まらない値を関数に値渡しする場合（ <code>isByVal()</code> が
<code>true</code> を返す時）に対応する。</p>
</div>
<div class="paragraph">
<p>次のようなCコードを入力するとbyvalに対応していないために <code>bar</code>
についてはエラーになるが、 <code>foo</code> と <code>piyo</code> については
エラーにならない。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>struct hoge {
    int ary[10];
};

int foo(struct hoge h)
{
    return h.ary[3];
}

int bar(void)
{
    struct hoge h;
    h.ary[3] = 10;
    return foo(h);
}

struct hoge piyo(int i)
{
    struct hoge h;
    h.ary[3] = i;
    return h;
}</pre>
</div>
</div>
<div class="paragraph">
<p>まず <code>foo</code> のように、構造体の値を引数として渡す場合、
呼び出し元の関数のスタックに渡す構造体のコピーを作成する。
次いでこのコピーへのポインタを
値の代わりに引数として渡す。これらは <code>LowerCall</code> にて行われる。</p>
</div>
<div class="paragraph">
<p>また <code>piyo</code> のように
戻り値として構造体の値を返す場合、呼び出される関数の第一引数に
<code>sret</code> がついたポインタが渡されるように関数プロトタイプが
フロントエンドによって変更される。それに合わせて関数呼び出しの
戻り値・引数も変更されるため、バックエンドが特別にすべき
処理はない。</p>
</div>
<div class="paragraph">
<p>結局 <code>byval</code> 処理のために変更する必要があるのは <code>LowerCall</code> での
「構造体のコピーをスタックに作成し、値の代わりにこれへのポインタを
返す」部分である。実装に際してはRISC-Vのもの<a href="#github_riscv-llvm_patch_25">[95]</a>
を参考にする。</p>
</div>
<div class="paragraph">
<p>最適化なしだと無意味なコードが多く出力されてしまうため、
次のようなコードを <code>-O2</code> をつけてテストするとよい。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>struct hoge {
    int ary[10];
};

int foo(struct hoge);

struct hoge bar(int i)
{
    struct hoge h;
    h.ary[3] = i;
    h.ary[3] = foo(h);
    return h;
}</pre>
</div>
</div>
<div class="paragraph">
<p>なお構造体のサイズが小さく、レジスタに直接載るような場合<sup class="footnote">[<a id="_footnoteref_126" class="footnote" href="#_footnotedef_126" title="View footnote.">126</a>]</sup>でも、このように迂遠な方法をとる。
これはおそらく <code>Clang</code> 側でcalling conventionとして指定することにより
解決が可能であると推測される。TODO <sup class="footnote">[<a id="_footnoteref_127" class="footnote" href="#_footnotedef_127" title="View footnote.">127</a>]</sup></p>
</div>
<div class="paragraph">
<p>テストでは <code>getelementptr</code> を用いる。この命令の
第三引数以降は、構造体なら何番目のメンバか、配列なら何番目の要素かを表している
<a href="#llvm-langref">[43]</a>。ちょうどC言語の <code>.</code> や <code>[]</code> に相当するようだ<sup class="footnote">[<a id="_footnoteref_128" class="footnote" href="#_footnotedef_128" title="View footnote.">128</a>]</sup>。
単なるポインタを間接参照する場合は <code>0</code> を指定する必要があることが分かる。
<a href="#llvm-langref">[43]</a>にある例を引用する。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>struct RT {
  char A;
  int B[10][20];
  char C;
};
struct ST {
  int X;
  double Y;
  struct RT Z;
};

int *foo(struct ST *s) {
  return &amp;s[1].Z.B[5][13];
}</pre>
</div>
</div>
<div class="paragraph">
<p>このようなCコードに対して、次のようなLLVM IRが対応する。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>%struct.RT = type { i8, [10 x [20 x i32]], i8 }
%struct.ST = type { i32, double, %struct.RT }

define i32* @foo(%struct.ST* %s) nounwind uwtable readnone optsize ssp {
entry:
  %arrayidx = getelementptr inbounds %struct.ST, %struct.ST* %s, i64 1, i32 2, i32 1, i64 5, i64 13
  ret i32* %arrayidx
}</pre>
</div>
</div>
<div class="paragraph">
<p>なお構造体に対してindexを指定する際には <code>i32</code> 定数値のみが使用できる。
上の例で <code>i32</code> となっているところはそれである。</p>
</div>
<div class="paragraph">
<p>RISC-Vのコード<a href="#github_riscv-llvm_patch_25">[95]</a>を参考にしてテストを書くと
<code>foo+2</code> のようなコードが生成される。
<code>llvm-objdump</code> で確認すると、一見 <code>0</code> が入っていて正しくオブジェクトファイルが
生成されていないように見えるが <code>llvm-readelf</code> で確認するとrelocationが
作成されていることが分かる。実際グローバル変数はどこに配置されるか分からないので
これが正しい。</p>
</div>
<div class="paragraph">
<p>byval引数のためにローカルスタックに用意した領域への
ポインタに引数をすり替える必要がある。first tryではこれを忘れていた。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fastccに対応する">fastccに対応する</h2>
<div class="sectionbody">
<div class="paragraph">
<p>LLVMでは、ABIに定義されたC言語の関数呼び出し規約に則った呼出し規約 (<code>ccc</code>;
<code>The C calling convention</code>) の他に、
互換性を無視したより高速な呼出し規約を利用できる。
これを <code>fastcc</code>; <code>The fast calling convention</code> という<a href="#llvm-langref">[43]</a>。
これは例えば <code>static</code> 指定された関数など、外部との互換性を気にする必要がない
場合に使用される<sup class="footnote">[<a id="_footnoteref_129" class="footnote" href="#_footnotedef_129" title="View footnote.">129</a>]</sup>。
また、末尾最適化は <code>fastcc</code> 指定された関数にのみ適用される。</p>
</div>
<div class="paragraph">
<p>RISC-VではCCCとFastCCに違いがない<a href="#llvm_phabricator-d45395-398662">[126]</a>。</p>
</div>
<div class="paragraph">
<p>RV16Kでもあえて違いを出す必要がないため <code>ccc</code> と全く同じにしておく。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_インラインアセンブリに対応する">インラインアセンブリに対応する</h2>
<div class="sectionbody">
<div class="paragraph">
<p>LLVM IRはインラインアセンブリに対応している<a href="#llvm-langref-inline_asm">[127]</a>。
制約などの記述方法はほとんどgccのインラインアセンブリのそれと一致するため、
gcc向けの資料などを参考にできる<a href="#hazymoon-gcc_inline_asm">[128]</a>。</p>
</div>
<div class="paragraph">
<p>RV16Kバックエンドでもインラインアセンブリに対応する。
ユーザが直接使うことよりも、テストが記述しやすくなることが
モチベーションである。
参考にするパッチは<a href="#github_riscv-llvm_patch_28">[129]</a>。</p>
</div>
<div class="paragraph">
<p>まず <code>RV16KTargetLowering::getRegForInlineAsmConstraint</code> をオーバーライドする。
この関数では <code>r</code> や <code>{edx}</code> といったレジスタの制約に応じて、
対応するレジスタの番号とレジスタのクラスを返す。
オーバーライド元の <code>TargetLowering::getRegForInlineAsmConstraint</code> は
具体的な物理レジスタが制約として与えられた場合（例えば <code>{edx}</code> ）
の処理が記述されているため、
それ以外（ <code>r</code> ）の場合について記述する。特定の物理レジスタに限らず、
あるレジスタクラスに属するレジスタなら何でも良い場合は、
そのレジスタクラスと <code>0</code> を返却する
<sup class="footnote">[<a id="_footnoteref_130" class="footnote" href="#_footnotedef_130" title="View footnote.">130</a>]</sup>。</p>
</div>
<div class="paragraph">
<p>これによってbranch analysisまでインラインアセンブリが通るようになる。
<code>RV16KInstrInfo::getInstSizeInBytes</code> にてエラーが出る
<sup class="footnote">[<a id="_footnoteref_131" class="footnote" href="#_footnotedef_131" title="View footnote.">131</a>]</sup>ので、
<code>TargetOpcode::INLINEASM</code> を
ハンドルする。 <code>getInlineAsmLength</code> を呼べば良い。</p>
</div>
<div class="paragraph">
<p>すると次のようなエラーがアセンブリ中に出力されるようになる。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>error: invalid operand in inline asm: 'add $1, $2'
error: invalid operand in inline asm: 'add $1, $2'</pre>
</div>
</div>
<div class="paragraph">
<p>すなわち <code>$1</code> などが正しく展開されていない。
これを展開するためには <code>RV16KAsmPrinter::PrintAsmOperand</code> を
実装する必要がある<sup class="footnote">[<a id="_footnoteref_132" class="footnote" href="#_footnotedef_132" title="View footnote.">132</a>]</sup>。
なお <code>AsmPrinter::PrintAsmOperand</code> は <code>c</code> や <code>n</code> といったmodifierが
付与された即値オペランドを処理するようだ<a href="#llvm-langref-inline_asm-asm_template_argument_modifier">[130]</a>。</p>
</div>
<div class="paragraph">
<p>同様に制約 <code>m</code> にも対応する。まず <code>RV16KDAGToDAGISel::SelectInlineAsmMemoryOperand</code>
をオーバーライドして実装し、メモリアドレスへのパターンマッチを実現する<sup class="footnote">[<a id="_footnoteref_133" class="footnote" href="#_footnotedef_133" title="View footnote.">133</a>]</sup>。
とりあえず単純な場合にのみ対応するため左から右へ受け流す<sup class="footnote">[<a id="_footnoteref_134" class="footnote" href="#_footnotedef_134" title="View footnote.">134</a>]</sup>。</p>
</div>
<div class="paragraph">
<p>また <code>$1</code> などを展開するために <code>RV16KAsmPrinter::PrintAsmMemoryOperand</code> を
実装する。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_emergency_spillに対応しない">emergency spillに対応しない</h2>
<div class="sectionbody">
<div class="paragraph">
<p>register scavengerが空きレジスタを見つけられない場合にレジスタの内容を
退避するemergency spillに対応しようとした。
まず <code>RV16KFrameLowering::processFunctionBeforeFrameFinalized</code> を
オーバーライドする。この関数はstack frameのファイナライズを行う関数で、
これが呼ばれた後はスタックのサイズが確定し、
frame indexを定数値に置き換えられる<sup class="footnote">[<a id="_footnoteref_135" class="footnote" href="#_footnotedef_135" title="View footnote.">135</a>]</sup>。</p>
</div>
<div class="paragraph">
<p>emergency spillとはregister scavengerがレジスタを確保する際に行う
spill操作のことで <code>RegScavenger::spill</code> 内で行われる。</p>
</div>
<div class="paragraph">
<p>ここでRISC-Vバックエンドのemergency spillに関する考察を行うと、
RV16Kバックエンドにはemergency spillへの対応は不要であると結論される。</p>
</div>
<div class="paragraph">
<p>そもそも、RISC-Vバックエンドがregister scavengerを必要とするのは次に限られる。
これは <code>MRI.createVirtualRegister</code> を利用しているコードのうち、
register allocationが実行された後に実行される部分と同一である。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>RISCVFrameLowering::adjustReg</code> 内で <code>Val</code> を <code>DestReg</code> に読み込む際 <code>Val</code> が
符号付き12bit即値に収まらない場合は <code>addi</code> 1命令では対応できないため、
<code>ScratchReg</code> 仮想レジスタを一時レジスタとして使用してこれを行う。
このとき <code>Val</code> はスタックサイズ（ないしそれに近い値）である。</p>
</li>
<li>
<p><code>RISCVRegisterInfo::eliminateFrameIndex</code> 内で <code>Offset</code> を <code>FrameReg</code> と
ともにframe indexの代わりに指定する際 <code>Offset</code> が符号付き12bit即値に
収まらない場合は <code>addi/lw/sw</code> など1命令では対応できないため、
<code>ScratchReg</code> 仮想レジスタを一時レジスタとして使用してこれを行う。
このとき <code>Offset</code> はスタック上の相対アドレスである。</p>
</li>
<li>
<p><code>RISCVInstrInfo::insertIndirectBranch</code> 内でジャンプ先のアドレスを
レジスタに格納するために <code>ScratchReg</code> 仮想レジスタを一時レジスタとして
使用してこれを行う。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><code>RISCVFrameLowering::processFunctionBeforeFrameFinalized</code> 内のコメントが
意味しているのは、上記の3について <code>ScratchReg</code> に
対応する物理レジスタを見つけられないような場合のemergency spillには
対応しないということだろう。おそらくその理由は、そのような状況を
frame loweringの段階で判断できないからだと推察される。
すなわちRISC-Vバックエンドにおいては、
全ての場合についてemergency spillのための領域 (emergency spill slot)
をstack上に確保するのは非効率であるため、
frame loweringの段階で分かる情報から判断して
emergency spill slotが必要そうなframeに対してのみこの領域を確保しているが、
上記リストの3の状態でemergency spillが必要か否かをframe loweringの
段階で判断することはほとんど不可能だと推察されるということである。</p>
</div>
<div class="paragraph">
<p>では1と2の場合にはどのように「emergency spill slotが必要か否か」を判断するのか。
実際のRISC-Vバックエンドでは「フレームが使用すると推測されるスタックサイズが
符号付き11bit整数に収まらない（つまり2048バイト以上）のとき」にこれを確保する。
なぜこれでよいのか。それは、1と2はどちらも<strong>スタックサイズまたはsp/fpからの
相対アドレスを表す即値が符号付き12bit整数に収まらない場合に、
register scavengerを利用して一時レジスタを確保する</strong>という共通点があるからである。
従って一時レジスタを使用するのはスタックサイズが符号付き12bit整数値で
表せないほど大きい場合に限定される。もちろんこれは必要条件で、
このような状態であったとしても実際にはemergency spillが必要とならないケースが
ほとんどだと推察される。それゆえRISC-Vバックエンドにemergency spillを
導入したコミットのコミットメッセージ
<a href="#github-llvm-0715d35ed5ac2312951976bee2a0d2587f98f39f">[131]</a>
では次のように書いている。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Although the register scavenger can often find a spare register, an emergency
spill slot is needed to guarantee success.</pre>
</div>
</div>
<div class="paragraph">
<p>では転じてRV16Kではどうか。RV16Kでは <code>lw/sw</code> が符号付き16bit即値をとるため、
上記リストのうち2は問題にならない。一方で1と3については同様の問題をはらんでいる。
このうち1については、RISC-Vと同様の手法を用いて対応できる。すなわち <code>addi</code> が
許容する符号付き4bit即値より大きいスタックサイズとなりそうな場合は
emergency spill slotを確保するのである。しかしこれはほとんどの関数で
この領域を確保することを意味するため、極めて非効率であり「コスパ」が悪い。
従って当分emergency spillについては実装しないことにする。</p>
</div>
<div class="paragraph">
<p>ちなみにRISC-Vの <code>large-stack.ll</code> のテストが<a href="#github_riscv-llvm_patch_32">[132]</a>では
変更されているが、実はこのテストはemergency spillを必要としないため、
<code>processFunctionBeforeFrameFinalized</code> の当該部分をコメントアウトしても
動作する。これはよく分からない。TODO</p>
</div>
<div class="paragraph">
<p>なおemergency spillを実装していない（ <code>processFunctionBeforeFrameFinalized</code> がない）
バックエンドも多い。
またARCバックエンドでは、スタック領域を使用するならば (<code>MFI.hasStackObjects()</code>)
必ずemergency spill slotを確保している。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_frameaddrreturnaddr_に対応する"><code>FRAMEADDR/RETURNADDR</code> に対応する</h2>
<div class="sectionbody">
<div class="paragraph">
<p>LLVM IRには <code>llvm.frameaddress</code> というintrinsicがある。
これは指定したスタックフレームのframe pointerの値を計算し返却するビルトイン関数で、
例えばスタックトレースの取得などに使用される（要確認；TODO）。
これは <code>ISD::FRAMEADDR</code> に対応しておりcustomでのlowerが必要である<a href="#github_riscv-llvm_patch_29">[88]</a>
<sup class="footnote">[<a id="_footnoteref_136" class="footnote" href="#_footnotedef_136" title="View footnote.">136</a>]</sup>。
具体的には引数で指定された深さまでframe pointerを手繰る必要がある。
しかしこれはスタックにframe pointerが格納されている場合に限り有効である。
例えば <code>hasFP</code> では、引数で指定する関数中で <code>llvm.frameaddress</code> が呼ばれていないかを
考慮できるが、その関数を呼び出す関数のことまではわからない。したがってframe pointer eliminationが
行われている関数から呼び出されるなどした場合は正しいframe pointerを
計算することはできないが、仕様上これで良いことになっている<a href="#llvm-langref">[43]</a>。
すなわち <code>llvm.frameaddress</code> を使用すること自体は、これが正しく動かなくなるような
最適化等を抑止しない。</p>
</div>
<div class="paragraph">
<p><code>llvm.returnaddress</code> はその関数のreturn addressを同様に計算し返却するビルトイン関数で、
<code>ISD::RETURNADDR</code> に対応する。これもまた <code>llvm.frameaddress</code> と同じ意味において
正しい値を返却することは保証しない<a href="#llvm-langref">[43]</a>。</p>
</div>
<div class="paragraph">
<p>ところで <code>llvm.returnaddress</code> が正常に動作するためには、スタック上に
<code>ra</code> が保存されている必要がある。おそらくこれがRISC-Vバックエンドが
<code>RISCVFrameLowering::determineCalleeSaves</code> にて <code>SavedRegs</code> に
<code>ra</code> を追加する理由だろうと推察される。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_pseudobr_を消す"><code>PseudoBR</code> を消す</h2>
<div class="sectionbody">
<div class="paragraph">
<p>RISC-Vでは <code>br</code> にパターンマッチさせるために <code>PseudoBR</code> 擬似命令を作成している。
これは <code>JAL</code> 命令を直接使うと <code>isBranch</code> などのフラグが立たないためである
と推察される<a href="#github-llvm-bcb36be8e3f5dced36710ba1a2e2206071ccc7ba">[115]</a>。
RV16Kでは <code>J</code> 命令を直接使用すればよいため <code>PseudoBR</code> 擬似命令は必要ない。
そこでこれを削除し次のようにパターンマッチを記述した。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>def : Pat&lt;(br bb:$imm), (J simm16_lsb0_j:$imm)&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>すると <code>branch.ll</code> を読み込ませると次のようなエラーが出力された。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ISEL: Starting selection on root node: t19: ch = br t21, BasicBlock:ch&lt;test2 0x5577d143f220&gt;
ISEL: Starting pattern match
  Match failed at index 0
LLVM ERROR: Cannot select: t19: ch = br t21, BasicBlock:ch&lt;test2 0x5577d143f220&gt;
In function: foo</pre>
</div>
</div>
<div class="paragraph">
<p>以前にもあったが、どうやら <code>Instruction</code> の <code>Pattern</code> フィールドに
パターンを指定するのと <code>Pat</code> を利用してパターンを指定するのとは
微妙に意味が異なるようなのだ。実際 <code>J</code> の定義の際に
<code>let Pattern = [(br bb:$imm)]</code> と指定すると正しく動作する。</p>
</div>
<div class="paragraph">
<p><code>TargetSelectionDAG.td</code> 内で <code>Pat</code> は <code>Pattern</code> クラスであると定義される。
一方 <code>Pattern</code> フィールドの方は <code>Target.td</code> の <code>Instruction</code> クラス内で
保持される。</p>
</div>
<div class="paragraph">
<p><code>br</code> のための <code>Pat</code> がある場合とない場合で生成されるTableGenファイルを比較した
ところ<strong>全く同一</strong>であった。つまりTableGenが <code>Pat</code> で指定される <code>br</code> に
対応していないようだ。</p>
</div>
<div class="paragraph">
<p><code>Pat</code> で指定するパターンも <code>Pattern</code> フィールドで指定するパターンも、
どちらもTableGenによって <code>RV16KGenDAGISel.inc</code> の <code>SelectCode</code> という関数の
<code>MatcherTable</code> という巨大なテーブルにまとめられる。
これを生成するのは <code>DAGISelEmitter.cpp</code> の <code>DAGISelEmitter::run</code> のようだ。</p>
</div>
<div class="paragraph">
<p><code>ninja -v</code> として <code>RV16KGenDAGISel.inc</code> を作るコマンドを把握し <code>-debug</code> オプションを
仕掛けたが、そもそもこれに対応していなかった。 <code>gdb</code> を用いて調べようとしたが
breakpointが設定できない。謎。仕方がないので <code>DAGISelEmitter::run</code> 内の
<code>LLVM_DEBUG</code> の <code>errs()</code> を <code>std::cerr</code> に変更してコンパイルし実行すると、
すでにこの段階で <code>br</code> が消えていることが分かった。さてどうするか。</p>
</div>
<div class="paragraph">
<p>このDAGISelの部分がどのように動くかについてまとめた資料を見つけた
<a href="#github-fracture-wiki-how-dagisel-works">[134]</a>。
これによると実際に <code>Pattern</code> を解釈しているのは
<code>CodeGenDAGPatterns::ParsePatterns</code> のようだ。
そこでここに次のようにデバッグ表示を仕込むと <code>br</code> の文字が見えた。
ここまでは到達しているようだ。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/////////// INSERTED FOR DEBUG FROM HERE //////////
std::cerr &lt;&lt; "PATTERN: ";
Pattern.dump();
std::cerr &lt;&lt; "RESULT:  ";
Result.dump();
/////////// INSERTED FOR DEBUG   TO HERE //////////</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>ParseOnePattern(CurPattern, Pattern, Result, InstImpResults);</pre>
</div>
</div>
<div class="paragraph">
<p>次に <code>CodeGenDAGPatterns::ParseOnePattern</code> の末尾にこのようにデバッグ表示を
仕込んだ。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/////////// INSERTED FOR DEBUG FROM HERE //////////
std::cerr &lt;&lt; "PATTERN: ";
Pattern.dump();
std::cerr &lt;&lt; "RESULT:  ";
Result.dump();
std::cerr &lt;&lt; "&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\t" &lt;&lt; std::boolalpha &lt;&lt; Temp.getOnlyTree()-&gt;hasPossibleType() &lt;&lt; std::endl;
/////////// INSERTED FOR DEBUG   TO HERE //////////</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>// A pattern may end up with an "impossible" type, i.e. a situation
// where all types have been eliminated for some node in this pattern.
// This could occur for intrinsics that only make sense for a specific
// value type, and use a specific register class. If, for some mode,
// that register class does not accept that type, the type inference
// will lead to a contradiction, which is not an error however, but
// a sign that this pattern will simply never match.
if (Temp.getOnlyTree()-&gt;hasPossibleType())
  for (auto T : Pattern.getTrees())
    if (T-&gt;hasPossibleType())
      AddPatternToMatch(&amp;Pattern,
                        PatternToMatch(TheDef, makePredList(Preds),
                                       T, Temp.getOnlyTree(),
                                       InstImpResults, Complexity,
                                       TheDef-&gt;getID()));</pre>
</div>
</div>
<div class="paragraph">
<p>次のように出力された。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>PATTERN: anonymous_997: 	(br (bb:{ *:[Other] }):$imm)
RESULT:  anonymous_997: 	(J (imm:{ *:[] })&lt;&lt;P:Predicate_simm16_lsb0_j&gt;&gt;:$imm)
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;	false</pre>
</div>
</div>
<div class="paragraph">
<p>すなわち <code>Temp.getOnlyTree()&#8594;hasPossibleType()</code> が <code>false</code>
となっているためにパターンとして登録されないことが分かった。</p>
</div>
<div class="paragraph">
<p>ここで正しく動作する <code>Pattern</code> フィールドでの指定を試すと、次のように出力された。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>PATTERN: J:     (br (bb:{ *:[Other] }):$imm)
RESULT:  J:     (J (bb:{ *:[Other] }):$imm)
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; true</pre>
</div>
</div>
<div class="paragraph">
<p>そこで次のように <code>Pat</code> を指定すると無事動作した。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>def : Pat&lt;(br bb:$imm), (J bb:$imm)&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>一方 <code>bb</code> ではなく <code>simm16_lsb0_j</code> に合わせると <code>false</code> となり動作しなかった。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>PATTERN: anonymous_997: 	(br (imm:{ *:[] })&lt;&lt;P:Predicate_simm16_lsb0_j&gt;&gt;:$imm)
RESULT:  anonymous_997: 	(J (imm:{ *:[] })&lt;&lt;P:Predicate_simm16_lsb0_j&gt;&gt;:$imm)
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;	false</pre>
</div>
</div>
<div class="paragraph">
<p>ここで <code>Bcc</code> に注目すると、こちらも <code>bb</code> から <code>simm8_lsb0</code> と同じような
パターンマッチを行っているにも関わらず、次のように <code>true</code> が返却されている。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>PATTERN: anonymous_1003:        (RV16KBrCC GPR:{ *:[i16] }:$lhs, GPR:{ *:[i16] }:$rhs, (bb:{ *:[Other] }):$dst, SETLE:{ *:[Other] })
RESULT:  anonymous_1003:        (Bcc:{ *:[i16] } GPR:{ *:[i16] }:$lhs, GPR:{ *:[i16] }:$rhs, simm8_lsb0:{ *:[Other] }:$dst, 1:{ *:[i16] })
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; true</pre>
</div>
</div>
<div class="paragraph">
<p>そこで <code>simm16_lsb0_j</code> の定義を変え <code>ImmLeaf</code> の継承をやめたところ、
<code>br</code> のパターンマッチを書き換えずとも動作するようになった。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>def simm16_lsb0_j : Operand&lt;OtherVT&gt; {</pre>
</div>
</div>
<div class="paragraph">
<p>推測するに <code>ImmLeaf</code> 継承時に指定する <code>return isShiftedInt&lt;15, 1&gt;(Imm);</code>
が <code>bb</code> には当てはまらなかった（そもそも即値でない）ために
正しいパターンマッチと認識されなかったのではないだろうか。TODO</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_rv16k_rtを作る">rv16k-rtを作る</h2>
<div class="sectionbody">
<div class="paragraph">
<p>ランタイムライブラリなど、LLVM バックエンドを使うためのスクリプトを
置く場所を作る。これ自体は単なるディレクトリ（ないしgitレポジトリ）だが、
これがある前提でClangを設定する。</p>
</div>
<div class="paragraph">
<p><code>runtime.s</code> を <code>crt0.s</code> という名前でrv16k-rtに移す。また <code>rv16k.lds</code> も
ここに移す。Clangを起動する際には <code>--sysroot=/path/to/rv16k-rt</code> とする。
そのため <code>--sysroot</code> が設定された場合には <code>getFilePaths().push_back(D.SysRoot)</code> とし、
そこを探索パスに追加する。</p>
</div>
<div class="paragraph">
<p>ついでに <code>-L</code> オプションに対応する。これはそのままリンカに渡す。
したがって <code>-L</code> をつけるだけではClangの探索パスには入らないことに注意が必要である。
<code>GetProgramPath</code> の実装を見ると <code>LibraryPaths</code> を検索していることが分かるが、
これは <code>-L</code> とは全く無関係である。</p>
</div>
<div class="paragraph">
<p>さて以上の変更から、Clangを起動する際には次のようにすることになった。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ bin/clang -target rv16k -Oz bf.c -o bf.exe --sysroot=/path/to/rv16k-rt</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_0_を不正なアドレスにする"><code>0</code> を不正なアドレスにする</h2>
<div class="sectionbody">
<div class="paragraph">
<p>通常 <code>0</code> として指定される <code>NULL</code> を不正なアドレスにする。
すなわちRAMの0番地にはいかなるデータも格納しないことにする。
これはLLVMが暗黙のうちに仮定している条件でもある（どこかで出典を見たが見つけられない；
要調査；TODO）。</p>
</div>
<div class="paragraph">
<p>リンカスクリプトをいじって <code>.data</code> が <code>0x00010002</code> から始まるようにする。</p>
</div>
<div class="paragraph">
<p>しかし実質的にNULLポインタが発生するのはmalloc/freeを使い始めてからなので、
それが無い間はさほど問題ではない。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_乗算除算剰余に対応">乗算・除算・剰余に対応</h2>
<div class="sectionbody">
<div class="paragraph">
<p>RV16Kv2命令セットには掛け算や割り算・余りを計算するための命令がない。
そこでこれらをソフトウェア的に実装し対応する。</p>
</div>
<div class="paragraph">
<p>LLVMはこれらの演算を <code><em>mulhi3</code> などのライブラリ関数呼び出しに変換する。
どの操作がどのライブラリ関数呼び出しに対応しているかは
<code>llvm/include/llvm/RuntimeLibcalls.def</code> にて定まっており、
例えば32bitの掛け算なら <code></em>mulsi3</code> ・ 16bitなら <code>__muhi3</code> と定義されている。</p>
</div>
<div class="paragraph">
<p>これらの関数の実体はLLVMのcompiler-rtプロジェクトなど<sup class="footnote">[<a id="_footnoteref_137" class="footnote" href="#_footnotedef_137" title="View footnote.">137</a>]</sup>で定義される。
しかしcompiler-rt の <code><em>mulsi3</code> の実装などをみると <code>int</code> が使われている。
すなわち <code>int</code> を32bitの整数型と前提しているのだ。
一方で16bit用の <code></em>mulhi3</code> などはそもそも定義されていない。
したがってこのままでは使用できないため、
これをフォークし改変して使用することにする。</p>
</div>
<div class="paragraph">
<p>これらの関数は、各々別のオブジェクトファイルとしてコンパイルし<sup class="footnote">[<a id="_footnoteref_138" class="footnote" href="#_footnotedef_138" title="View footnote.">138</a>]</sup>、
<code>ar</code> コマンドを用いて次のように静的ライブラリ <code>libc</code> とする。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ar rcs libc.a __mulhi3.o __divhi3.o ...</pre>
</div>
</div>
<div class="paragraph">
<p>この <code>libc</code> をLLDを用いてリンクする。それには <code>-lc</code> オプションを付与すればよいが、
いちいち手で指定するのは面倒のためClang側でデフォルト設定する。
このときこのオプションはソースコードをコマンドに並べ終えたあとに指定することが
大切である。また <code>libc</code> の他にも静的ライブラリをリンクする必要があり、
それらが互いに循環依存の関係にある場合は <code>--start-group</code> と <code>--end-group</code> で
囲むなどする必要がある<a href="#shinh-blog-010637">[137]</a>。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_allowregisterrenaming_を_1_にする"><code>AllowRegisterRenaming</code> を <code>1</code> にする</h2>
<div class="sectionbody">
<div class="paragraph">
<p>TableGenファイルによるTarget定義のところで <code>AllowRegisterRenaming</code> を <code>1</code> に
設定する<a href="#github_riscv-llvm_patch_85">[141]</a>。これによってテストを若干修正する必要が
ある。</p>
</div>
<div class="paragraph">
<p><code>AllowRegisterRenaming</code> によって、
レジスタ割り付けが終わった後にレジスタの名前を書き換える処理が許可される。
ABIやopcodeの制限からレジスタを書き換えることができない場合は
<code>MachineOperand::isRenamable</code> が <code>false</code> を返すことが要求される。
これが具体的にどのような場合に相当するのかはよくわからないが、
とりあえずテストはパスしたのでよしとする。TODO</p>
</div>
<div class="paragraph">
<p>このレジスタ書き換えは <code>MachineCopyPropagation</code> で行われる。
このパスは、コピー先レジスタが使われるまでにコピー元レジスタが破壊されていなければ、
代わりにコピー元レジスタを使用するようにする。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_最適化について調査する">最適化について調査する</h2>
<div class="sectionbody">
<div class="paragraph">
<p>RV16Kv2にとってベストな最適化が行われるようにしたい。</p>
</div>
<div class="paragraph">
<p><code>llvm/lib/Passes/PassBuilder.cpp</code> にて最適化等のパイプラインが構築されている<a href="#llvm_dev_ml-117139">[140]</a>。
具体的には <code>PassBuilder::parseModulePass</code> にてコマンドラインオプションが
パーズされ、通常 <code>buildPerModuleDefaultPipeline</code> が呼ばれる。
このなかでは <code>buildModuleSimplificationPipeline</code> によってcore simplificationの
ためのパスが追加され、次いで <code>buildModuleOptimizationPipeline</code> によって
optimizationのためのパスが追加される。</p>
</div>
<div class="paragraph">
<p>具体的にどのようなパスが実行されているか、Clangに <code>-mllvm
-opt-bisect-limit=-1</code> をオプションとして渡すことでダンプさせることができる。
また <code>-mllvm -debug-pass=Arguments</code> を渡すことで <code>opt</code> にどのようなオプションが
渡されるかを見ることができる<a href="#llvm_dev_ml-117139">[140]</a>。</p>
</div>
<div class="paragraph">
<p><code>TwoAddressInstructionPass</code> は <code>A = B op C</code> を <code>A = B</code> と <code>A op= C</code> に
分割する。</p>
</div>
<div class="paragraph">
<p><code>-Oz</code> オプションが渡されたときの挙動が良くわからない。TODO
<code>-O2</code> のときと比較すると <code>opt</code> に渡されているオプションは少なくなっている。
これは <code>PassBuilder</code> にて <code>isOptimizingForSize</code> を使って分岐しているところに
対応しているようだ。したがって <code>-Oz</code> オプション<sup class="footnote">[<a id="_footnoteref_139" class="footnote" href="#_footnotedef_139" title="View footnote.">139</a>]</sup>をつけた場合、
次の箇所が<strong>無効化</strong>される。</p>
</div>
<div class="paragraph">
<p>まず標準ライブラリ関数呼び出しの結果が用いられない場合に、
引数の値の範囲に応じて関数呼び出しを抑制するような <code>if</code> を追加する（shrink-wrapする）
パス<sup class="footnote">[<a id="_footnoteref_140" class="footnote" href="#_footnotedef_140" title="View footnote.">140</a>]</sup>。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>if (!isOptimizingForSize(Level))
  FPM.addPass(LibCallsShrinkWrapPass());</pre>
</div>
</div>
<div class="paragraph">
<p>次にソースコードのプロファイルに応じてメモリアクセスの命令を最適化するパス
<sup class="footnote">[<a id="_footnoteref_141" class="footnote" href="#_footnotedef_141" title="View footnote.">141</a>]</sup>。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>// For PGO use pipeline, try to optimize memory intrinsics such as memcpy
// using the size value profile. Don't perform this when optimizing for size.
if (PGOOpt &amp;&amp; PGOOpt-&gt;Action == PGOOptions::IRUse &amp;&amp;
    !isOptimizingForSize(Level))
  FPM.addPass(PGOMemOPSizeOpt());</pre>
</div>
</div>
<div class="paragraph">
<p>最後に簡素化とインライン展開を行うパス群<sup class="footnote">[<a id="_footnoteref_142" class="footnote" href="#_footnotedef_142" title="View footnote.">142</a>]</sup>。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>// Generally running simplification passes and the inliner with an high
// threshold results in smaller executables, but there may be cases where
// the size grows, so let's be conservative here and skip this simplification
// at -Os/Oz. We will not do this  inline for context sensistive PGO (when
// IsCS is true).
if (!isOptimizingForSize(Level) &amp;&amp; !IsCS) {
  InlineParams IP;

  // In the old pass manager, this is a cl::opt. Should still this be one?
  IP.DefaultThreshold = 75;

  // FIXME: The hint threshold has the same value used by the regular inliner.
  // This should probably be lowered after performance testing.
  // FIXME: this comment is cargo culted from the old pass manager, revisit).
  IP.HintThreshold = 325;

  CGSCCPassManager CGPipeline(DebugLogging);

  CGPipeline.addPass(InlinerPass(IP));

  FunctionPassManager FPM;
  FPM.addPass(SROA());
  FPM.addPass(EarlyCSEPass());    // Catch trivial redundancies.
  FPM.addPass(SimplifyCFGPass()); // Merge &amp; remove basic blocks.
  FPM.addPass(InstCombinePass()); // Combine silly sequences.
  invokePeepholeEPCallbacks(FPM, Level);

  CGPipeline.addPass(createCGSCCToFunctionPassAdaptor(std::move(FPM)));

  MPM.addPass(createModuleToPostOrderCGSCCPassAdaptor(std::move(CGPipeline)));
}</pre>
</div>
</div>
<div class="paragraph">
<p><code>PassBuilder</code> で指定されているのはこれだけだが、パス内部で最適化レベルの
処理を行うパスについてはこの限りでない。例えば <code>LoopUnrollPass</code> は
<code>OptLevel</code> を引数として受け取り、その値に応じて内部的なしきい値を変える。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_即値命令を追加する">即値命令を追加する</h2>
<div class="sectionbody">
<div class="paragraph">
<p>RV16Kv3に向けて <code>lsi/andi/ori/xori/lsli/lsri/asri</code> 命令を追加すると
次のように変化した。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/rv16kv2_imm_opt.png" alt="rv16kv2 imm opt">
</div>
</div>
<div class="paragraph">
<p>4bitに収まるにも関わらず <code>lsi</code> ではなく <code>li</code> を使用しているのは、
リンク時に値が決まるためであると推察される。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_リンク時最適化lto_link_time_optimizationをかける">リンク時最適化（LTO; Link Time Optimization）をかける</h2>
<div class="sectionbody">
<div class="paragraph">
<p>各ファイルをコンパイルする際にLLVM bitcodeでとどめ、
必要なすべてのファイルをリンク時にconcatした上で機械語へ変換することによって、
オブジェクトファイル間をまたいで不要なコードの削除などの
最適化を行うことができる。これをLTOという。
LTOはClangに <code>-flto</code> オプションを渡すことで実行することができる。</p>
</div>
<div class="paragraph">
<p>LLDにLLVM bitcodeを渡すため、Clangの <code>RV16KToolChain</code> に次を追加。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>bool HasNativeLLVMSupport() const override { return true; }</pre>
</div>
</div>
<div class="paragraph">
<p>またLLDがLLVM bitcodeから <code>e_machine</code> を特定できるように、
<code>lld/ELF/InputFiles</code> の <code>getBitcodeMachineKind</code> にRV16Kのための <code>case</code> を追加。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>case Triple::rv16k:
  return EM_RV16K;</pre>
</div>
</div>
<div class="paragraph">
<p>これでClangに <code>-flto</code> オプションが渡せるようになる。</p>
</div>
<div class="paragraph">
<p>……なるのだが、目立った最適化は得られなかった。むしろ <code>-Oz</code> オプションを
つけているにもかかわらずコードサイズは大きくなった。理由不明。TODO</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_末尾再帰に対応する">末尾再帰に対応する</h2>
<div class="sectionbody">
<div class="paragraph">
<p>RISC-Vは末尾再帰に対応している<a href="#llvm_phabricator-d45395">[125]</a>。
<code>PseudoTAIL</code> 擬似命令をアセンブリレベルで導入した上で、これをコード生成させている。</p>
</div>
<div class="paragraph">
<p>例えば次のようなコードをLLVM IRにコンパイルすると <code>tail call</code> が出現する。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cat foo.c
int factorial(int x)
{
    if (x &gt; 0)
        return x * factorial(x - 1);
    else
        return 1;
}

int test_tailcall(int a)
{
    return factorial(a);
}

$ ./rv16k-clang -c -S -O1 foo.c -o foo.ll -emit-llvm

$ cat foo.s

...

; Function Attrs: nounwind readnone
define dso_local i16 @factorial(i16 %x) local_unnamed_addr #0 {
entry:
  %cmp3 = icmp sgt i16 %x, 0
  br i1 %cmp3, label %if.then, label %return

if.then:                                          ; preds = %entry, %if.then
  %x.tr5 = phi i16 [ %sub, %if.then ], [ %x, %entry ]
  %accumulator.tr4 = phi i16 [ %mul, %if.then ], [ 1, %entry ]
  %sub = add nsw i16 %x.tr5, -1
  %mul = mul nsw i16 %x.tr5, %accumulator.tr4
  %cmp = icmp sgt i16 %sub, 0
  br i1 %cmp, label %if.then, label %return

return:                                           ; preds = %if.then, %entry
  %accumulator.tr.lcssa = phi i16 [ 1, %entry ], [ %mul, %if.then ]
  ret i16 %accumulator.tr.lcssa
}

; Function Attrs: nounwind readnone
define dso_local i16 @test_tailcall(i16 %a) local_unnamed_addr #0 {
entry:
  %call = tail call i16 @factorial(i16 %a)
  ret i16 %call
}

...</pre>
</div>
</div>
<div class="paragraph">
<p>ちなみに <code>factorial</code> の方は（関数呼び出しでなく）単なるループに展開
されていることにも注意が必要である。また <code>-O2</code> で最適化すると
<code>factorial</code> がインライン展開されるため <code>tail call</code> はなくなってしまう。</p>
</div>
<div class="paragraph">
<p>さてTCOを行うためには、まず i) <code>tail</code> が付与された関数呼び出しが
実際に末尾関数呼び出し（tail call）であるかどうかを判断し ii) tail callである場合は
<code>RV16KISD::CALL</code> ではなく <code>RV16KISD::TAIL</code> を発行し iii)
これに対してパターンマッチを行い <code>J</code> ないし <code>JR</code> 命令に変換する必要がある。 i) と ii)
は <code>RV16KTargetLowering::LowerCall</code> にて行い iii) はTableGenファイルとして記述する。</p>
</div>
<div class="paragraph">
<p>まず iii) から実装する。
はじめ次のように定義したところ <code>Tail</code> にパターンマッチしなかった。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>def PseudoTAIL : Pseudo&lt;(outs), (ins simm16_lsb0_j:$imm), []&gt;,
                   PseudoInstExpansion&lt;(J simm16_lsb0_j:$imm)&gt;;

...

def : Pat&lt;(Tail (iPTR tglobaladdr:$dst)),
          (PseudoTAIL texternalsym:$dst)&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p><code>ins simm16_lsb0_j</code> を <code>ins simm16_lsb0</code> としたところうまくいった。
<code>PseudoBR</code> のときと同様の症状に見えるが対処方法が微妙に違う。
<code>ImmLeaf</code> を継承した型でないと <code>tglobaladdr</code> などにパターンマッチできない？
しかしRISC-Vの <code>bare_symbol</code> などはこの限りでないように見える。
全くわからない。TODO 結局 <code>tglobaladdr</code> などが即値のパターンにマッチするのが
すべての元凶のように思えるが……。</p>
</div>
<div class="paragraph">
<p>RISC-Vでは <code>Tail</code> のパターンマッチに <code>(iPTR &#8230;&#8203;)</code> を挟んでいる。
RV16Kは16bitアーキテクチャなので<sup class="footnote">[<a id="_footnoteref_143" class="footnote" href="#_footnotedef_143" title="View footnote.">143</a>]</sup>、
これは <code>(i16 &#8230;&#8203;)</code> と等価であると推察される。
実際これを <code>(i16 &#8230;&#8203;)</code> と書き換えてもテストに通った。一方で <code>(i8 &#8230;&#8203;)</code> や <code>(i32 &#8230;&#8203;)</code> では
動作しなかった。一方で <code>iPTR</code> を単純に削除し <code>&#8230;&#8203;</code> の部分のみとしても動作した。
そこでとりあえずはこれを削除した形で記述した。</p>
</div>
<div class="paragraph">
<p><code>Tail</code> がレジスタを取る場合、パターンマッチによって <code>PseudoTAILIndirect</code> に変換される。
ここで使用できるレジスタはcaller-savedなレジスタに限られる。
というのも、RISC-Vバックエンドのコメントによれば、tail callが行われる直前には、
callee-savedなレジスタの値の復帰が行われるため、分岐先のアドレスを保持する
レジスタの中身が打ち消されてしまうからである。
そこで新たに <code>GPRTC</code> というレジスタクラスを定義し <code>PseudoTAILIndirect</code> はこれをオペランドと
している。</p>
</div>
<div class="paragraph">
<p>次に ii) を記述する。 <code>IsTailCall</code> が立っている場合は、通常の関数呼び出しを表す
<code>CALLSEQ_START/CALL/CALLSEQ_END</code> の出力を抑止し、代わりに <code>TAIL</code> を出力する。
なおtail callの場合preserved maskをオペランドに追加する必要はない。
おそらくこれはtail call後に実行される同関数中のコードが存在しないためであると考えられる。
したがってtail callが存在する場合のpreserved mask追加も害はない。
実際Mipsバックエンドは追加している。
またRV16Kバックエンドで試しても、テストを通過した。</p>
</div>
<div class="paragraph">
<p>最後に i) を実装する。具体的には
<code>RV16KTargetLowering::IsEligibleForTailCallOptimization</code> の実装を行う。
この関数は、LLVM IRでは <code>tail call</code> となっている関数について、
本当にtail callしてよいかを判断する。</p>
</div>
<div class="paragraph">
<p>関数宣言がweak symbol<a href="#wikipedia-weak_symbol">[143]</a>の場合tail callの挙動は実装依存となるため
行わない。</p>
</div>
<div class="paragraph">
<p>tail callのcallerが保存するレジスタをcalleeも保存しているかをチェックしている。</p>
</div>
<div class="paragraph">
<p>構造体をbyvalで引数として渡す関数をtail callしたい場合一筋縄ではいかない。
というのもこのような場合、構造体はcaller側のstackに保存され、
そのポインタが引数として渡される。しかしtail callでは
calleeがcallerのスタック領域を使用する（これによってメモリ使用量を削減する）ため、
ナイーブな実装では引数として渡された構造体を壊してしまう。
実際これを処理するためのwork-aroundは存在し、
x86向けバックエンドでは使用されているようだが、
RISC-Vを始めとする他のバックエンドでは、byvalで引数を渡す場合は
単にtail callしないという選択をしている。RV16Kもこれに従う。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_構造体を正しく扱う">構造体を正しく扱う</h2>
<div class="sectionbody">
<div class="paragraph">
<p>次のようなテストコードを正しく動かしたい。これを動かすと <code>0</code> が
返却されるはずだが、現時点では <code>-1</code> が返ってきてしまう。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>struct hoge {
    int x, y;
};

struct hoge piyo(struct hoge h)
{
    if (h.x &lt; 0) return h;

    h.x -= 1;
    h.y -= 1;
    struct hoge ret = piyo(h);
    return ret;
}

int main()
{
    struct hoge h = {1, 2};
    return piyo(h).y;
}</pre>
</div>
</div>
<div class="paragraph">
<p>上のコードをコンパイルすると、
<code>piyo</code> の戻り値から <code>y</code> を取り出すために「 <code>piyo</code> の戻り値の構造体が入った
アドレスに <code>2</code> を <code>or</code> して <code>y</code> のアドレスとする」というアセンブリが
出力される。ここで <code>or</code> は <code>add</code> の代替として機能することが
期待されている。これは <code>bin/llc</code> に <code>-debug</code> をつけると、
次のように変換されていることから分かる。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Creating new node: t17: ch,glue = callseq_start t15, TargetConstant:i16&lt;0&gt;, TargetConstant:i16<b class="conum">(0)</b>
Creating new node: t19: ch,glue = CopyToReg t17, Register:i16 $x8, FrameIndex:i16<b class="conum">(0)</b>
Creating new node: t21: ch,glue = CopyToReg t19, Register:i16 $x9, FrameIndex:i16&lt;1&gt;, t19:1
Creating new node: t24: ch,glue = RV16KISD::CALL t21, TargetGlobalAddress:i16&lt;void (%struct.hoge*, %struct.hoge*)* @piyo&gt; 0, Register:i16 $x8, Register:i16 $x9, RegisterMask:Untyped, t21:1
Creating new node: t25: ch,glue = callseq_end t24, TargetConstant:i16&lt;0&gt;, TargetConstant:i16&lt;0&gt;, t24:1
Creating new node: t26: i16 = add nuw FrameIndex:i16&lt;0&gt;, Constant:i16<b class="conum">(2)</b>
Creating new node: t27: i16,ch = load&lt;(dereferenceable load 2 from %ir.y, !tbaa !7)&gt; t25, t26, undef:i16

...

Combining: t26: i16 = add nuw FrameIndex:i16&lt;0&gt;, Constant:i16<b class="conum">(2)</b>
Creating new node: t30: i16 = or FrameIndex:i16&lt;0&gt;, Constant:i16<b class="conum">(2)</b>
 ... into: t30: i16 = or FrameIndex:i16&lt;0&gt;, Constant:i16<b class="conum">(2)</b></pre>
</div>
</div>
<div class="paragraph">
<p>この変換は <code>llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp</code> の
<code>visitADD</code> にて次のように行われている。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>// fold (a+b) -&gt; (a|b) iff a and b share no bits.
if ((!LegalOperations || TLI.isOperationLegal(ISD::OR, VT)) &amp;&amp;
    DAG.haveNoCommonBitsSet(N0, N1))
  return DAG.getNode(ISD::OR, DL, VT, N0, N1);</pre>
</div>
</div>
<div class="paragraph">
<p>しかし実際には、RV16Kにおいて <code>piyo</code> の戻り値が格納されるアドレスは2バイトで
アラインされるため、このような <code>add</code> を <code>or</code> に変換する操作は正しく
動かない場合がある。 <code>visitADD</code> では
<code>DAG.haveNoCommonBitsSet</code> を呼び出すことでこのチェックを
行っているように見えるが、frame indexが対象の場合は、
このチェックをすり抜けてしまう（後述）<sup class="footnote">[<a id="_footnoteref_144" class="footnote" href="#_footnotedef_144" title="View footnote.">144</a>]</sup>。</p>
</div>
<div class="paragraph">
<p>これを解決するには i) このような <code>or</code> への変換を無効化したり ii) frame indexに
対する即値の <code>or</code> をメモリ操作のdisplacementとする などが考えられる。
RV16Kにおいてはこのような場合に <code>or</code> へ変換することはそもそも間違っている
ため i) の対処が本来である。しかしLLVMにおいてこれをどのように
無効化すればよいか判然としない（後述；TODO）。
そこで今回は ii) によって対処する。
なおこれはRISC-Vも採用している手法である<a href="#github_riscv-llvm_patch_22">[91]</a>
<sup class="footnote">[<a id="_footnoteref_145" class="footnote" href="#_footnotedef_145" title="View footnote.">145</a>]</sup>。</p>
</div>
<div class="paragraph">
<p>具体的には<a href="#github_riscv-llvm_patch_22">[91]</a>を参考にして次のような
パターンを追加する。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>def : Pat&lt;(load (IsOrAdd AddrFI:$rs1, simm16_lsb0:$imm16)),
          (LW AddrFI:$rs1, simm16_lsb0:$imm16)&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>ここで使用される <code>IsOrAdd</code> は次のように定義される述語である。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>def IsOrAdd: PatFrag&lt;(ops node:$A, node:$B), (or node:$A, node:$B), [{
  return isOrEquivalentToAdd(N);
}]&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>これでうまく動作する。</p>
</div>
<div class="paragraph">
<p>さてではなぜ上記のようなチェックが機能しないのか。
それは<strong>具体的な値が確定するまでframe indexは <code>0</code> として扱われて
いるから</strong>である（多分）。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_risc_vとrv16kの比較">RISC-VとRV16Kの比較</h2>
<div class="sectionbody">
<div class="paragraph">
<p>生成されるオブジェクトのサイズの比較を行いたい。
これはRV16KがRISC-Vと比べてどの程度今回の目的（ROMが極めて小さい）に
特化出来ているかの指標の1つになりうる。</p>
</div>
<div class="paragraph">
<p>RV16KとRISC-Vのバックエンドの両方でテスト用Cコードを
オブジェクトファイルにコンパイルし、両者の <code>.text</code> 部分のサイズを
取得する。掛け算・割り算の扱い方や、構造体値渡しのconventionなど
単純に比較できない要素は数多くあるが、1つの指標にはなる。</p>
</div>
<div class="paragraph">
<p>LLVMをビルドしたディレクトリで、次のようなワンライナーを実行する。
なおこれの実行には、RISC-Vクロスコンパイル用にビルドしたGCCが必要である。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ls ~/ano/secure_vm/rv16k-test/build_and_test/test/00*.c | \
while read line; do \
    echo $(basename $line); \
    echo "\tRV16K          $(bin/clang -target rv16k -Oz -c -o - $line | \
                     bin/llvm-readelf -S | \
                     grep " .text" | \
                     sed -E 's/ +/ /g' | \
                     cut -d' ' -f8)"; \
    echo "\tRV32EC (GCC)   $(~/workspace/riscv-gnu-toolchain/build/bin/riscv32-unknown-elf-gcc -march=rv32ec -mabi=ilp32e -Os -c -o _tetete.o $line &amp;&amp; \
                      bin/llvm-readelf -S _tetete.o | \
                      sed -E 's/ +/ /g' | \
                      grep " .text" | \
                      cut -d' ' -f8 | \
                      awk '{s+=strtonum("0x"$1)} END {printf "%06x",s}' )"; rm -f _tetete.o; \
    echo "\tRV32IC (LLVM)  $(bin/clang -target riscv32 -march=rv32ic -Oz -c -o - $line | \
                      bin/llvm-readelf -S | \
                      grep " .text" | \
                      sed -E 's/ +/ /g' | \
                      cut -d' ' -f8)"; \
    echo "\tRV32IC (GCC)   $(~/workspace/riscv-gnu-toolchain/build/bin/riscv32-unknown-elf-gcc -march=rv32ic -mabi=ilp32e -Os -c -o _tetete.o $line &amp;&amp; \
                      bin/llvm-readelf -S _tetete.o | \
                      sed -E 's/ +/ /g' | \
                      grep " .text" | \
                      cut -d' ' -f8 | \
                      awk '{s+=strtonum("0x"$1)} END {printf "%06x",s}' )"; rm -f _tetete.o; \
done</pre>
</div>
</div>
<div class="paragraph">
<p>結果は次のようであった。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>0001.c
    RV16K          000006
    RV32IC (LLVM)  000006
    RV32EC (GCC)   000006
0002-fib.c
    RV16K          00003e
    RV32IC (LLVM)  000044
    RV32EC (GCC)   00003c
0003-bf.c
    RV16K          000162
    RV32IC (LLVM)  0000f2
    RV32EC (GCC)   0001aa
0004-lisp.c
    RV16K          000176
    RV32IC (LLVM)  00016e
    RV32EC (GCC)   00017e
0005-prime.c
    RV16K          00009c
    RV32IC (LLVM)  000082
    RV32EC (GCC)   000082
0006-editdis.c
    RV16K          0000d6
    RV32IC (LLVM)  00009e
    RV32EC (GCC)   0000de
0007-perceptron.c
    RV16K          000148
    RV32IC (LLVM)  000132
    RV32EC (GCC)   000134
0008-rpn.c
    RV16K          000110
    RV32IC (LLVM)  0000e4
    RV32EC (GCC)   0000e2
0009-gameoflife.c
    RV16K          0001c4
    RV32IC (LLVM)  000166
    RV32EC (GCC)   000130
0010-struct.c
    RV16K          000100
    RV32IC (LLVM)  000090
    RV32EC (GCC)   0000a0</pre>
</div>
</div>
<div class="paragraph">
<p>あるオブジェクトファイルに登場する命令の種類と数を調べるときは
次のようにする。RISC-Vの場合 <code>-riscv-no-aliases</code> をつけることで、
圧縮命令に対して <code>c.</code> プレフィクスを出力してくれる。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ bin/llvm-objdump -d -riscv-no-aliases rpn-rv32ec.o | cut -f3 | egrep -v "^$|:" | sort | uniq -c | sort -nr</pre>
</div>
</div>
<div class="sect2">
<h3 id="_lsiandiorixorilslilsriasri_など即値命令を追加する"><code>lsi/andi/ori/xori/lsli/lsri/asri</code> など即値命令を追加する</h3>
<div class="literalblock">
<div class="content">
<pre>0001.c
    RV16K          000006
    RV32IC (LLVM)  000006
    RV32EC (GCC)   000006
0002-fib.c
    RV16K          00003a
    RV32IC (LLVM)  000044
    RV32EC (GCC)   00003c
0003-bf.c
    RV16K          000146
    RV32IC (LLVM)  0000f2
    RV32EC (GCC)   0001aa
0004-lisp.c
    RV16K          000158
    RV32IC (LLVM)  00016e
    RV32EC (GCC)   00017e
0005-prime.c
    RV16K          00008c
    RV32IC (LLVM)  000082
    RV32EC (GCC)   000082
0006-editdis.c
    RV16K          0000d0
    RV32IC (LLVM)  00009e
    RV32EC (GCC)   0000de
0007-perceptron.c
    RV16K          000136
    RV32IC (LLVM)  000132
    RV32EC (GCC)   000134
0008-rpn.c
    RV16K          000110
    RV32IC (LLVM)  0000e4
    RV32EC (GCC)   0000e2
0009-gameoflife.c
    RV16K          0001be
    RV32IC (LLVM)  000166
    RV32EC (GCC)   000130
0010-struct.c
    RV16K          0000fa
    RV32IC (LLVM)  000090
    RV32EC (GCC)   0000a0</pre>
</div>
</div>
<div class="paragraph">
<p>多少下がる。</p>
</div>
</div>
<div class="sect2">
<h3 id="_lw0_と_sw0_を追加する"><code>lw0</code> と <code>sw0</code> を追加する</h3>
<div class="paragraph">
<p><code>lw</code> や <code>sw</code> のoffsetが <code>0</code> の場合と同等の2byte命令を追加。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>0001.c
    RV16K          000006
    RV32IC (LLVM)  000006
    RV32EC (GCC)   000006
0002-fib.c
    RV16K          00003a
    RV32IC (LLVM)  000044
    RV32EC (GCC)   00003c
0003-bf.c
    RV16K          00013e
    RV32IC (LLVM)  0000f2
    RV32EC (GCC)   0001aa
0004-lisp.c
    RV16K          000144
    RV32IC (LLVM)  00016e
    RV32EC (GCC)   00017e
0005-prime.c
    RV16K          000086
    RV32IC (LLVM)  000082
    RV32EC (GCC)   000082
0006-editdis.c
    RV16K          0000c8
    RV32IC (LLVM)  00009e
    RV32EC (GCC)   0000de
0007-perceptron.c
    RV16K          000120
    RV32IC (LLVM)  000132
    RV32EC (GCC)   000134
0008-rpn.c
    RV16K          0000f8
    RV32IC (LLVM)  0000e4
    RV32EC (GCC)   0000e2
0009-gameoflife.c
    RV16K          0001be
    RV32IC (LLVM)  000166
    RV32EC (GCC)   000130
0010-struct.c
    RV16K          0000e8
    RV32IC (LLVM)  000090
    RV32EC (GCC)   0000a0</pre>
</div>
</div>
<div class="paragraph">
<p>そこそこ縮んだ。</p>
</div>
</div>
<div class="sect2">
<h3 id="_addi_の即値フィールドを6bitに増やす"><code>addi</code> の即値フィールドを6bitに増やす</h3>
<div class="paragraph">
<p>新たに <code>addib</code> 命令を追加し、即値フィールドを6bitとする。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>0001.c
    RV16K          000006
    RV32IC (LLVM)  000006
    RV32EC (GCC)   000006
0002-fib.c
    RV16K          00003a
    RV32IC (LLVM)  000044
    RV32EC (GCC)   00003c
0003-bf.c
    RV16K          000136
    RV32IC (LLVM)  0000f2
    RV32EC (GCC)   0001aa
0004-lisp.c
    RV16K          00013c
    RV32IC (LLVM)  00016e
    RV32EC (GCC)   00017e
0005-prime.c
    RV16K          00007e
    RV32IC (LLVM)  000082
    RV32EC (GCC)   000082
0006-editdis.c
    RV16K          0000c0
    RV32IC (LLVM)  00009e
    RV32EC (GCC)   0000de
0007-perceptron.c
    RV16K          000114
    RV32IC (LLVM)  000132
    RV32EC (GCC)   000134
0008-rpn.c
    RV16K          0000f8
    RV32IC (LLVM)  0000e4
    RV32EC (GCC)   0000e2
0009-gameoflife.c
    RV16K          0001be
    RV32IC (LLVM)  000166
    RV32EC (GCC)   000130
0010-struct.c
    RV16K          0000d0
    RV32IC (LLVM)  000090
    RV32EC (GCC)   0000a0</pre>
</div>
</div>
<div class="paragraph">
<p>微妙。</p>
</div>
</div>
<div class="sect2">
<h3 id="_add3_rd_rs1_rs2_を追加する"><code>add3 rd, rs1, rs2</code> を追加する</h3>
<div class="paragraph">
<p>3オペランド命令を追加する。次のようにパターンマッチさせる。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>def : Pat&lt;(add GPRC:$rs1, GPRC:$rs2), (ADD3 GPRC:$rs1, GPRC:$rs2)&gt;;
def : Pat&lt;(add GPR:$rs1, GPR:$rs2), (ADD GPR:$rs1, GPR:$rs2)&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>結果は次の通り。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>0001.c
    RV16K          000006
    RV32IC (LLVM)  000006
    RV32EC (GCC)   000006
0002-fib.c
    RV16K          000038
    RV32IC (LLVM)  000044
    RV32EC (GCC)   00003c
0003-bf.c
    RV16K          000134
    RV32IC (LLVM)  0000f2
    RV32EC (GCC)   0001aa
0004-lisp.c
    RV16K          00013a
    RV32IC (LLVM)  00016e
    RV32EC (GCC)   00017e
0005-prime.c
    RV16K          000082
    RV32IC (LLVM)  000082
    RV32EC (GCC)   000082
0006-editdis.c
    RV16K          0000be
    RV32IC (LLVM)  00009e
    RV32EC (GCC)   0000de
0007-perceptron.c
    RV16K          000110
    RV32IC (LLVM)  000132
    RV32EC (GCC)   000134
0008-rpn.c
    RV16K          000108
    RV32IC (LLVM)  0000e4
    RV32EC (GCC)   0000e2
0009-gameoflife.c
    RV16K          0001a6
    RV32IC (LLVM)  000166
    RV32EC (GCC)   000130
0010-struct.c
    RV16K          0000d0
    RV32IC (LLVM)  000090
    RV32EC (GCC)   0000a0</pre>
</div>
</div>
<div class="paragraph">
<p><code>gameoflife.c</code> のサイズは若干小さくなるが、むしろ <code>rpn.c</code> などサイズが大きく
なっているバイナリがあることに注意が必要。
TableGenによるパターンマッチでは最初に書いたパターンを優先して採用するため、
このような場合では <code>add3</code> のみが
使用され<sup class="footnote">[<a id="_footnoteref_146" class="footnote" href="#_footnotedef_146" title="View footnote.">146</a>]</sup>、レジスタの使用に制限が発生したことが
原因と思われる。</p>
</div>
<div class="paragraph">
<p>2オペランドの命令を基調としているところに3オペランドの命令を追加するのは
難しい。RISC-VのRV32CはRV32Iのコードサイズを削減することが主目的であるため、
RV32IからRV32Cへの1:1対応として処理すれば良い。しかしRV16Kは2オペランドの
体系のため、この一部を3オペランドに変換するというのは非自明な処理である。
というのも、命令選択の時点では、レジスタクラスは分かっても、
どのレジスタを使用するかはわからない。そもそも <code>add3</code> が適用可能かどうかが
わからないのである。</p>
</div>
</div>
<div class="sect2">
<h3 id="_irレベルで定数読み込みのコストを考慮に入れる">IRレベルで定数読み込みのコストを考慮に入れる</h3>
<div class="paragraph">
<p>より効率的なコード生成のために、IRレベルで行われる変形（transformation）に
対してコード生成時の情報を提供する。具体的にはconstant materializingの
コストを伝えるようにする。これには <code>TargetTransformInfo</code> の
RV16K版を定義する必要がある。</p>
</div>
<div class="paragraph">
<p>IRレベルにおける「コスト」は、通常の命令（ <code>add</code> など）を1として
考える。これは加算乗除ができる値として捉える必要がある。
<code>enum TargetCostConstants</code> のコメントに詳細がある。</p>
</div>
<div class="paragraph">
<p>RISC-VではLLVM9にて <code>TargetTransformInfo</code> が定義される。これを参考にする。</p>
</div>
<div class="paragraph">
<p>基本的には即値のサイズと命令の種類ごとに「基本コスト」の何倍かを
記述する。ここで「基本コスト」は実質的に2バイトのことである。</p>
</div>
<div class="paragraph">
<p><code>LLVMBuild.txt</code> の <code>required_libraries</code> に <code>Analysis</code> を追加する必要があった。
理由不明。TODO</p>
</div>
<div class="paragraph">
<p>サイズベンチマークをしたところ、全く減らなかった。悲しい。</p>
</div>
</div>
<div class="sect2">
<h3 id="_サイズ最適化のときはloop_unrollingを抑止する">サイズ最適化のときはloop-unrollingを抑止する</h3>
<div class="paragraph">
<p>ARMがloop unrollingを明示的に抑止しているので、それに習う。</p>
</div>
<div class="paragraph">
<p><code>RV16KTTIImpl::getUnrollingPreferences</code> を定義し、この中でloop unrollingを無効化する。</p>
</div>
<div class="paragraph">
<p>全く効果がなかったのでrevertした。</p>
</div>
</div>
<div class="sect2">
<h3 id="_globalmergepass_を追加する"><code>GlobalMergePass</code> を追加する</h3>
<div class="paragraph">
<p>ARMが使っているパスで、グローバル変数を一つにまとめることでregister pressureを下げる。
<code>lw/sw</code> のdisplacementを有効活用できるのではないかと追加したが効果なし。revert.</p>
</div>
</div>
<div class="sect2">
<h3 id="_machinescheduler_を有効化する"><code>MachineScheduler</code> を有効化する</h3>
<div class="paragraph">
<p>なんかRISC-Vが最近有効化してたからしてみた。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>bool enableMachineScheduler() const override { return true; }</pre>
</div>
</div>
<div class="paragraph">
<p>コードサイズが増えた。revert.</p>
</div>
</div>
<div class="sect2">
<h3 id="_islegaladdressingmodeislegalicmpimmediateislegaladdimmediate_を定義"><code>isLegalAddressingMode/isLegalICmpImmediate/isLegalAddImmediate</code> を定義</h3>
<div class="paragraph">
<p>アドレスモード・ <code>cmpi</code> が取れる即値幅・ <code>addi</code> が取れる即値幅を、
LLVM IRレベルで利用できるように定義。コードサイズに効果なし。
これらに関するRISC-Vのコミットでも「LLVMに対して正しいbackendの情報を
伝えることは間違っていないと思うから追加するけど、このコミットのご利益を表現する
テストは書けないよ」みたいなことが書いてある。</p>
</div>
</div>
<div class="sect2">
<h3 id="_iszextfree_を定義"><code>isZextFree</code> を定義</h3>
<div class="paragraph">
<p>符号なし8bitの値をメモリから読み込む際に <code>zext</code> が使われないことを保証する。</p>
</div>
<div class="paragraph">
<p>実装したが効果なし。revert.</p>
</div>
</div>
<div class="sect2">
<h3 id="_再実体化remat_rematerializationの実装">再実体化（remat; rematerialization）の実装</h3>
<div class="paragraph">
<p>再実体化とは、複数回使用されるような値を一度だけ計算しレジスタやメモリに格納しておく
共通部分式除去とは<strong>逆に</strong>、毎回計算することにより実行時間を減少させたり、
レジスタ・メモリ使用量に余裕をもたせる最適化である<a href="#wikipedia-remat">[144]</a>
<sup class="footnote">[<a id="_footnoteref_147" class="footnote" href="#_footnotedef_147" title="View footnote.">147</a>]</sup>。RISC-Vによる実装を参考にする<a href="#llvm_phabricator-d46182">[145]</a>。</p>
</div>
<div class="paragraph">
<p>LLVMでは結局、即値を即値ロードの命令に変換することをmaterializeと呼び、
その逆をrematerializeと読んでいるようだ？</p>
</div>
<div class="paragraph">
<p>やることは単純で <code>li</code> と <code>lsi</code> に <code>isReMaterializable</code> フラグを立てれば良い。
<a href="#llvm_phabricator-d46182">[145]</a>でも指摘されているように、
このフラグが立ったからといって必ずrematが行われるわけではなく、
あくまでヒントとして使用される。</p>
</div>
<div class="paragraph">
<p>コードサイズは変化しなかった。revert.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_llvm9に移行する">LLVM9に移行する</h2>
<div class="sectionbody">
<div class="paragraph">
<p>LLVM9が9/19に公開された<sup class="footnote">[<a id="_footnoteref_148" class="footnote" href="#_footnotedef_148" title="View footnote.">148</a>]</sup>。そこで、これまでLLVM8にて開発してきた
RV16KバックエンドをLLVM9に対応させたい。</p>
</div>
<div class="paragraph">
<p>RISC-Vバックエンドを独自に作っている<a href="#fpga_develop_diary">[44]</a>では
LLVM8から9にポートした際の記事が公開されている<a href="#fpga_develop_diary-to_llvm9">[147]</a>。</p>
</div>
<div class="paragraph">
<p>まず <code>rv16k-toward-v3</code> ブランチをLLVM9とマージする。これには <code>git rebase --onto</code> が使える。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ git rebase --onto llvmorg-9.0.0 llvmorg-8.0.0 rv16k-toward-v3</pre>
</div>
</div>
<div class="paragraph">
<p>次にこれをビルドする。RISC-Vはもはやexperimentalではない。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cmake -G Ninja \
    -DLLVM_ENABLE_PROJECTS="clang;lld" \
    -DCMAKE_BUILD_TYPE="Debug" \
    -DBUILD_SHARED_LIBS=True \
    -DLLVM_USE_SPLIT_DWARF=True \
    -DLLVM_OPTIMIZED_TABLEGEN=True \
    -DLLVM_BUILD_TESTS=True \
    -DCMAKE_C_COMPILER=clang \
    -DCMAKE_CXX_COMPILER=clang++ \
    -DLLVM_USE_LINKER=lld \
    -DLLVM_TARGETS_TO_BUILD="X86;RISCV" \
    -DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD="RV16K" \
    ~/ano/secure_vm/llvm-project/llvm
    ../llvm
$ cmake --build .</pre>
</div>
</div>
<div class="paragraph">
<p>もちろんLLVM8と9で異なっている部分があるため、ビルドがコケる。適宜修正する。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>LLVM8まではレジスタは単なる <code>unsigned</code> の整数値であったが、
これをラップするものとして新たに <code>Register</code> クラスが導入された<a href="#llvm_phabricator-rl364191">[149]</a>。
具体的には <code>MachineOperand::getReg</code> の戻り値が <code>Register</code> に変更され、
それに依存する他の部分も変更されている。RV16Kバックエンドの場合は
<code>RV16KRegisterInfo::getFrameRegister</code> の戻り値の型のみを変更した。</p>
</li>
<li>
<p><code>AsmPrinter</code> の <code>AsmVariant</code> を活用しているバックエンドはx86のみだったため
削除されたらしい<a href="#llvm_phabricator-d60488">[148]</a>。合わせて削除する。</p>
</li>
<li>
<p>LLDにおけるコーディング規約が変更され、
変数名が小文字から始まるようになった<a href="#llvm_phabricator-d64121">[150]</a>
<sup class="footnote">[<a id="_footnoteref_149" class="footnote" href="#_footnotedef_149" title="View footnote.">149</a>]</sup>。これに伴い、
継承元のメンバ変数を参照する部分などでは書き換えを要する。具体的には
<code>RV16K::RV16K</code> で上書きする <code>NoneRel</code> メンバ変数などが該当する。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以上の変更によりビルドが可能になった。コードサイズのベンチマークは次のように変化した。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>0001.c
    RV16K          000006
    RV32EC (GCC)   000006
    RV32IC (LLVM)  000008
    RV32IC (GCC)   000006
0002-fib.c
    RV16K          00003a
    RV32EC (GCC)   00003c
    RV32IC (LLVM)  000046
    RV32IC (GCC)   00003c
0003-bf.c
    RV16K          00013a
    RV32EC (GCC)   0001aa
    RV32IC (LLVM)  0000e6
    RV32IC (GCC)   0000ec
0004-lisp.c
    RV16K          00013c
    RV32EC (GCC)   00017e
    RV32IC (LLVM)  00017a
    RV32IC (GCC)   00017e
0005-prime.c
    RV16K          00007a
    RV32EC (GCC)   000082
    RV32IC (LLVM)  000082
    RV32IC (GCC)   000082
0006-editdis.c
    RV16K          0000c2
    RV32EC (GCC)   0000de
    RV32IC (LLVM)  0000b0
    RV32IC (GCC)   0000ca
0007-perceptron.c
    RV16K          00013c
    RV32EC (GCC)   000134
    RV32IC (LLVM)  000158
    RV32IC (GCC)   000134
0008-rpn.c
    RV16K          0000fc
    RV32EC (GCC)   0000e2
    RV32IC (LLVM)  0000d8
    RV32IC (GCC)   0000e2
0009-gameoflife.c
    RV16K          0001c6
    RV32EC (GCC)   000130
    RV32IC (LLVM)  000176
    RV32IC (GCC)   000130
0010-struct.c
    RV16K          0000d0
    RV32EC (GCC)   0000a0
    RV32IC (LLVM)  000092
    RV32IC (GCC)   0000a4</pre>
</div>
</div>
<div class="paragraph">
<p>悪化した<sup class="footnote">[<a id="_footnoteref_150" class="footnote" href="#_footnotedef_150" title="View footnote.">150</a>]</sup><sup class="footnote">[<a id="_footnoteref_151" class="footnote" href="#_footnotedef_151" title="View footnote.">151</a>]</sup><sup class="footnote">[<a id="_footnoteref_152" class="footnote" href="#_footnotedef_152" title="View footnote.">152</a>]</sup>。</p>
</div>
<div class="paragraph">
<p><code>git checkout</code> を使って、この変更が為される前後での挙動を見てみると、
<code>MachineBlockPlacement</code> への変更<a href="#llvm_phabricator-d43256">[153]</a>により
挙動が変わっている。</p>
</div>
<div class="paragraph">
<p>この変更は次のようなbasic blockのスケジューリングを行うパスである。
例えば次のようなCFGがあるとする。ここで <code>for.body</code> や <code>for.inc</code> から
2本の矢印が伸びているのは、そのbasic blockの内部または末尾から、
どちらかのbasic blockに分岐する（fall-throughを含む）ことを意味している。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>    entry
      |
      V
--&gt;for.body
|     |\
|     | \
|     |  \
|     | if.then3
|     |  /
|     | /
|     |/
---for.inc
      |
      V
for.cond.cleanup</pre>
</div>
</div>
<div class="paragraph">
<p>このとき、仮に次のように命令をスケジュールしたとする。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>entry
for.body
if.then3
for.inc
for.cond.cleanup</pre>
</div>
</div>
<div class="paragraph">
<p><code>if.then3</code> のbasic blockが一度も実行されないとすると、
ループは次のように回ることになる。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>   ...
-&gt; for.body
-&gt; （ジャンプ） for.inc
-&gt; （ジャンプ） for.body
   ...</pre>
</div>
</div>
<div class="paragraph">
<p>したがって、ループ中2回ジャンプする。</p>
</div>
<div class="paragraph">
<p>次に、以下のようにスケジュールしてみる。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>entry
for.inc
for.body
if.then3
for.cond.cleanup</pre>
</div>
</div>
<div class="paragraph">
<p>すると、ループは次のように回る。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>   ...
-&gt; for.body
-&gt; （ジャンプ） for.inc
-&gt; for.body
   ...</pre>
</div>
</div>
<div class="paragraph">
<p>したがって、ループ中のジャンプは1回で済むことになる。</p>
</div>
<div class="paragraph">
<p>しかし上記の図には<strong><code>entry</code> 末尾から <code>for.cond.cleanup</code> への条件分岐が
明記されていない</strong>。この分だけバイナリサイズとして不利である。</p>
</div>
<div class="paragraph">
<p><code>rpn.c</code> のbefore/afterを見てみると、このパスによるメリットは無いように見える。
過剰に変換を行っているということだろうか？</p>
</div>
<div class="paragraph">
<p><code>Bcc</code> の条件が絶対に成り立たないことを見抜いて <code>J</code> に変換する
機能がなくなっているっぽい。なんもわからん。TODO</p>
</div>
<div class="paragraph">
<p>ところでLLVM9では <code>llvm-objdump</code> の出力形式も変更されているようだ。謎。TODO</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_done_line">--- DONE LINE ---</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_mallocfreeの実装">malloc/freeの実装</h2>
<div class="sectionbody">
<div class="paragraph">
<p>bss領域の後ろからheapにすればいいが、512Bに収まるようなmalloc/freeが書けるかどうか。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_命令スケジューリングのための情報を命令に付加する">命令スケジューリングのための情報を命令に付加する</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Instruction itineraries</p>
</div>
<div class="paragraph">
<p>命令ごとのサイクル数などを考慮？<a href="#fox-llvm">[7]</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_アドレッシングモード">アドレッシング・モード</h2>
<div class="sectionbody">
<div class="paragraph">
<p>SparcやLanaiでは <code>reg + imm</code> のアドレッシング・モードを <code>ComplexPattern</code> を
使用してパターンマッチしている。すなわち <code>(load reg0, (add reg1 + imm))</code> に対する
パターンマッチを <code>SelectADDRri</code> などで <code>(lw reg0, reg1, imm)</code> に変換している？
これは <code>MIOperandInfo</code> と結びついて <code>ins</code> として扱われる。
従って <code>SelectInlineAsmMemoryOperand</code> では <code>(load reg, (add reg + imm))</code> に
対するパターンマッチを実施する必要がある？　のか？　分からん。TODO
これをどうやってビット列に結びつけているかまったくの不明。</p>
</div>
<div class="paragraph">
<p>一方RISC-Vでは明確なアドレッシング・モードの定義はなく、
TableGenレベルのパターンマッチで対応している。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_関数の可変長引数に対応する">関数の可変長引数に対応する</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="#github_riscv-llvm_patch_26">[133]</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_コマンドライン引数対応">コマンドライン引数対応</h2>
<div class="sectionbody">
<div class="paragraph">
<p>RAMをいじればいいはずだが面倒そう。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_デバッグ情報を出力する">デバッグ情報を出力する</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://github.com/lowRISC/riscv-llvm/blob/master/0047-RISCV-Initial-support-for-emitting-call-frame-inform.patch" class="bare">https://github.com/lowRISC/riscv-llvm/blob/master/0047-RISCV-Initial-support-for-emitting-call-frame-inform.patch</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_参照">参照</h2>
<div class="sectionbody">
<div class="ulist bibliography">
<ul class="bibliography">
<li>
<p><a id="github_riscv-llvm_docs_01"></a>[1] <a href="https://github.com/lowRISC/riscv-llvm/blob/master/docs/01-intro-and-building-llvm.mkd" class="bare">https://github.com/lowRISC/riscv-llvm/blob/master/docs/01-intro-and-building-llvm.mkd</a></p>
</li>
<li>
<p><a id="llvm_getting-started"></a>[2] <a href="https://llvm.org/docs/GettingStarted.html" class="bare">https://llvm.org/docs/GettingStarted.html</a></p>
</li>
<li>
<p><a id="clang_gettings-started"></a>[3] <a href="https://clang.llvm.org/get_started.html" class="bare">https://clang.llvm.org/get_started.html</a></p>
</li>
<li>
<p><a id="asciidoctor_user-manual"></a>[4] <a href="https://asciidoctor.org/docs/user-manual/" class="bare">https://asciidoctor.org/docs/user-manual/</a></p>
</li>
<li>
<p><a id="riscv"></a>[5] <a href="https://riscv.org/" class="bare">https://riscv.org/</a></p>
</li>
<li>
<p><a id="riscv_specifications"></a>[6] <a href="https://riscv.org/specifications/" class="bare">https://riscv.org/specifications/</a></p>
</li>
<li>
<p><a id="fox-llvm"></a>[7] 『きつねさんでもわかるLLVM〜コンパイラを自作するためのガイドブック〜』（柏木 餅子・風薬・矢上 栄一、株式会社インプレス、2013年）</p>
</li>
<li>
<p><a id="github_riscv-llvm_docs_02"></a>[8] <a href="https://github.com/lowRISC/riscv-llvm/blob/master/docs/02-starting-the-backend.mkd" class="bare">https://github.com/lowRISC/riscv-llvm/blob/master/docs/02-starting-the-backend.mkd</a></p>
</li>
<li>
<p><a id="github_riscv-llvm_patch_02"></a>[9] <a href="https://github.com/lowRISC/riscv-llvm/blob/master/0002-RISCV-Recognise-riscv32-and-riscv64-in-triple-parsin.patch" class="bare">https://github.com/lowRISC/riscv-llvm/blob/master/0002-RISCV-Recognise-riscv32-and-riscv64-in-triple-parsin.patch</a></p>
</li>
<li>
<p><a id="github_riscv-llvm"></a>[10] <a href="https://github.com/lowRISC/riscv-llvm" class="bare">https://github.com/lowRISC/riscv-llvm</a></p>
</li>
<li>
<p><a id="youtube_llvm-backend-development-by-example"></a>[11] <a href="https://www.youtube.com/watch?v=AFaIP-dF-RA" class="bare">https://www.youtube.com/watch?v=AFaIP-dF-RA</a></p>
</li>
<li>
<p><a id="msyksphinz_try-riscv64-llvm-backend"></a>[12] <a href="http://msyksphinz.hatenablog.com/entry/2019/01/02/040000_1" class="bare">http://msyksphinz.hatenablog.com/entry/2019/01/02/040000_1</a></p>
</li>
<li>
<p><a id="github_riscv-llvm_patch_03"></a>[13] <a href="https://github.com/lowRISC/riscv-llvm/blob/master/0003-RISCV-Add-RISC-V-ELF-defines.patch" class="bare">https://github.com/lowRISC/riscv-llvm/blob/master/0003-RISCV-Add-RISC-V-ELF-defines.patch</a></p>
</li>
<li>
<p><a id="github_riscv-llvm_patch_04"></a>[14] <a href="https://github.com/lowRISC/riscv-llvm/blob/master/0004-RISCV-Add-stub-backend.patch" class="bare">https://github.com/lowRISC/riscv-llvm/blob/master/0004-RISCV-Add-stub-backend.patch</a></p>
</li>
<li>
<p><a id="github_riscv-llvm_patch_06"></a>[15] <a href="https://github.com/lowRISC/riscv-llvm/blob/master/0006-RISCV-Add-bare-bones-RISC-V-MCTargetDesc.patch" class="bare">https://github.com/lowRISC/riscv-llvm/blob/master/0006-RISCV-Add-bare-bones-RISC-V-MCTargetDesc.patch</a></p>
</li>
<li>
<p><a id="github_riscv-llvm_patch_10"></a>[16] <a href="https://github.com/lowRISC/riscv-llvm/blob/master/0010-RISCV-Add-support-for-disassembly.patch" class="bare">https://github.com/lowRISC/riscv-llvm/blob/master/0010-RISCV-Add-support-for-disassembly.patch</a></p>
</li>
<li>
<p><a id="llvm-writing_backend-operand_mapping"></a>[17] <a href="https://llvm.org/docs/WritingAnLLVMBackend.html#instruction-operand-mapping" class="bare">https://llvm.org/docs/WritingAnLLVMBackend.html#instruction-operand-mapping</a></p>
</li>
<li>
<p><a id="llvm-writing_backend"></a>[18] <a href="https://llvm.org/docs/WritingAnLLVMBackend.html" class="bare">https://llvm.org/docs/WritingAnLLVMBackend.html</a></p>
</li>
<li>
<p><a id="github_riscv-llvm_patch_07"></a>[19] <a href="https://github.com/lowRISC/riscv-llvm/blob/master/0007-RISCV-Add-basic-RISCVAsmParser.patch" class="bare">https://github.com/lowRISC/riscv-llvm/blob/master/0007-RISCV-Add-basic-RISCVAsmParser.patch</a></p>
</li>
<li>
<p><a id="github_riscv-llvm_patch_08"></a>[20] <a href="https://github.com/lowRISC/riscv-llvm/blob/master/0008-RISCV-Add-RISCVInstPrinter-and-basic-MC-assembler-te.patch" class="bare">https://github.com/lowRISC/riscv-llvm/blob/master/0008-RISCV-Add-RISCVInstPrinter-and-basic-MC-assembler-te.patch</a></p>
</li>
<li>
<p><a id="llvm-tablegen"></a>[21] <a href="https://llvm.org/docs/TableGen/index.html" class="bare">https://llvm.org/docs/TableGen/index.html</a></p>
</li>
<li>
<p><a id="github_riscv-llvm_patch_09"></a>[22] <a href="https://github.com/lowRISC/riscv-llvm/blob/master/0009-RISCV-Add-support-for-all-RV32I-instructions.patch" class="bare">https://github.com/lowRISC/riscv-llvm/blob/master/0009-RISCV-Add-support-for-all-RV32I-instructions.patch</a></p>
</li>
<li>
<p><a id="llvm_dev_ml-tablegen_definition_question"></a>[23] <a href="http://lists.llvm.org/pipermail/llvm-dev/2015-December/093310.html" class="bare">http://lists.llvm.org/pipermail/llvm-dev/2015-December/093310.html</a></p>
</li>
<li>
<p><a id="llvm_doxygen-twine"></a>[24] <a href="https://llvm.org/doxygen/classllvm_1_1Twine.html" class="bare">https://llvm.org/doxygen/classllvm_1_1Twine.html</a></p>
</li>
<li>
<p><a id="llvm-tablegen-langref"></a>[25] <a href="https://llvm.org/docs/TableGen/LangRef.html" class="bare">https://llvm.org/docs/TableGen/LangRef.html</a></p>
</li>
<li>
<p><a id="github_riscv-llvm_docs_05"></a>[26] <a href="https://github.com/lowRISC/riscv-llvm/blob/master/docs/05-disassembly.mkd" class="bare">https://github.com/lowRISC/riscv-llvm/blob/master/docs/05-disassembly.mkd</a></p>
</li>
<li>
<p><a id="github_riscv-llvm_patch_11"></a>[27] <a href="https://github.com/lowRISC/riscv-llvm/blob/master/0011-RISCV-Add-common-fixups-and-relocations.patch" class="bare">https://github.com/lowRISC/riscv-llvm/blob/master/0011-RISCV-Add-common-fixups-and-relocations.patch</a></p>
</li>
<li>
<p><a id="github_riscv-llvm_docs_06"></a>[28] <a href="https://github.com/lowRISC/riscv-llvm/blob/master/docs/06-relocations-and-fixups.mkd" class="bare">https://github.com/lowRISC/riscv-llvm/blob/master/docs/06-relocations-and-fixups.mkd</a></p>
</li>
<li>
<p><a id="github_riscv-llvm_patch_13"></a>[29] <a href="https://github.com/lowRISC/riscv-llvm/blob/master/0013-RISCV-Initial-codegen-support-for-ALU-operations.patch" class="bare">https://github.com/lowRISC/riscv-llvm/blob/master/0013-RISCV-Initial-codegen-support-for-ALU-operations.patch</a></p>
</li>
<li>
<p><a id="speakerdeck-llvm_backend_development"></a>[30] <a href="https://speakerdeck.com/asb/llvm-backend-development-by-example-risc-v" class="bare">https://speakerdeck.com/asb/llvm-backend-development-by-example-risc-v</a></p>
</li>
<li>
<p><a id="llvm-code_generator"></a>[31] <a href="https://llvm.org/docs/CodeGenerator.html" class="bare">https://llvm.org/docs/CodeGenerator.html</a></p>
</li>
<li>
<p><a id="llvm-code_generator-target_independent_code_gen_alg"></a>[32] <a href="https://llvm.org/docs/CodeGenerator.html#target-independent-code-generation-algorithms" class="bare">https://llvm.org/docs/CodeGenerator.html#target-independent-code-generation-algorithms</a></p>
</li>
<li>
<p><a id="llvm-code_generator-selectiondag_instruction_selection"></a>[33] <a href="https://llvm.org/docs/CodeGenerator.html#selectiondag-instruction-selection-process" class="bare">https://llvm.org/docs/CodeGenerator.html#selectiondag-instruction-selection-process</a></p>
</li>
<li>
<p><a id="github_riscv-llvm_patch_15"></a>[34] <a href="https://github.com/lowRISC/riscv-llvm/blob/master/0015-RISCV-Codegen-support-for-memory-operations.patch" class="bare">https://github.com/lowRISC/riscv-llvm/blob/master/0015-RISCV-Codegen-support-for-memory-operations.patch</a></p>
</li>
<li>
<p><a id="cpu0"></a>[35] <a href="https://jonathan2251.github.io/lbd/" class="bare">https://jonathan2251.github.io/lbd/</a></p>
</li>
<li>
<p><a id="elvm-llvm_backend"></a>[36] <a href="https://github.com/shinh/llvm/tree/elvm" class="bare">https://github.com/shinh/llvm/tree/elvm</a></p>
</li>
<li>
<p><a id="elvm-slide"></a>[37] <a href="http://shinh.skr.jp/slide/llel/000.html" class="bare">http://shinh.skr.jp/slide/llel/000.html</a></p>
</li>
<li>
<p><a id="github_riscv-llvm_patch_16"></a>[38] <a href="https://github.com/lowRISC/riscv-llvm/blob/master/0016-RISCV-Codegen-support-for-memory-operations-on-globa.patch" class="bare">https://github.com/lowRISC/riscv-llvm/blob/master/0016-RISCV-Codegen-support-for-memory-operations-on-globa.patch</a></p>
</li>
<li>
<p><a id="github_riscv-llvm_patch_17"></a>[39] <a href="https://github.com/lowRISC/riscv-llvm/blob/master/0017-RISCV-Codegen-for-conditional-branches.patch" class="bare">https://github.com/lowRISC/riscv-llvm/blob/master/0017-RISCV-Codegen-for-conditional-branches.patch</a></p>
</li>
<li>
<p><a id="todai_llvm_backend"></a>[40] <a href="https://github.com/cpu-experiment-2018-2/llvm/tree/master/lib/Target/ELMO" class="bare">https://github.com/cpu-experiment-2018-2/llvm/tree/master/lib/Target/ELMO</a></p>
</li>
<li>
<p><a id="todai_llvm_backend-article"></a>[41] <a href="http://uenoku.hatenablog.com/entry/2018/12/25/044244" class="bare">http://uenoku.hatenablog.com/entry/2018/12/25/044244</a></p>
</li>
<li>
<p><a id="github_riscv-llvm_patch_18"></a>[42] <a href="https://github.com/lowRISC/riscv-llvm/blob/master/0018-RISCV-Support-for-function-calls.patch" class="bare">https://github.com/lowRISC/riscv-llvm/blob/master/0018-RISCV-Support-for-function-calls.patch</a></p>
</li>
<li>
<p><a id="llvm-langref"></a>[43] <a href="http://llvm.org/docs/LangRef.html" class="bare">http://llvm.org/docs/LangRef.html</a></p>
</li>
<li>
<p><a id="fpga_develop_diary"></a>[44] <a href="http://msyksphinz.hatenablog.com/" class="bare">http://msyksphinz.hatenablog.com/</a></p>
</li>
<li>
<p><a id="llvm-anton_korobeynikov_2012"></a>[45] <a href="https://llvm.org/devmtg/2012-04-12/Slides/Workshops/Anton_Korobeynikov.pdf" class="bare">https://llvm.org/devmtg/2012-04-12/Slides/Workshops/Anton_Korobeynikov.pdf</a></p>
</li>
<li>
<p><a id="llvm-welcome_to_the_back_end_2017"></a>[46] <a href="https://www.youtube.com/watch?v=objxlZg01D0" class="bare">https://www.youtube.com/watch?v=objxlZg01D0</a></p>
</li>
<li>
<p><a id="ean10-howto-llvmas"></a>[47] <a href="https://www.embecosm.com/appnotes/ean10/ean10-howto-llvmas-1.0.html" class="bare">https://www.embecosm.com/appnotes/ean10/ean10-howto-llvmas-1.0.html</a></p>
</li>
<li>
<p><a id="lowrisc-devmtg18"></a>[48] <a href="https://www.lowrisc.org/llvm/devmtg18/" class="bare">https://www.lowrisc.org/llvm/devmtg18/</a></p>
</li>
<li>
<p><a id="LLVMBackend_2015_03_26_v2"></a>[49] <a href="http://www.inf.ed.ac.uk/teaching/courses/ct/other/LLVMBackend-2015-03-26_v2.pdf" class="bare">http://www.inf.ed.ac.uk/teaching/courses/ct/other/LLVMBackend-2015-03-26_v2.pdf</a></p>
</li>
<li>
<p><a id="rui-compilerbook"></a>[50] <a href="https://www.sigbus.info/compilerbook" class="bare">https://www.sigbus.info/compilerbook</a></p>
</li>
<li>
<p><a id="krister-writing_gcc_backend"></a>[51] <a href="https://kristerw.blogspot.com/2017/08/writing-gcc-backend_4.html" class="bare">https://kristerw.blogspot.com/2017/08/writing-gcc-backend_4.html</a></p>
</li>
<li>
<p><a id="llvm-ml-129089"></a>[52] <a href="http://lists.llvm.org/pipermail/llvm-dev/2019-January/129089.html" class="bare">http://lists.llvm.org/pipermail/llvm-dev/2019-January/129089.html</a></p>
</li>
<li>
<p><a id="llvm-langref-datalayout"></a>[53] <a href="https://llvm.org/docs/LangRef.html#langref-datalayout" class="bare">https://llvm.org/docs/LangRef.html#langref-datalayout</a></p>
</li>
<li>
<p><a id="github-frasercrmck_llvm_leg"></a>[54] <a href="https://github.com/frasercrmck/llvm-leg/tree/master/lib/Target/LEG" class="bare">https://github.com/frasercrmck/llvm-leg/tree/master/lib/Target/LEG</a></p>
</li>
<li>
<p><a id="llvm_doxygen-InitMCRegisterInfo"></a>[55] <a href="https://llvm.org/doxygen/classllvm_1_1MCRegisterInfo.html#a989859615fcb74989b4f978c4d227a03" class="bare">https://llvm.org/doxygen/classllvm_1_1MCRegisterInfo.html#a989859615fcb74989b4f978c4d227a03</a></p>
</li>
<li>
<p><a id="llvm-programmers_manual"></a>[56] <a href="http://llvm.org/docs/ProgrammersManual.html" class="bare">http://llvm.org/docs/ProgrammersManual.html</a></p>
</li>
<li>
<p><a id="llvm-writing_backend-calling_conventions"></a>[57] <a href="https://llvm.org/docs/WritingAnLLVMBackend.html#calling-conventions" class="bare">https://llvm.org/docs/WritingAnLLVMBackend.html#calling-conventions</a></p>
</li>
<li>
<p><a id="riscv-calling"></a>[58] <a href="https://riscv.org/wp-content/uploads/2015/01/riscv-calling.pdf" class="bare">https://riscv.org/wp-content/uploads/2015/01/riscv-calling.pdf</a></p>
</li>
<li>
<p><a id="llvm_dev_ml-how_to_debug_instruction_selection"></a>[59] <a href="http://lists.llvm.org/pipermail/llvm-dev/2017-August/116501.html" class="bare">http://lists.llvm.org/pipermail/llvm-dev/2017-August/116501.html</a></p>
</li>
<li>
<p><a id="fpga_develop_diary-20190612040000"></a>[60] <a href="http://msyksphinz.hatenablog.com/entry/2019/06/12/040000" class="bare">http://msyksphinz.hatenablog.com/entry/2019/06/12/040000</a></p>
</li>
<li>
<p><a id="llvm_dev_ml-br_cc_questions"></a>[61] <a href="http://lists.llvm.org/pipermail/llvm-dev/2014-August/075303.html" class="bare">http://lists.llvm.org/pipermail/llvm-dev/2014-August/075303.html</a></p>
</li>
<li>
<p><a id="llvm_dev_ml-multiple_result_instrs"></a>[62] <a href="https://groups.google.com/forum/#!topic/llvm-dev/8kPOj-_lbGk" class="bare">https://groups.google.com/forum/#!topic/llvm-dev/8kPOj-_lbGk</a></p>
</li>
<li>
<p><a id="stackoverflow-frame_lowering"></a>[63] <a href="https://stackoverflow.com/questions/32872946/what-is-stack-frame-lowering-in-llvm" class="bare">https://stackoverflow.com/questions/32872946/what-is-stack-frame-lowering-in-llvm</a></p>
</li>
<li>
<p><a id="llvm_dev_ml-selecting_frame_index"></a>[64] <a href="https://groups.google.com/d/msg/llvm-dev/QXwtqgau-jA/PwnHDF0gG_oJ" class="bare">https://groups.google.com/d/msg/llvm-dev/QXwtqgau-jA/PwnHDF0gG_oJ</a></p>
</li>
<li>
<p><a id="fpga_develop_diary-llvm"></a>[65] <a href="https://github.com/msyksphinz/llvm/tree/myriscvx/impl90/lib/Target/MYRISCVX" class="bare">https://github.com/msyksphinz/llvm/tree/myriscvx/impl90/lib/Target/MYRISCVX</a></p>
</li>
<li>
<p><a id="llvm-github_cd44ae"></a>[66] <a href="https://github.com/llvm/llvm-project/commit/cd44aee3da22f9a618f2e63c226bebf615fa8cf8" class="bare">https://github.com/llvm/llvm-project/commit/cd44aee3da22f9a618f2e63c226bebf615fa8cf8</a></p>
</li>
<li>
<p><a id="llvm_phabricator-d43752"></a>[67] <a href="https://reviews.llvm.org/D43752" class="bare">https://reviews.llvm.org/D43752</a></p>
</li>
<li>
<p><a id="llvm-compilerwriterinfo"></a>[68] <a href="https://llvm.org/docs/CompilerWriterInfo.html" class="bare">https://llvm.org/docs/CompilerWriterInfo.html</a></p>
</li>
<li>
<p><a id="wikipedia-The_Gleaners"></a>[69] <a href="https://en.wikipedia.org/wiki/The_Gleaners" class="bare">https://en.wikipedia.org/wiki/The_Gleaners</a></p>
</li>
<li>
<p><a id="github_riscv-llvm_patch_20"></a>[70] <a href="https://github.com/lowRISC/riscv-llvm/blob/master/0020-RISCV-Support-and-tests-for-a-variety-of-additional-.patch" class="bare">https://github.com/lowRISC/riscv-llvm/blob/master/0020-RISCV-Support-and-tests-for-a-variety-of-additional-.patch</a></p>
</li>
<li>
<p><a id="llvm_phabricator-d47422"></a>[71] <a href="https://reviews.llvm.org/D47422" class="bare">https://reviews.llvm.org/D47422</a></p>
</li>
<li>
<p><a id="llvm-extendingllvm"></a>[72] <a href="https://llvm.org/docs/ExtendingLLVM.html" class="bare">https://llvm.org/docs/ExtendingLLVM.html</a></p>
</li>
<li>
<p><a id="llvm_dev_ml-001264"></a>[73] <a href="http://lists.llvm.org/pipermail/llvm-dev/2004-June/001264.html" class="bare">http://lists.llvm.org/pipermail/llvm-dev/2004-June/001264.html</a></p>
</li>
<li>
<p><a id="llvm_phabricator-d42958"></a>[74] <a href="https://reviews.llvm.org/D42958" class="bare">https://reviews.llvm.org/D42958</a></p>
</li>
<li>
<p><a id="compiler_rt"></a>[75] <a href="https://compiler-rt.llvm.org/" class="bare">https://compiler-rt.llvm.org/</a></p>
</li>
<li>
<p><a id="github-riscv_compiler_rt"></a>[76] <a href="https://github.com/andestech/riscv-compiler-rt" class="bare">https://github.com/andestech/riscv-compiler-rt</a></p>
</li>
<li>
<p><a id="github_riscv-llvm_patch_27"></a>[77] <a href="https://github.com/lowRISC/riscv-llvm/blob/master/0027-RISCV-Support-stack-frames-and-offsets-up-to-32-bits.patch" class="bare">https://github.com/lowRISC/riscv-llvm/blob/master/0027-RISCV-Support-stack-frames-and-offsets-up-to-32-bits.patch</a></p>
</li>
<li>
<p><a id="llvm_phabricator-d44885"></a>[78] <a href="https://reviews.llvm.org/D44885" class="bare">https://reviews.llvm.org/D44885</a></p>
</li>
<li>
<p><a id="llvm_phabricator-d45859"></a>[79] <a href="https://reviews.llvm.org/D45859" class="bare">https://reviews.llvm.org/D45859</a></p>
</li>
<li>
<p><a id="llvm-langref-poison_value"></a>[80] <a href="http://llvm.org/docs/LangRef.html#poisonvalues" class="bare">http://llvm.org/docs/LangRef.html#poisonvalues</a></p>
</li>
<li>
<p><a id="github-emscripten-issues-34"></a>[81] <a href="https://github.com/emscripten-core/emscripten/issues/34" class="bare">https://github.com/emscripten-core/emscripten/issues/34</a></p>
</li>
<li>
<p><a id="switch_lowering_in_llvm"></a>[82] <a href="http://fileadmin.cs.lth.se/cs/education/edan75/part2.pdf" class="bare">http://fileadmin.cs.lth.se/cs/education/edan75/part2.pdf</a></p>
</li>
<li>
<p><a id="github-avr_llvm-issues-88"></a>[83] <a href="https://github.com/avr-llvm/llvm/issues/88" class="bare">https://github.com/avr-llvm/llvm/issues/88</a></p>
</li>
<li>
<p><a id="asciidoctor-quickref"></a>[84] <a href="https://asciidoctor.org/docs/asciidoc-syntax-quick-reference/" class="bare">https://asciidoctor.org/docs/asciidoc-syntax-quick-reference/</a></p>
</li>
<li>
<p><a id="llvm_phabricator-d56351"></a>[85] <a href="https://reviews.llvm.org/D56351" class="bare">https://reviews.llvm.org/D56351</a></p>
</li>
<li>
<p><a id="hatenablog-rhysd-230119"></a>[86] <a href="https://rhysd.hatenablog.com/entry/2017/03/13/230119" class="bare">https://rhysd.hatenablog.com/entry/2017/03/13/230119</a></p>
</li>
<li>
<p><a id="llvm_dev_ml-115805"></a>[87] <a href="http://lists.llvm.org/pipermail/llvm-dev/2017-July/115805.html" class="bare">http://lists.llvm.org/pipermail/llvm-dev/2017-July/115805.html</a></p>
</li>
<li>
<p><a id="github_riscv-llvm_patch_29"></a>[88] <a href="https://github.com/lowRISC/riscv-llvm/blob/master/0029-RISCV-Add-support-for-llvm.-frameaddress-returnaddre.patch" class="bare">https://github.com/lowRISC/riscv-llvm/blob/master/0029-RISCV-Add-support-for-llvm.-frameaddress-returnaddre.patch</a></p>
</li>
<li>
<p><a id="github-riscv_llvm-clang"></a>[89] <a href="https://github.com/lowRISC/riscv-llvm/tree/master/clang" class="bare">https://github.com/lowRISC/riscv-llvm/tree/master/clang</a></p>
</li>
<li>
<p><a id="github-elvm_clang"></a>[90] <a href="https://github.com/shinh/clang/tree/elvm" class="bare">https://github.com/shinh/clang/tree/elvm</a></p>
</li>
<li>
<p><a id="github_riscv-llvm_patch_22"></a>[91] <a href="https://github.com/lowRISC/riscv-llvm/blob/master/0022-RISCV-Support-lowering-FrameIndex.patch" class="bare">https://github.com/lowRISC/riscv-llvm/blob/master/0022-RISCV-Support-lowering-FrameIndex.patch</a></p>
</li>
<li>
<p><a id="llvm_dev_ml-087879"></a>[92] <a href="http://lists.llvm.org/pipermail/llvm-dev/2015-July/087879.html" class="bare">http://lists.llvm.org/pipermail/llvm-dev/2015-July/087879.html</a></p>
</li>
<li>
<p><a id="stackoverflow-27467293"></a>[93] <a href="https://stackoverflow.com/questions/27467293/how-to-force-clang-use-llvm-assembler-instead-of-system" class="bare">https://stackoverflow.com/questions/27467293/how-to-force-clang-use-llvm-assembler-instead-of-system</a></p>
</li>
<li>
<p><a id="github-riscv_llvm-clang-03"></a>[94] <a href="https://github.com/lowRISC/riscv-llvm/blob/master/clang/0003-RISCV-Implement-clang-driver-for-the-baremetal-RISCV.patch" class="bare">https://github.com/lowRISC/riscv-llvm/blob/master/clang/0003-RISCV-Implement-clang-driver-for-the-baremetal-RISCV.patch</a></p>
</li>
<li>
<p><a id="github_riscv-llvm_patch_25"></a>[95] <a href="https://github.com/lowRISC/riscv-llvm/blob/master/0025-RISCV-Add-custom-CC_RISCV-calling-convention-and-imp.patch" class="bare">https://github.com/lowRISC/riscv-llvm/blob/master/0025-RISCV-Add-custom-CC_RISCV-calling-convention-and-imp.patch</a></p>
</li>
<li>
<p><a id="llvm_dev_ml-106187"></a>[96] <a href="http://lists.llvm.org/pipermail/llvm-dev/2016-October/106187.html" class="bare">http://lists.llvm.org/pipermail/llvm-dev/2016-October/106187.html</a></p>
</li>
<li>
<p><a id="llvm_phabricator-d39322"></a>[97] <a href="https://reviews.llvm.org/D39322" class="bare">https://reviews.llvm.org/D39322</a></p>
</li>
<li>
<p><a id="cpu0-lld"></a>[98] <a href="http://jonathan2251.github.io/lbt/lld.html" class="bare">http://jonathan2251.github.io/lbt/lld.html</a></p>
</li>
<li>
<p><a id="youtube-how_to_add_a_new_target_to_lld"></a>[99] <a href="https://www.youtube.com/watch?v=FIXaeRU31Ww" class="bare">https://www.youtube.com/watch?v=FIXaeRU31Ww</a></p>
</li>
<li>
<p><a id="llvm-smith_newlldtargetpdf"></a>[100] <a href="https://llvm.org/devmtg/2016-09/slides/Smith-NewLLDTarget.pdf" class="bare">https://llvm.org/devmtg/2016-09/slides/Smith-NewLLDTarget.pdf</a></p>
</li>
<li>
<p><a id="llvm-lld"></a>[101] <a href="https://lld.llvm.org/index.html" class="bare">https://lld.llvm.org/index.html</a></p>
</li>
<li>
<p><a id="note-n9948f0cc3ed3"></a>[102] <a href="https://note.mu/ruiu/n/n9948f0cc3ed3" class="bare">https://note.mu/ruiu/n/n9948f0cc3ed3</a></p>
</li>
<li>
<p><a id="lanai-isa"></a>[103] <a href="https://docs.google.com/document/d/1jwAc-Rbw1Mn7Dbn2oEB3-0FQNOwqNPslZa-NDy8wGRo/pub" class="bare">https://docs.google.com/document/d/1jwAc-Rbw1Mn7Dbn2oEB3-0FQNOwqNPslZa-NDy8wGRo/pub</a></p>
</li>
<li>
<p><a id="github-blog_os-issues-370"></a>[104] <a href="https://github.com/phil-opp/blog_os/issues/370" class="bare">https://github.com/phil-opp/blog_os/issues/370</a></p>
</li>
<li>
<p><a id="llvm_phabricator-d61688"></a>[105] <a href="https://reviews.llvm.org/D61688" class="bare">https://reviews.llvm.org/D61688</a></p>
</li>
<li>
<p><a id="man-xtensa_linux_gnu_ld"></a>[106] <a href="https://linux.die.net/man/1/xtensa-linux-gnu-ld" class="bare">https://linux.die.net/man/1/xtensa-linux-gnu-ld</a></p>
</li>
<li>
<p><a id="man-elf"></a>[107] <a href="https://linuxjm.osdn.jp/html/LDP_man-pages/man5/elf.5.html" class="bare">https://linuxjm.osdn.jp/html/LDP_man-pages/man5/elf.5.html</a></p>
</li>
<li>
<p><a id="llvm_phabricator-d45385"></a>[108] <a href="https://reviews.llvm.org/D45385" class="bare">https://reviews.llvm.org/D45385</a></p>
</li>
<li>
<p><a id="llvm_phabricator-d47882"></a>[109] <a href="https://reviews.llvm.org/D47882" class="bare">https://reviews.llvm.org/D47882</a></p>
</li>
<li>
<p><a id="llvm_dev_ml-128257"></a>[110] <a href="https://lists.llvm.org/pipermail/llvm-dev/2018-December/128257.html" class="bare">https://lists.llvm.org/pipermail/llvm-dev/2018-December/128257.html</a></p>
</li>
<li>
<p><a id="github_riscv-llvm_patch_31"></a>[111] <a href="https://github.com/lowRISC/riscv-llvm/blob/master/0031-RISCV-Implement-support-for-the-BranchRelaxation-pas.patch" class="bare">https://github.com/lowRISC/riscv-llvm/blob/master/0031-RISCV-Implement-support-for-the-BranchRelaxation-pas.patch</a></p>
</li>
<li>
<p><a id="github_riscv-llvm_patch_30"></a>[112] <a href="https://github.com/lowRISC/riscv-llvm/blob/master/0030-RISCV-Implement-branch-analysis.patch" class="bare">https://github.com/lowRISC/riscv-llvm/blob/master/0030-RISCV-Implement-branch-analysis.patch</a></p>
</li>
<li>
<p><a id="stackoverflow-5789806"></a>[113] <a href="https://stackoverflow.com/questions/5789806/meaning-of-and-in-c" class="bare">https://stackoverflow.com/questions/5789806/meaning-of-and-in-c</a></p>
</li>
<li>
<p><a id="compiler_study_report"></a>[114] <a href="https://proc-cpuinfo.fixstars.com/2018/11/compiler_study_report/" class="bare">https://proc-cpuinfo.fixstars.com/2018/11/compiler_study_report/</a></p>
</li>
<li>
<p><a id="github-llvm-bcb36be8e3f5dced36710ba1a2e2206071ccc7ba"></a>[115] <a href="https://github.com/llvm/llvm-project/commit/bcb36be8e3f5dced36710ba1a2e2206071ccc7ba" class="bare">https://github.com/llvm/llvm-project/commit/bcb36be8e3f5dced36710ba1a2e2206071ccc7ba</a></p>
</li>
<li>
<p><a id="llvm_dev_ml-059799"></a>[116] <a href="http://lists.llvm.org/pipermail/llvm-dev/2013-February/059799.html" class="bare">http://lists.llvm.org/pipermail/llvm-dev/2013-February/059799.html</a></p>
</li>
<li>
<p><a id="tricore-llvm-slides"></a>[117] <a href="https://reup.dmcs.pl/wiki/images/7/7a/Tricore-llvm-slides.pdf" class="bare">https://reup.dmcs.pl/wiki/images/7/7a/Tricore-llvm-slides.pdf</a></p>
</li>
<li>
<p><a id="tricore-llvm"></a>[118] <a href="https://opus4.kobv.de/opus4-fau/files/1108/tricore_llvm.pdf" class="bare">https://opus4.kobv.de/opus4-fau/files/1108/tricore_llvm.pdf</a></p>
</li>
<li>
<p><a id="llvm_dev_ml-111697"></a>[119] <a href="http://lists.llvm.org/pipermail/llvm-dev/2017-April/111697.html" class="bare">http://lists.llvm.org/pipermail/llvm-dev/2017-April/111697.html</a></p>
</li>
<li>
<p><a id="takayuki-no09"></a>[120] <a href="http://www.ertl.jp/~takayuki/readings/c/no09.html" class="bare">http://www.ertl.jp/~takayuki/readings/c/no09.html</a></p>
</li>
<li>
<p><a id="hwenginner-linker"></a>[121] <a href="https://hwengineer.github.io/linker/" class="bare">https://hwengineer.github.io/linker/</a></p>
</li>
<li>
<p><a id="koikikukan-000300"></a>[122] <a href="http://www.koikikukan.com/archives/2017/04/05-000300.php" class="bare">http://www.koikikukan.com/archives/2017/04/05-000300.php</a></p>
</li>
<li>
<p><a id="stackoverflow-57735654_34997577"></a>[123] <a href="https://stackoverflow.com/questions/34997577/linker-script-allocation-of-bss-section#comment57735654_34997577" class="bare">https://stackoverflow.com/questions/34997577/linker-script-allocation-of-bss-section#comment57735654_34997577</a></p>
</li>
<li>
<p><a id="redhat-ld_simple_example"></a>[124] <a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/4/html/Using_ld_the_GNU_Linker/simple-example.html" class="bare">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/4/html/Using_ld_the_GNU_Linker/simple-example.html</a></p>
</li>
<li>
<p><a id="llvm_phabricator-d45395"></a>[125] <a href="https://reviews.llvm.org/D45395" class="bare">https://reviews.llvm.org/D45395</a></p>
</li>
<li>
<p><a id="llvm_phabricator-d45395-398662"></a>[126] <a href="https://reviews.llvm.org/D45395#inline-398662" class="bare">https://reviews.llvm.org/D45395#inline-398662</a></p>
</li>
<li>
<p><a id="llvm-langref-inline_asm"></a>[127] <a href="http://llvm.org/docs/LangRef.html#inline-assembler-expressions" class="bare">http://llvm.org/docs/LangRef.html#inline-assembler-expressions</a></p>
</li>
<li>
<p><a id="hazymoon-gcc_inline_asm"></a>[128] <a href="http://caspar.hazymoon.jp/OpenBSD/annex/gcc_inline_asm.html" class="bare">http://caspar.hazymoon.jp/OpenBSD/annex/gcc_inline_asm.html</a></p>
</li>
<li>
<p><a id="github_riscv-llvm_patch_28"></a>[129] <a href="https://github.com/lowRISC/riscv-llvm/blob/master/0028-RISCV-Add-basic-support-for-inline-asm-constraints.patch" class="bare">https://github.com/lowRISC/riscv-llvm/blob/master/0028-RISCV-Add-basic-support-for-inline-asm-constraints.patch</a></p>
</li>
<li>
<p><a id="llvm-langref-inline_asm-asm_template_argument_modifier"></a>[130] <a href="http://llvm.org/docs/LangRef.html#asm-template-argument-modifiers" class="bare">http://llvm.org/docs/LangRef.html#asm-template-argument-modifiers</a></p>
</li>
<li>
<p><a id="github-llvm-0715d35ed5ac2312951976bee2a0d2587f98f39f"></a>[131] <a href="https://github.com/llvm/llvm-project/commit/0715d35ed5ac2312951976bee2a0d2587f98f39f" class="bare">https://github.com/llvm/llvm-project/commit/0715d35ed5ac2312951976bee2a0d2587f98f39f</a></p>
</li>
<li>
<p><a id="github_riscv-llvm_patch_32"></a>[132] <a href="https://github.com/lowRISC/riscv-llvm/blob/master/0032-RISCV-Reserve-an-emergency-spill-slot-for-the-regist.patch" class="bare">https://github.com/lowRISC/riscv-llvm/blob/master/0032-RISCV-Reserve-an-emergency-spill-slot-for-the-regist.patch</a></p>
</li>
<li>
<p><a id="github_riscv-llvm_patch_26"></a>[133] <a href="https://github.com/lowRISC/riscv-llvm/blob/master/0026-RISCV-Support-for-varargs.patch" class="bare">https://github.com/lowRISC/riscv-llvm/blob/master/0026-RISCV-Support-for-varargs.patch</a></p>
</li>
<li>
<p><a id="github-fracture-wiki-how-dagisel-works"></a>[134] <a href="https://github.com/draperlaboratory/fracture/wiki/How-TableGen%27s-DAGISel-Backend-Works" class="bare">https://github.com/draperlaboratory/fracture/wiki/How-TableGen%27s-DAGISel-Backend-Works</a></p>
</li>
<li>
<p><a id="welcome_to_the_back_end-slides"></a>[135] <a href="http://llvm.org/devmtg/2017-10/slides/Braun-Welcome%20to%20the%20Back%20End.pdf" class="bare">http://llvm.org/devmtg/2017-10/slides/Braun-Welcome%20to%20the%20Back%20End.pdf</a></p>
</li>
<li>
<p><a id="life_of_an_instruction"></a>[136] <a href="https://eli.thegreenplace.net/2012/11/24/life-of-an-instruction-in-llvm/" class="bare">https://eli.thegreenplace.net/2012/11/24/life-of-an-instruction-in-llvm/</a></p>
</li>
<li>
<p><a id="shinh-blog-010637"></a>[137] <a href="http://shinh.hatenablog.com/entry/2014/10/03/010637" class="bare">http://shinh.hatenablog.com/entry/2014/10/03/010637</a></p>
</li>
<li>
<p><a id="llvm_backend_intro"></a>[138] <a href="https://www.slideshare.net/AkiraMaruoka/llvm-backend" class="bare">https://www.slideshare.net/AkiraMaruoka/llvm-backend</a></p>
</li>
<li>
<p><a id="amazon-llvm_cookbook-customer_review"></a>[139] <a href="https://www.amazon.co.jp/dp/178528598X#customer_review-R28L2NAL8T9M2H" class="bare">https://www.amazon.co.jp/dp/178528598X#customer_review-R28L2NAL8T9M2H</a></p>
</li>
<li>
<p><a id="llvm_dev_ml-117139"></a>[140] <a href="https://lists.llvm.org/pipermail/llvm-dev/2017-September/117139.html" class="bare">https://lists.llvm.org/pipermail/llvm-dev/2017-September/117139.html</a></p>
</li>
<li>
<p><a id="github_riscv-llvm_patch_85"></a>[141] <a href="https://github.com/lowRISC/riscv-llvm/blob/master/0085-RISCV-Set-AllowRegisterRenaming-1.patch" class="bare">https://github.com/lowRISC/riscv-llvm/blob/master/0085-RISCV-Set-AllowRegisterRenaming-1.patch</a></p>
</li>
<li>
<p><a id="llvm_dev_ml-135337"></a>[142] <a href="https://lists.llvm.org/pipermail/llvm-dev/2019-September/135337.html" class="bare">https://lists.llvm.org/pipermail/llvm-dev/2019-September/135337.html</a></p>
</li>
<li>
<p><a id="wikipedia-weak_symbol"></a>[143] <a href="https://en.wikipedia.org/wiki/Weak_symbol" class="bare">https://en.wikipedia.org/wiki/Weak_symbol</a></p>
</li>
<li>
<p><a id="wikipedia-remat"></a>[144] <a href="https://en.wikipedia.org/wiki/Rematerialization" class="bare">https://en.wikipedia.org/wiki/Rematerialization</a></p>
</li>
<li>
<p><a id="llvm_phabricator-d46182"></a>[145] <a href="https://reviews.llvm.org/D46182" class="bare">https://reviews.llvm.org/D46182</a></p>
</li>
<li>
<p><a id="nakata-compiler"></a>[146] 『コンパイラの構成と最適化（第2版）』（中田育男、朝倉書店、2009）</p>
</li>
<li>
<p><a id="fpga_develop_diary-to_llvm9"></a>[147] <a href="http://msyksphinz.hatenablog.com/entry/2019/08/17/040000" class="bare">http://msyksphinz.hatenablog.com/entry/2019/08/17/040000</a></p>
</li>
<li>
<p><a id="llvm_phabricator-d60488"></a>[148] <a href="https://reviews.llvm.org/D60488" class="bare">https://reviews.llvm.org/D60488</a></p>
</li>
<li>
<p><a id="llvm_phabricator-rl364191"></a>[149] <a href="https://reviews.llvm.org/rL364191" class="bare">https://reviews.llvm.org/rL364191</a></p>
</li>
<li>
<p><a id="llvm_phabricator-d64121"></a>[150] <a href="https://reviews.llvm.org/D64121" class="bare">https://reviews.llvm.org/D64121</a></p>
</li>
<li>
<p><a id="llvm-codingstandards"></a>[151] <a href="https://llvm.org/docs/CodingStandards.html" class="bare">https://llvm.org/docs/CodingStandards.html</a></p>
</li>
<li>
<p><a id="llvm_dev_ml-134921"></a>[152] <a href="https://lists.llvm.org/pipermail/llvm-dev/2019-September/134921.html" class="bare">https://lists.llvm.org/pipermail/llvm-dev/2019-September/134921.html</a></p>
</li>
<li>
<p><a id="llvm_phabricator-d43256"></a>[153] <a href="https://reviews.llvm.org/D43256" class="bare">https://reviews.llvm.org/D43256</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. 論文とスライドも怪しいものだが、著者が一致しているので多分正しいだろう。
</div>
<div class="footnote" id="_footnotedef_2">
<a href="#_footnoteref_2">2</a>. これとは別の発表で「コンパイラ開発してない人生はFAKE」という名言が飛び出した勉強会<a href="#compiler_study_report">[114]</a>。
</div>
<div class="footnote" id="_footnotedef_3">
<a href="#_footnoteref_3">3</a>. LLVMバックエンドの開発を円滑にするためのアーキテクチャなのではと思うほどに分かりやすい。
</div>
<div class="footnote" id="_footnotedef_4">
<a href="#_footnoteref_4">4</a>. 後のSparcについて<a href="#llvm_dev_ml-059799">[116]</a> にて指摘されているように、商業的に成功しなかったアーキテクチャほどコードが単純で分かりやすい。
</div>
<div class="footnote" id="_footnotedef_5">
<a href="#_footnoteref_5">5</a>. ちなみにreturn addressをスタックに積むx86では <code>eip</code> を（x86_64では <code>rip</code> を）返している。 なぜかは良くわからない。TODO
</div>
<div class="footnote" id="_footnotedef_6">
<a href="#_footnoteref_6">6</a>. このあたり、即値とは <code>MCExpr</code> である、というデータ構造が効いている。
</div>
<div class="footnote" id="_footnotedef_7">
<a href="#_footnoteref_7">7</a>. この <code>parseExpression</code> がどの程度の「式」をパーズしてくれるかは定かでない。TODO
</div>
<div class="footnote" id="_footnotedef_8">
<a href="#_footnoteref_8">8</a>. もっとも これは即値部分にシンボルのみが書けたときから（よく考えれば）そうだったのだが。
</div>
<div class="footnote" id="_footnotedef_9">
<a href="#_footnoteref_9">9</a>. 面倒なので。
</div>
<div class="footnote" id="_footnotedef_10">
<a href="#_footnoteref_10">10</a>. 今決めた。
</div>
<div class="footnote" id="_footnotedef_11">
<a href="#_footnoteref_11">11</a>. 仕組みさえ作っておけば、今後他の命令で同様の操作が必要になったときでも変更が容易である。
</div>
<div class="footnote" id="_footnotedef_12">
<a href="#_footnoteref_12">12</a>. と <code>Target.td</code> の コメントに記載がある。
</div>
<div class="footnote" id="_footnotedef_13">
<a href="#_footnoteref_13">13</a>. ここまで問題が明らかにならなかった理由は良くわからない。
</div>
<div class="footnote" id="_footnotedef_14">
<a href="#_footnoteref_14">14</a>. ただし条件分岐周りは各アーキ工夫をこらすところのようで、TableGenに頼らず C\++コードをがりがり書いているバックエンドは多く存在する。
</div>
<div class="footnote" id="_footnotedef_15">
<a href="#_footnoteref_15">15</a>. かなしい。
</div>
<div class="footnote" id="_footnotedef_16">
<a href="#_footnoteref_16">16</a>. 本当は <code>JAL</code> になるべきだが、 とりあえずここでは飛ぶ先の関数のアドレスをレジスタに入れて <code>JALR</code> で飛ぶ仕組みになっている。
</div>
<div class="footnote" id="_footnotedef_17">
<a href="#_footnoteref_17">17</a>. 普通そうだ。むしろそうでない場合が思い当たらない。
</div>
<div class="footnote" id="_footnotedef_18">
<a href="#_footnoteref_18">18</a>. これは <code>LowerGlobalAddress</code> において行われる。
</div>
<div class="footnote" id="_footnotedef_19">
<a href="#_footnoteref_19">19</a>. 本来必要なオペランド以外もオペランドに追加することで 生存期間を引き伸ばせるようだ。RISC Vのコードから類推しただけなので確認が必要。TODO
</div>
<div class="footnote" id="_footnotedef_20">
<a href="#_footnoteref_20">20</a>. これらの DAGは <code>Glue</code> を用いて1つにまとめられている。これによって間に余計な命令が挟まることを 防いでいる<a href="#llvm_dev_ml-135337">[142]</a>。
</div>
<div class="footnote" id="_footnotedef_21">
<a href="#_footnoteref_21">21</a>. 関数プロローグではi) <code>sp</code> を押し下げii) <strong><code>fp</code> を含む</strong>全てのcallee-savedレジスタを スタック上に保存した後iii) <code>fp</code> を設定する。したがって <code>sp</code> からの相対アドレスでないと正しく指定ができないという事情もあるようだ。 結局callee-savedなレジスタについては <code>sp</code> からの正のoffsetで参照され、 それ以外のレジスタについては <code>fp</code> からの負のoffsetで参照される。
</div>
<div class="footnote" id="_footnotedef_22">
<a href="#_footnoteref_22">22</a>. x86の実装などを見ると、 <code>fp</code> を使用せず全て <code>sp</code> で対応する場合（ <code>hasFP</code> が <code>false</code> の場合） などもここでoffset計算を行うようだが、挙動を追いきれていない。TODO
</div>
<div class="footnote" id="_footnotedef_23">
<a href="#_footnoteref_23">23</a>. RISC Vの実装では <code>12(fp)</code> などと、実際に必要な値以上に深くスタックフレームが確保されている ように見える。これはRISC Vの16バイトアラインを考慮しているためと推察される。要確認TODO
</div>
<div class="footnote" id="_footnotedef_24">
<a href="#_footnoteref_24">24</a>. 正確には「対応している」というより「許容している」が正しく、 特に特別な処理は行っていない（ように見える；要確認；TODO）。
</div>
<div class="footnote" id="_footnotedef_25">
<a href="#_footnoteref_25">25</a>. 正直これら2つが 必要なのかどうかはよくわからない。スタックフレームの定義によりそうだが、 例えばLanaiでは両方考慮していない。
</div>
<div class="footnote" id="_footnotedef_26">
<a href="#_footnoteref_26">26</a>. この処理で飛ばされる命令の意味がよくわからない。 TODO
</div>
<div class="footnote" id="_footnotedef_27">
<a href="#_footnoteref_27">27</a>. この計算は <code>CallFrameSetupOpcode</code> と <code>CallFrameDestroyOpcode</code> が定義されていればよく、 これは<a href="#adjcallstack">[adjcallstack]</a>によってなされているようだ。
</div>
<div class="footnote" id="_footnotedef_28">
<a href="#_footnoteref_28">28</a>. <a href="#llvm_phabricator-d43752">[67]</a>はC言語の可変長配列（VLA; Variable Length Array）に 対応するためのパッチのようだ。関数中にVLAが存在する場合 <code>sp</code> が適切に アラインメントされないまま関数呼び出しが行われてしまう場合がある。 それを防ぐために <code>ADJCALLSTACKDOWN</code> と <code>ADJCALLSTACKUP</code> を利用して <code>sp</code> の操作を行っている。
</div>
<div class="footnote" id="_footnotedef_29">
<a href="#_footnoteref_29">29</a>. 実際この指定を外してコード生成を行うと <code>fp</code> の スタック退避のためのコードは生成されない。一方で関数呼び出しなどが 行われている場合には <code>ra</code> のためのコードは生成されるが、 RISC-Vでは <code>ra</code> と <code>fp</code> の両方を明示的に退避している。これによって 最適化が行われない場合には必ず <code>ra</code> と <code>fp</code> がスタック上に退避されることになり、 <code>llvm.frameaddress</code> と <code>llvm.returnaddress</code> が動作することを保証している。
</div>
<div class="footnote" id="_footnotedef_30">
<a href="#_footnoteref_30">30</a>. 異なる手法でcallee-savedレジスタ退避を行うアーキテクチャもある。 Lanaiの <code>determineCalleeSaves</code> では <code>RCA</code> と <code>FP</code> のための領域のみを <code>MachineFrameInfo</code> に確保し <code>SavedRegs</code> への追加は行わない。そして <code>emitPrologue</code> にて、 この領域に <code>FP</code> を退避するコードを生成する。
</div>
<div class="footnote" id="_footnotedef_31">
<a href="#_footnoteref_31">31</a>. RV16K（ないし 実装を参照したRISC V）の <code>emitPrologue</code> では <code>MBBI</code> を <code>std::advance</code> を用いて先に進める部分がある。 これはここで特定し生成されたcallee-savedレジスタ退避のコードの後に <code>fp</code> の設定を行うためである。
</div>
<div class="footnote" id="_footnotedef_32">
<a href="#_footnoteref_32">32</a>. またの名を三項演算ｓうわなにをするやめｒ（静粛されました）
</div>
<div class="footnote" id="_footnotedef_33">
<a href="#_footnoteref_33">33</a>. 意味的にはそうだが、実際にClangがそうコンパイルするかは 要確認TODO
</div>
<div class="footnote" id="_footnotedef_34">
<a href="#_footnoteref_34">34</a>. 歴史的には順序が逆だが。
</div>
<div class="footnote" id="_footnotedef_35">
<a href="#_footnoteref_35">35</a>. これは expandの処理に含まれないのだろうか。要調査TODO
</div>
<div class="footnote" id="_footnotedef_36">
<a href="#_footnoteref_36">36</a>. 条件が成立する場合に <code>MOV</code> を行うx86の命令。
</div>
<div class="footnote" id="_footnotedef_37">
<a href="#_footnoteref_37">37</a>. 一方で <code>MachineBasicBlock</code> を作成することは （既に見てきたように）可能である。これによって、1つのbasic blockに複数の <code>MachineBasicBlock</code> が対応することになる。
</div>
<div class="footnote" id="_footnotedef_38">
<a href="#_footnoteref_38">38</a>. <code>setOperationAction</code> の指定によって、結果どのような アセンブリが生成されるかについてまとめた情報（実装以外に）はない（要確認；TODO）。 結局、他のバックエンドを参考にしながら指定するほかない。 なお実装を見る場合は <code>DAGTypeLegalizer</code> や <code>SelectionDAGLegalize</code> などを参考するとよさそうだ。
</div>
<div class="footnote" id="_footnotedef_39">
<a href="#_footnoteref_39">39</a>. 実際には 状況によって <code>sub</code> も用いられる。
</div>
<div class="footnote" id="_footnotedef_40">
<a href="#_footnoteref_40">40</a>. 以前の実装は このナイーブな手法であったが、その部分を使用する適切なテストが存在しなかったため エラーにならなかった。ここでの修正とともにテストに <code>large-stack.ll</code> <a href="#github_riscv-llvm_patch_27">[77]</a>を追加した。
</div>
<div class="footnote" id="_footnotedef_41">
<a href="#_footnoteref_41">41</a>. このエラーは <code>-verify-machineinstrs</code> オプションを 指定しているために発生している。これを指定しない場合はそのまま処理が継続し、 別の場所でエラーが出る。
</div>
<div class="footnote" id="_footnotedef_42">
<a href="#_footnoteref_42">42</a>. それを行っているのがregister scavengerのようだが、詳細は要調査；TODO
</div>
<div class="footnote" id="_footnotedef_43">
<a href="#_footnoteref_43">43</a>. 例えば <code>and x1, x0</code> 後に <code>mov x0, x1</code> とする場合 <code>and</code> に <code>isCommutable</code> フラグが立っていれば、2つの命令をまとめて <code>and x0, x1</code> とできる（場合がある）。
</div>
<div class="footnote" id="_footnotedef_44">
<a href="#_footnoteref_44">44</a>. Sparcも同様の手法を採用している。
</div>
<div class="footnote" id="_footnotedef_45">
<a href="#_footnoteref_45">45</a>. ただし <code>i32</code> の結果を関数から返却するために関数呼び出し規則を変更する必要がある。
</div>
<div class="footnote" id="_footnotedef_46">
<a href="#_footnoteref_46">46</a>. LLVMが把握していない関数を呼ぶとは これいかに。参照先ではランタイムライブラリを呼ぶ場合などが説明されているがよくわからなかった。 ランタイムライブラリの関数（後に登場する <code>__mulsi3</code> など）はコンパイラが挿入するため、 具体的な関数プロトタイプを埋め込むことは困難ということか？　実際アセンブリ中にシンボル名のまま 出力すれば目的は達成されるため、無理にこれを特定する必要はない。要調査；TODO
</div>
<div class="footnote" id="_footnotedef_47">
<a href="#_footnoteref_47">47</a>. 逆に言えば すべて符号なしとして積を計算してよい。これはi) LLVMが2の補数表現を採用していることとii) 結果とオペランドが同じビット幅を持っていることから従うようだ<a href="#llvm-langref">[43]</a>。
</div>
<div class="footnote" id="_footnotedef_48">
<a href="#_footnoteref_48">48</a>. ISAや人によっては特殊でないかもしれないが。
</div>
<div class="footnote" id="_footnotedef_49">
<a href="#_footnoteref_49">49</a>. <code>i16</code> はレジスタが16bitで あるためか勝手にexpandされるようだ。
</div>
<div class="footnote" id="_footnotedef_50">
<a href="#_footnoteref_50">50</a>. LLVM IRではオペランドに不適切な 値が渡された場合poison valueを返却し、命令に依存関係がある間はこれを伝播させる。 その後その値が別の場所で使用される（例えばメモリロードのアドレスとして用いられる等） に際してundefに変換され、結果未定義の挙動を行うことになっているようだ<a href="#llvm-langref-poison_value">[80]</a>が、 ちゃんと読んでいない TODO。これがアセンブリとどう対応するのかわからない。 とりあえずinvalidな値が出力されるという認識でよさそうだ。
</div>
<div class="footnote" id="_footnotedef_51">
<a href="#_footnoteref_51">51</a>. というかこれはまさにGCの挙動であって、 コンパイル時に完全に把握することは（ライスの定理的に（言いたかっただけ））不可能ではないのか。
</div>
<div class="footnote" id="_footnotedef_52">
<a href="#_footnoteref_52">52</a>. 使いどころが無いように 思えるが、Ruby VMで実際に使用されているらしい<a href="#github-emscripten-issues-34">[81]</a>。
</div>
<div class="footnote" id="_footnotedef_53">
<a href="#_footnoteref_53">53</a>. 実際にClangが <code>switch</code> 文 を <code>switch</code> 命令 に対応させているかは要調査；TODO。
</div>
<div class="footnote" id="_footnotedef_54">
<a href="#_footnoteref_54">54</a>. あとの作業と直交していて 手を抜けるところはとりあえず抜いておく。
</div>
<div class="footnote" id="_footnotedef_55">
<a href="#_footnoteref_55">55</a>. 実際の出力と <a href="#switch_lowering_in_llvm">[82]</a>からの推論。詳細は要調査；TODO
</div>
<div class="footnote" id="_footnotedef_56">
<a href="#_footnoteref_56">56</a>. 後に登場する <code>hasFP</code> の実装を見ると、具体的にどのような場合に <code>fp</code> が必要となるのか分かる。
</div>
<div class="footnote" id="_footnotedef_57">
<a href="#_footnoteref_57">57</a>. 要するに <code>sp</code> を スタックにpush/popするということである。
</div>
<div class="footnote" id="_footnotedef_58">
<a href="#_footnoteref_58">58</a>. 正確には 書き換わらないレジスタについて記述する。記述しなかったそれ以外のレジスタが 書き換えられるとLLVMは認識する。
</div>
<div class="footnote" id="_footnotedef_59">
<a href="#_footnoteref_59">59</a>. 実際には <code>LowerGlobalAddress</code> と <code>LowerExternalSymbol</code> を呼び出すことで行われている。
</div>
<div class="footnote" id="_footnotedef_60">
<a href="#_footnoteref_60">60</a>. アドレスそのものであって、それが指す値ではないことに注意が必要である。
</div>
<div class="footnote" id="_footnotedef_61">
<a href="#_footnoteref_61">61</a>. パターンを型として指定するというのは若干違和感がある。 要調査。TODO
</div>
<div class="footnote" id="_footnotedef_62">
<a href="#_footnoteref_62">62</a>. これを俗に「バグを泳がせる」と言ったり言わなかったりする。
</div>
<div class="footnote" id="_footnotedef_63">
<a href="#_footnoteref_63">63</a>. 実際には <code>selectLEAAddr</code> 関数内で「 <code>lea</code> 命令に置き換える価値があるか」を判断し（ <code>Complexity</code> ） ているようだ（要確認；TODO）。
</div>
<div class="footnote" id="_footnotedef_64">
<a href="#_footnoteref_64">64</a>. あるいは <code>-triple rv16k--</code> としてもよい。
</div>
<div class="footnote" id="_footnotedef_65">
<a href="#_footnoteref_65">65</a>. 仕様が固まっていない。
</div>
<div class="footnote" id="_footnotedef_66">
<a href="#_footnoteref_66">66</a>. 今決めた。
</div>
<div class="footnote" id="_footnotedef_67">
<a href="#_footnoteref_67">67</a>. ようやく 「コンパイラ」という感じがしてきた。
</div>
<div class="footnote" id="_footnotedef_68">
<a href="#_footnoteref_68">68</a>. <code>CC_RISCV</code> は <code>analyze{Input,Output}Args</code> を通して引数と戻り値の両方に 対応している。
</div>
<div class="footnote" id="_footnotedef_69">
<a href="#_footnoteref_69">69</a>. 示した <code>SDValue</code> クラスの定義に付された コメントで <code>return value to use from that node</code> という書かれ方がされているのは このためであると推察される。
</div>
<div class="footnote" id="_footnotedef_70">
<a href="#_footnoteref_70">70</a>. <code>getValue</code> と言われるとなんとなく親ノードを指すような 気がしてしまうのは私だけだろうか。
</div>
<div class="footnote" id="_footnotedef_71">
<a href="#_footnoteref_71">71</a>. 準同型暗号上で動く プロセッサでは、レジスタやメモリその他全てのデータが暗号化されているため、 外から終了条件を判定することができない。そのため、プロセッサを動作させるサイクル数 を予め指定することで有限時間で終了することを保証する。もちろん、 そのクロック数までに計算が終わらなければ、正しい結果は得られない。
</div>
<div class="footnote" id="_footnotedef_72">
<a href="#_footnoteref_72">72</a>. <code>j</code> 命令は <code>pc</code> を <code>pc + imm + 2</code> に 更新する。従って自分自身にジャンプするためには <code>-2</code> を <code>imm</code> として指定する 必要がある。
</div>
<div class="footnote" id="_footnotedef_73">
<a href="#_footnoteref_73">73</a>. LLVMが作成しているリンカ。GNU ldやgoldよりも動作速度が速い・ コードベースが簡素化されている・新しいターゲットの追加が容易などの利点を有する<a href="#note-n9948f0cc3ed3">[102]</a>。
</div>
<div class="footnote" id="_footnotedef_74">
<a href="#_footnoteref_74">74</a>. <code>.rodata</code> セクションは 実行中変更されることがないためROMで良いように思われるが、そもそもRV16Kでは ROMに配置されたデータにアクセスする方法がないため、実行中参照されるデータは すべてRAMに置かなければいけない。
</div>
<div class="footnote" id="_footnotedef_75">
<a href="#_footnoteref_75">75</a>. 多分。ほんまか？　要調査；TODO
</div>
<div class="footnote" id="_footnotedef_76">
<a href="#_footnoteref_76">76</a>. 一般には、ヘッダの作り方により64bitアドレス空間でもあり得る。
</div>
<div class="footnote" id="_footnotedef_77">
<a href="#_footnoteref_77">77</a>. 実はエントリポイントが <code>0</code> はELFファイルが エントリポイントを保持しないことを意味する<a href="#man-elf">[107]</a>ため、この設計は 若干危うい。RV16Kの使われ方からは問題ないはずだが、要調査；TODO
</div>
<div class="footnote" id="_footnotedef_78">
<a href="#_footnoteref_78">78</a>. <code>objcopy</code> などが使える？ 　要調査；TODO
</div>
<div class="footnote" id="_footnotedef_79">
<a href="#_footnoteref_79">79</a>. これは（暗黙の）仮定。
</div>
<div class="footnote" id="_footnotedef_80">
<a href="#_footnoteref_80">80</a>. <code>.data</code> セクションが <code>0x00010000</code> から始まるとしたため。
</div>
<div class="footnote" id="_footnotedef_81">
<a href="#_footnoteref_81">81</a>. そもそもこの値は32bitのため <code>lw</code> がオペランドとする16bitのスペースに書き込むことができない。
</div>
<div class="footnote" id="_footnotedef_82">
<a href="#_footnoteref_82">82</a>. 多分。記述と処理からの 類推。要確認；TODO
</div>
<div class="footnote" id="_footnotedef_83">
<a href="#_footnoteref_83">83</a>. 今決めた。
</div>
<div class="footnote" id="_footnotedef_84">
<a href="#_footnoteref_84">84</a>. そんなわけはないと思うので要調査；TODO
</div>
<div class="footnote" id="_footnotedef_85">
<a href="#_footnoteref_85">85</a>. コマンドライン引数などを実装すればここで処理を行う必要がある。
</div>
<div class="footnote" id="_footnotedef_86">
<a href="#_footnoteref_86">86</a>. このようにして リンカを指定するのは本来でないかもしれない。要調査；TODO
</div>
<div class="footnote" id="_footnotedef_87">
<a href="#_footnoteref_87">87</a>. デフォルトではldやlldはセクションをページサイズでアラインメントする。 これは静的ライブラリをリンクするために必要なようだ<a href="#man-xtensa_linux_gnu_ld">[106]</a>が、 一方で生成されるバイナリサイズを 大きくしてしまう。そこで <code>--nmagic</code> を指定することでこれを無効化できる。しかしこのオプションは ldには存在するが、我々がベースにしているLLVM 8.0.0のlldには存在しない。 そこで代わりに <code>--omagic</code> を指定する。 これは <code>.text</code> に書き込み可フラグを立てるためセキュリティ上問題があるようだが、 今回の使用方法では問題にならない<a href="#github-blog_os-issues-370">[104]</a>。なおLLVM 8.0.0の リリース後に <code>--nmagic</code> が追加されているようだ<a href="#llvm_phabricator-d61688">[105]</a>。要調査；TODO
</div>
<div class="footnote" id="_footnotedef_88">
<a href="#_footnoteref_88">88</a>. このようにLLDをコマンドとして使用するのは現在のLLDを設計した Rui Ueyamaさんの決定らしい<a href="#note-n9948f0cc3ed3">[102]</a>。
</div>
<div class="footnote" id="_footnotedef_89">
<a href="#_footnoteref_89">89</a>. ここで <code>runtime.s</code> と <code>foo.c</code> の順番を入れ替えるとentry pointの位置が変化する。 ファイル名の順序が <code>.text</code> 中での順序を決定していると推察されるが、 根拠がない。要調査；TODO
</div>
<div class="footnote" id="_footnotedef_90">
<a href="#_footnoteref_90">90</a>. 驚いたことにx86では行われていない。 x86ではアセンブリレベルでは即値に応じて命令を変更する必要がないからかもしれない。要調査；TODO
</div>
<div class="footnote" id="_footnotedef_91">
<a href="#_footnoteref_91">91</a>. 終わっていなければ <code>MachineInstr</code> が 引数として渡されることはない。またframe index ("abstract stack location references") の削除は関数プロローグ・エピローグの挿入と同時に行われ るようだ<a href="#llvm-code_generator">[31]</a>。
</div>
<div class="footnote" id="_footnotedef_92">
<a href="#_footnoteref_92">92</a>. 例えばRISC Vのバックエンドに対して同様の細工をして試してみるなど。
</div>
<div class="footnote" id="_footnotedef_93">
<a href="#_footnoteref_93">93</a>. 本当はコンパイル時にｼｭｯとしてほしい。
</div>
<div class="footnote" id="_footnotedef_94">
<a href="#_footnoteref_94">94</a>. というよりただの 置換だが。
</div>
<div class="footnote" id="_footnotedef_95">
<a href="#_footnoteref_95">95</a>. <code>TargetFrameIndex</code> は命令のオペランドにはなるが、命令そのものには ならないため、という推論。TODO. ちょうど即値のmaterializeと似ているかもしれない
</div>
<div class="footnote" id="_footnotedef_96">
<a href="#_footnoteref_96">96</a>. <code>ADDI</code> の代わりに <code>Constraints</code> のみを外した <code>ADDIhoge</code> を作成して試したところ エラーは発生しなかった。またAVRのバックエンドのコメントには"This is actually "load effective address" of the stack slot instruction. We have only two-address instructions, thus we need to expand it into move + add." とあるので、おそらくこの理解で正しい。
</div>
<div class="footnote" id="_footnotedef_97">
<a href="#_footnoteref_97">97</a>. エラーにして ほしい。方法はないのか。TODO
</div>
<div class="footnote" id="_footnotedef_98">
<a href="#_footnoteref_98">98</a>. 直観的にはそうだが 形式的に証明できるかというと怪しい。TODO
</div>
<div class="footnote" id="_footnotedef_99">
<a href="#_footnoteref_99">99</a>. これは <code>llvm::RegScavenger::scavengeRegister</code> の コメントからも示唆される。
</div>
<div class="footnote" id="_footnotedef_100">
<a href="#_footnoteref_100">100</a>. passが重なると起こりやすいらしい<a href="#llvm-welcome_to_the_back_end_2017">[46]</a>。
</div>
<div class="footnote" id="_footnotedef_101">
<a href="#_footnoteref_101">101</a>. しかしRISC-Vでは 使用しているし良くわからない。TODO
</div>
<div class="footnote" id="_footnotedef_102">
<a href="#_footnoteref_102">102</a>. 例えば <code>eax</code> に <code>0</code> をいれるために <code>xor eax, eax</code> を実行するとき、 <code>eax</code> に（もともと）何が入っているかは重要ではない。
</div>
<div class="footnote" id="_footnotedef_103">
<a href="#_footnoteref_103">103</a>. 分岐解析はレジスタ割り付け までに起こっているはずだと仮定している。TODO
</div>
<div class="footnote" id="_footnotedef_104">
<a href="#_footnoteref_104">104</a>. あちらこちらさまよって一日を費やしたわりには 大したことの無い方法で収まりが付いた。
</div>
<div class="footnote" id="_footnotedef_105">
<a href="#_footnoteref_105">105</a>. ここから <code>jalr</code> を間接分岐と呼ばないことが分かる。
</div>
<div class="footnote" id="_footnotedef_106">
<a href="#_footnoteref_106">106</a>. 同じことをやるならLLVM core側で対応してくれればいいのに。
</div>
<div class="footnote" id="_footnotedef_107">
<a href="#_footnoteref_107">107</a>. 以前の 設計では <code>Bcc</code> を導入していなかったため <code>reverseBranchCondition</code> の実装で問題が発生した。RV16Kには条件分岐の逆の命令は 存在しないのである。これは本質的に <code>CMP</code> と <code>Jcc</code> を分けていることに起因する。
</div>
<div class="footnote" id="_footnotedef_108">
<a href="#_footnoteref_108">108</a>. 悲しい。
</div>
<div class="footnote" id="_footnotedef_109">
<a href="#_footnoteref_109">109</a>. peephole最適化などを行うことができないため、 最適化の観点からは好ましくない。TODO
</div>
<div class="footnote" id="_footnotedef_110">
<a href="#_footnoteref_110">110</a>. LLVMには実際 <code>CMP</code> と <code>SUB</code> が重複した際に これを最適化するようなpeephole最適化の <code>MachineFunctionPass</code> である <code>lib/CodeGen/PeepholeOptimizer.cpp</code> が存在する。
</div>
<div class="footnote" id="_footnotedef_111">
<a href="#_footnoteref_111">111</a>. というかイソップ寓話的にそう思い込んだともいう。
</div>
<div class="footnote" id="_footnotedef_112">
<a href="#_footnoteref_112">112</a>. というかそもそも命令を置き換えるコードを手で書くこと 自体が想定されていないような気がする。
</div>
<div class="footnote" id="_footnotedef_113">
<a href="#_footnoteref_113">113</a>. 長かった。
</div>
<div class="footnote" id="_footnotedef_114">
<a href="#_footnoteref_114">114</a>. 最下位bitとして <code>0</code> が補充されるため。
</div>
<div class="footnote" id="_footnotedef_115">
<a href="#_footnoteref_115">115</a>. しかし <code>PseudoBRIND</code> に <code>isCall</code> や <code>Defs</code> がついている理由はわからない。TODO
</div>
<div class="footnote" id="_footnotedef_116">
<a href="#_footnoteref_116">116</a>. 挙動からの類推。 要調査；TODO
</div>
<div class="footnote" id="_footnotedef_117">
<a href="#_footnoteref_117">117</a>. <code>clearVirtRegs</code> に仕込まれたデバッグ用コードによってエラーが出力される。
</div>
<div class="footnote" id="_footnotedef_118">
<a href="#_footnoteref_118">118</a>. 前向きに探す <code>scavengeRegister</code> はdeprecatedと コメントにある。
</div>
<div class="footnote" id="_footnotedef_119">
<a href="#_footnoteref_119">119</a>. 最新版 ではこれの有効・無効を第五引数の <code>AllowSpill</code> で切り替えられるようだ。TODO
</div>
<div class="footnote" id="_footnotedef_120">
<a href="#_footnoteref_120">120</a>. <code>clang</code> のヘルプをみると、直接 <code>-T</code> オプションを渡すことでリンカスクリプトを指定できるように思えるが、 動かなかった。要調査；TODO
</div>
<div class="footnote" id="_footnotedef_121">
<a href="#_footnoteref_121">121</a>. ただしOpenMPとMPLのためのリンカスクリプトだけは、 <code>tools::AddOpenMPLinkerScript</code> などで動的に作成しているようだ。
</div>
<div class="footnote" id="_footnotedef_122">
<a href="#_footnoteref_122">122</a>. 多分。要確認。TODO
</div>
<div class="footnote" id="_footnotedef_123">
<a href="#_footnoteref_123">123</a>. 一般的 :thinking_face:
</div>
<div class="footnote" id="_footnotedef_124">
<a href="#_footnoteref_124">124</a>. 何らかの理由で <code>.bss</code> の後ろに他の領域を配置したい場合は、 <code>.bss</code> が指定する領域を（ <code>.data</code> のように）ELFバイナリ中に確保するという手もある <a href="#stackoverflow-57735654_34997577">[123]</a>。
</div>
<div class="footnote" id="_footnotedef_125">
<a href="#_footnoteref_125">125</a>. は？
</div>
<div class="footnote" id="_footnotedef_126">
<a href="#_footnoteref_126">126</a>. <code>int</code> の変数一つ がメンバであるなど。
</div>
<div class="footnote" id="_footnotedef_127">
<a href="#_footnoteref_127">127</a>. 例えばx86で「本来 レジスタに収まるために直接渡されるはずの構造体に <code>byval</code> 指定がついた LLVM IRが渡された場合」などを実験する必要がある。TODO
</div>
<div class="footnote" id="_footnotedef_128">
<a href="#_footnoteref_128">128</a>. ただし 返ってくるのは当該要素へのポインタである
</div>
<div class="footnote" id="_footnotedef_129">
<a href="#_footnoteref_129">129</a>. 最適化を有効化した場合に限る。多分；TODO
</div>
<div class="footnote" id="_footnotedef_130">
<a href="#_footnoteref_130">130</a>. <code>TargetLowering::getRegForInlineAsmConstraint</code> の コメントに詳しい。
</div>
<div class="footnote" id="_footnotedef_131">
<a href="#_footnoteref_131">131</a>. branch analysis実装時に <code>llvm_unreachable</code> を仕込んでいたため。
</div>
<div class="footnote" id="_footnotedef_132">
<a href="#_footnoteref_132">132</a>. つまり <code>MachineOperand</code> のレベルでは 既にレジスタが対応している。通常の <code>LowerRV16KMachineInstrToMCInst</code> で 処理できない理由はよくわからない。TODO
</div>
<div class="footnote" id="_footnotedef_133">
<a href="#_footnoteref_133">133</a>. 「メモリアドレスへの パターンマッチ」とは耳慣れない表現だが、インラインアセンブリ以外のコード生成の場合でも メモリアドレスを計算する <code>SelectionDAG</code> へパターンマッチを行いこれを lowerしている。ちなみにこの関数を実装していなければ <code>Could not match memory address.</code> というエラーが出る。
</div>
<div class="footnote" id="_footnotedef_134">
<a href="#_footnoteref_134">134</a>. 参考にしたRISC-V以外の バックエンドでは <code>reg + reg</code> などのアドレッシング・モードが存在 することもあり、より複雑な処理を行っている。実際RISC-Vの実装では、メモリアクセス時に 足される即値が <code>0</code> に固定されている。また <code>FrameIndex</code> の取り扱いなども 不透明だ。ナイーブに考えれば <code>SelectAddrFI</code> の呼出しが必要なはずである。TODO
</div>
<div class="footnote" id="_footnotedef_135">
<a href="#_footnoteref_135">135</a>. コメントより。
</div>
<div class="footnote" id="_footnotedef_136">
<a href="#_footnoteref_136">136</a>. <code>setOperationAction</code> にCustomを指定する必要はないようだ。なぜだろう。TODO
</div>
<div class="footnote" id="_footnotedef_137">
<a href="#_footnoteref_137">137</a>. 他にglibcや newlibなどがある。
</div>
<div class="footnote" id="_footnotedef_138">
<a href="#_footnoteref_138">138</a>. リンクは オブジェクトファイル単位で行われるため、複数の関数を一つの オブジェクトファイルにまとめてしまうと、不要な関数までリンクされてしまう。
</div>
<div class="footnote" id="_footnotedef_139">
<a href="#_footnoteref_139">139</a>. あるいは <code>-Os</code> オプション。 確認した限りにおいて <code>-Os</code> と <code>-Oz</code> は同じように扱われている気がする。
</div>
<div class="footnote" id="_footnotedef_140">
<a href="#_footnoteref_140">140</a>. shrink-wrapの意味がよくわからないが、当該ソースコードを見る限りは 多分こういうこと。
</div>
<div class="footnote" id="_footnotedef_141">
<a href="#_footnoteref_141">141</a>. これがいまいち良くわからない。なぜサイズのために抑制する必要があるのか。TODO
</div>
<div class="footnote" id="_footnotedef_142">
<a href="#_footnoteref_142">142</a>. サイズのためにインライン展開を 抑制すべきというのは理解できるが、一方で <code>static</code> が付与された関数のインライン展開は 抑制されない。扱う場所が違うのかもしれない。TODO
</div>
<div class="footnote" id="_footnotedef_143">
<a href="#_footnoteref_143">143</a>. RV16Kバックエンドの記述の、具体的に どの部分がこれを定めているかははっきりしない。TODO
</div>
<div class="footnote" id="_footnotedef_144">
<a href="#_footnoteref_144">144</a>. また 以下のパターンマッチで使用する <code>isOrEquivalentToAdd</code> でも 同様のチェックを行っているが、これも後述する同様の理由ですり抜けてしまう。
</div>
<div class="footnote" id="_footnotedef_145">
<a href="#_footnoteref_145">145</a>. ただし上記と同様のCテストコードをRISC−Vバックエンドに入力した ところ、同じような問題は発生しなかった。良くわからない。TODO
</div>
<div class="footnote" id="_footnotedef_146">
<a href="#_footnoteref_146">146</a>. ただし関数プロローグ・エピローグでの <code>sp</code> の操作など、 直接 <code>add</code> を生成する場合は除く。
</div>
<div class="footnote" id="_footnotedef_147">
<a href="#_footnoteref_147">147</a>. <a href="#nakata-compiler">[146]</a>では「再計算」と訳されている。このほうが分かりやすい かもしれない。
</div>
<div class="footnote" id="_footnotedef_148">
<a href="#_footnoteref_148">148</a>. もちろんLLVMはOSSのため、9/19以前から 「公開」されていたのだが、言葉の綾である。
</div>
<div class="footnote" id="_footnotedef_149">
<a href="#_footnoteref_149">149</a>. 現在LLVMでは大文字始まり（CamlCase）の変数名が 原則使用されている<a href="#llvm-codingstandards">[151]</a>が、 これを小文字始まり（camlBack）に変更しようという動きがある<a href="#llvm_dev_ml-134921">[152]</a>。 その試行として、LLDにおいて実際に変更が行われた。
</div>
<div class="footnote" id="_footnotedef_150">
<a href="#_footnoteref_150">150</a>. は？
</div>
<div class="footnote" id="_footnotedef_151">
<a href="#_footnoteref_151">151</a>. LLVMのRV32ICもコードサイズが大きくなっていることから、 LLVM coreが悪化したように見える。は？
</div>
<div class="footnote" id="_footnotedef_152">
<a href="#_footnoteref_152">152</a>. キレた。
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-10-01 10:57:34 UTC
</div>
</div>
</body>
</html>